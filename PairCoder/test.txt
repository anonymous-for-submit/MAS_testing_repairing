['\n[NO]']
./outputs/fuzzing/results-test/
Namespace(dataset='codecontest', split_name='test', model='gpt-35-turbo', solution_file_name='solutions.json', id_range=None, id_list=None, dir_path='results_fuzzing', method='pair_programming', output_path='./outputs/fuzzing/results-test/', input_path='/data/zlyuaj/muti-agent/PairCoder/outputs/results-codecontest_gpt-35-turbo/codecontest.jsonl', output_file_name='test', num_generate=10, parallel=0, mutate_method='random', num_round=1000, save_seed=1, recover=0, calc_analyst=1, calc_final_result=1, save_all_seed=0, set_threshold_analyst=1, calc_relative_reward=1, clean_mutate_method=1, split_input=1, mutate_level='sentence', alpha=1.0, beta=1, add_monitor=0, repair_plan=0, repair_code=0, run_multi_gen=0, repair_prompt_num=0)
num_problems: 165
----------------------------------------------------------------------------------------------------
name
1623_E. Middle Duplication
----------------------------------------------------------------------------------------------------
description
A binary tree of n nodes is given. Nodes of the tree are numbered from 1 to n and the root is the node 1. Each node can have no child, only one left child, only one right child, or both children. For convenience, let's denote l_u and r_u as the left and the right child of the node u respectively, l_u = 0 if u does not have the left child, and r_u = 0 if the node u does not have the right child.

Each node has a string label, initially is a single character c_u. Let's define the string representation of the binary tree as the concatenation of the labels of the nodes in the in-order. Formally, let f(u) be the string representation of the tree rooted at the node u. f(u) is defined as follows: $$$ f(u) = \begin{cases} <empty string>, & if u = 0; \\\ f(l_u) + c_u + f(r_u) & otherwise, \end{cases}  where +$$$ denotes the string concatenation operation.

This way, the string representation of the tree is f(1).

For each node, we can duplicate its label at most once, that is, assign c_u with c_u + c_u, but only if u is the root of the tree, or if its parent also has its label duplicated.

You are given the tree and an integer k. What is the lexicographically smallest string representation of the tree, if we can duplicate labels of at most k nodes?

A string a is lexicographically smaller than a string b if and only if one of the following holds: 

  * a is a prefix of b, but a ≠ b; 
  * in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b. 

Input

The first line contains two integers n and k (1 ≤ k ≤ n ≤ 2 ⋅ 10^5).

The second line contains a string c of n lower-case English letters, where c_i is the initial label of the node i for 1 ≤ i ≤ n. Note that the given string c is not the initial string representation of the tree.

The i-th of the next n lines contains two integers l_i and r_i (0 ≤ l_i, r_i ≤ n). If the node i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i = 0.

It is guaranteed that the given input forms a binary tree, rooted at 1.

Output

Print a single line, containing the lexicographically smallest string representation of the tree if at most k nodes have their labels duplicated.

Examples

Input


4 3
abab
2 3
0 0
0 4
0 0


Output


baaaab

Input


8 2
kadracyn
2 5
3 4
0 0
0 0
6 8
0 7
0 0
0 0


Output


daarkkcyan

Input


8 3
kdaracyn
2 5
0 3
0 4
0 0
6 8
0 7
0 0
0 0


Output


darkcyan

Note

The images below present the tree for the examples. The number in each node is the node number, while the subscripted letter is its label. To the right is the string representation of the tree, with each letter having the same color as the corresponding node.

Here is the tree for the first example. Here we duplicated the labels of nodes 1 and 3. We should not duplicate the label of node 2 because it would give us the string "bbaaab", which is lexicographically greater than "baaaab".

<image>

In the second example, we can duplicate the labels of nodes 1 and 2. Note that only duplicating the label of the root will produce a worse result than the initial string.

<image>

In the third example, we should not duplicate any character at all. Even though we would want to duplicate the label of the node 3, by duplicating it we must also duplicate the label of the node 2, which produces a worse result.

<image>

There is no way to produce string "darkkcyan" from a tree with the initial string representation "darkcyan" :(.
----------------------------------------------------------------------------------------------------
public_tests
{'input': ['4 3\nabab\n2 3\n0 0\n0 4\n0 0\n', '8 3\nkdaracyn\n2 5\n0 3\n0 4\n0 0\n6 8\n0 7\n0 0\n0 0\n', '8 2\nkadracyn\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n'], 'is_valid_test': None, 'output': ['baaaab', 'darkcyan', 'daarkkcyan']}
----------------------------------------------------------------------------------------------------
private_tests
{'input': ['10 5\nzlsssrxujq\n4 5\n0 0\n0 0\n10 9\n0 0\n0 3\n0 6\n0 0\n8 7\n0 2\n', '50 50\navzqjbotzkdbrhpknuxxcndqnnkfpthvjriridgnocygczqeyy\n3 50\n0 0\n24 47\n0 0\n0 0\n0 36\n0 0\n42 0\n0 0\n0 0\n0 0\n2 9\n40 0\n0 0\n0 0\n0 0\n20 0\n5 0\n11 32\n0 0\n8 30\n0 34\n0 0\n17 21\n0 0\n0 0\n23 38\n15 39\n0 13\n19 0\n0 7\n10 14\n0 0\n4 41\n48 44\n33 27\n29 0\n0 0\n0 37\n0 0\n45 0\n31 25\n0 0\n12 22\n0 0\n28 26\n6 18\n49 16\n43 0\n46 35\n', '2 1\njb\n2 0\n0 0\n', '10 10\napjukgzrdb\n9 4\n0 7\n0 0\n5 10\n0 0\n2 8\n0 0\n0 0\n0 6\n0 3\n', '10 10\ngweyrwyrwc\n10 5\n6 7\n0 0\n0 0\n0 9\n0 0\n4 0\n0 0\n8 2\n0 3\n', '2 2\nyd\n2 0\n0 0\n', '3 3\nxea\n0 3\n0 0\n0 2\n', '10 10\ndabbsawwmx\n2 9\n0 3\n6 4\n0 0\n0 0\n0 0\n0 0\n5 10\n0 8\n7 0\n', '1 1\nz\n0 0\n', '10 10\nafrkrabttp\n6 7\n3 0\n8 0\n5 0\n9 0\n2 0\n4 10\n0 0\n0 0\n0 0\n', '3 1\nteq\n3 0\n0 0\n2 0\n', '3 2\nuru\n0 3\n0 0\n0 2\n', '10 5\nfpggomfyni\n7 3\n8 0\n0 4\n10 6\n0 0\n0 5\n0 0\n0 0\n0 2\n9 0\n', '50 20\nuyrewzloonruruuvdvvmjmshnonheynpbzkvkdvdihiwbmtjnv\n21 3\n27 0\n41 43\n19 2\n0 0\n46 0\n26 39\n0 0\n0 8\n0 0\n47 0\n38 0\n0 25\n36 24\n30 40\n28 14\n48 0\n0 0\n9 0\n33 23\n31 4\n0 17\n0 0\n0 0\n0 0\n6 50\n0 0\n0 0\n22 49\n0 0\n20 44\n0 0\n5 0\n7 16\n0 0\n0 11\n0 34\n32 0\n0 0\n0 35\n37 45\n0 15\n18 29\n12 13\n10 42\n0 0\n0 0\n0 0\n0 0\n0 0\n'], 'is_valid_test': None, 'output': ['qlssujjxrszzs', 'xnnqqhhoccnnttccddxxkkvvhhttzzbbjjrrddkkddqqjjuuaapffggpnriizznnyyyyeekiivbbzggnnqqrrccoo', 'bj', 'ddppzggraakkuubbj', 'cceeggrrrrwwwwwwyy', 'ddyy', 'xae', 'aaaabbbbddmmsswwwwxx', 'z', 'trfaaaatrkbbp', 'eqt', 'uur', 'ffffggnypiggmmo', 'wbbmmsnnpdduuwwrnjjoooovveennyyuukkmzoovllvzzhvvtruhiinbhyudkrrvimjden']}
----------------------------------------------------------------------------------------------------
generated_tests
{'input': ['3 1\nqet\n3 0\n0 0\n2 0\n', '10 10\ngweyrwzrwc\n10 5\n6 7\n0 0\n0 0\n0 9\n0 0\n4 0\n0 0\n8 2\n0 3\n', '2 4\nyd\n2 0\n0 0\n', '4 0\nabab\n2 3\n0 0\n0 4\n0 0\n', '3 1\nqes\n3 0\n0 0\n2 0\n', '2 2\nye\n2 0\n0 0\n', '3 3\nwea\n0 3\n0 0\n0 2\n', '1 2\nz\n0 0\n', '3 0\nteq\n3 0\n0 0\n2 0\n', '4 0\nabbb\n2 3\n0 0\n0 4\n0 0\n', '2 2\nxe\n2 0\n0 0\n', '2 2\nwe\n2 0\n0 0\n', '2 2\nwd\n2 0\n0 0\n', '2 1\njc\n2 0\n0 0\n', '2 0\nyd\n2 0\n0 0\n', '3 1\nter\n3 0\n0 0\n2 0\n', '8 2\nkadracny\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n', '2 1\nkb\n2 0\n0 0\n', '10 10\npttbarkrfa\n6 7\n3 0\n8 0\n5 0\n9 0\n2 0\n4 10\n0 0\n0 0\n0 0\n', '4 0\nbbaa\n2 3\n0 0\n0 4\n0 0\n', '3 1\nseq\n3 0\n0 0\n2 0\n', '2 1\nxe\n2 0\n0 0\n', '2 1\nkc\n2 0\n0 0\n', '2 0\nyc\n2 0\n0 0\n', '3 2\nter\n3 0\n0 0\n2 0\n', '8 2\nkadradny\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n', '2 1\nye\n2 0\n0 0\n', '3 3\nter\n3 0\n0 0\n2 0\n', '3 4\nxea\n0 3\n0 0\n0 2\n', '10 15\ndabbsawwmx\n2 9\n0 3\n6 4\n0 0\n0 0\n0 0\n0 0\n5 10\n0 8\n7 0\n', '1 1\ny\n0 0\n', '3 2\nuur\n0 3\n0 0\n0 2\n', '10 3\nfpggomfyni\n7 3\n8 0\n0 4\n10 6\n0 0\n0 5\n0 0\n0 0\n0 2\n9 0\n', '4 3\nbaba\n2 3\n0 0\n0 4\n0 0\n', '2 2\new\n2 0\n0 0\n', '2 1\nic\n2 0\n0 0\n', '2 5\nyf\n2 0\n0 0\n', '4 0\naabb\n2 3\n0 0\n0 4\n0 0\n', '3 2\nseq\n3 0\n0 0\n2 0\n', '2 2\nkc\n2 0\n0 0\n', '2 2\nve\n2 0\n0 0\n', '2 2\nic\n2 0\n0 0\n', '2 1\ncy\n2 0\n0 0\n', '2 2\nci\n2 0\n0 0\n', '10 1\nzlsssrxujq\n4 5\n0 0\n0 0\n10 9\n0 0\n0 3\n0 6\n0 0\n8 7\n0 2\n', '10 5\nfpgiomfyng\n7 3\n8 0\n0 4\n10 6\n0 0\n0 5\n0 0\n0 0\n0 2\n9 0\n', '3 1\nser\n3 0\n0 0\n2 0\n', '3 3\nvea\n0 3\n0 0\n0 2\n', '2 2\ndw\n2 0\n0 0\n', '2 5\nze\n2 0\n0 0\n', '2 0\nzd\n2 0\n0 0\n', '3 2\nret\n3 0\n0 0\n2 0\n', '2 1\nhc\n2 0\n0 0\n', '10 1\njlsssrxuzq\n4 5\n0 0\n0 0\n10 9\n0 0\n0 3\n0 6\n0 0\n8 7\n0 2\n', '3 1\nesr\n3 0\n0 0\n2 0\n', '2 5\nez\n2 0\n0 0\n', '2 0\ndz\n2 0\n0 0\n', '10 5\nafrkrabttp\n6 7\n3 0\n8 0\n5 0\n9 0\n2 0\n4 10\n0 0\n0 0\n0 0\n', '3 1\nueq\n3 0\n0 0\n2 0\n', '3 0\ntqe\n3 0\n0 0\n2 0\n', '2 2\nxd\n2 0\n0 0\n', '8 3\nkadracny\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n', '2 1\nbk\n2 0\n0 0\n', '8 1\nkadradny\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n', '2 2\njc\n2 0\n0 0\n', '2 2\ncj\n2 0\n0 0\n', '2 0\ndy\n2 0\n0 0\n', '2 5\ney\n2 0\n0 0\n', '3 1\neqt\n3 0\n0 0\n2 0\n', '3 1\nert\n3 0\n0 0\n2 0\n', '2 2\ndx\n2 0\n0 0\n', '4 6\nabab\n2 3\n0 0\n0 4\n0 0\n', '3 4\naew\n0 3\n0 0\n0 2\n', '2 1\nck\n2 0\n0 0\n', '2 1\nyf\n2 0\n0 0\n', '2 0\nze\n2 0\n0 0\n', '3 5\nxae\n0 3\n0 0\n0 2\n', '8 0\nkadracny\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n', '10 0\nzlstsrxujq\n4 5\n0 0\n0 0\n10 9\n0 0\n0 3\n0 6\n0 0\n8 7\n0 2\n', '3 1\nfrt\n3 0\n0 0\n2 0\n', '2 0\nzf\n2 0\n0 0\n', '2 0\njb\n2 0\n0 0\n', '4 3\nabba\n2 3\n0 0\n0 4\n0 0\n', '2 2\nxf\n2 0\n0 0\n', '4 0\nbbba\n2 3\n0 0\n0 4\n0 0\n', '3 2\ntur\n0 3\n0 0\n0 2\n', '2 2\nyc\n2 0\n0 0\n', '2 1\nbi\n2 0\n0 0\n', '3 5\nxda\n0 3\n0 0\n0 2\n', '2 0\ncx\n2 0\n0 0\n', '10 0\njlsssrxuzq\n4 5\n0 0\n0 0\n10 9\n0 0\n0 3\n0 6\n0 0\n8 7\n0 2\n', '3 1\neuq\n3 0\n0 0\n2 0\n', '3 4\naev\n0 3\n0 0\n0 2\n', '3 4\naex\n0 3\n0 0\n0 2\n', '2 0\nzg\n2 0\n0 0\n', '3 1\nexa\n0 3\n0 0\n0 2\n', '4 3\nacba\n2 3\n0 0\n0 4\n0 0\n', '3 0\naex\n0 3\n0 0\n0 2\n', '3 0\naew\n0 3\n0 0\n0 2\n', '3 3\nwda\n0 3\n0 0\n0 2\n', '3 4\nweb\n0 3\n0 0\n0 2\n', '3 3\ntes\n3 0\n0 0\n2 0\n', '3 6\nteq\n3 0\n0 0\n2 0\n', '10 2\nfpgiomfyng\n7 3\n8 0\n0 4\n10 6\n0 0\n0 5\n0 0\n0 0\n0 2\n9 0\n', '3 3\nret\n3 0\n0 0\n2 0\n', '3 1\nqeu\n3 0\n0 0\n2 0\n', '2 1\nbj\n2 0\n0 0\n', '3 4\neva\n0 3\n0 0\n0 2\n', '2 1\nwe\n2 0\n0 0\n', '2 2\nwf\n2 0\n0 0\n', '4 2\nabca\n2 3\n0 0\n0 4\n0 0\n', '3 2\nurt\n0 3\n0 0\n0 2\n', '10 0\nfpggomfyni\n7 3\n8 0\n0 4\n10 6\n0 0\n0 5\n0 0\n0 0\n0 2\n9 0\n', '1 0\nx\n0 0\n', '2 2\nex\n2 0\n0 0\n', '2 2\ncz\n2 0\n0 0\n', '3 1\nsfr\n3 0\n0 0\n2 0\n', '10 1\njlxssrsuzq\n4 5\n0 0\n0 0\n10 9\n0 0\n0 3\n0 6\n0 0\n8 7\n0 2\n', '10 2\nafrkrabttp\n6 7\n3 0\n8 0\n5 0\n9 0\n2 0\n4 10\n0 0\n0 0\n0 0\n', '8 1\nyndardak\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n', '3 4\nwea\n0 3\n0 0\n0 2\n', '1 0\nz\n0 0\n', '2 4\nye\n2 0\n0 0\n', '2 5\nye\n2 0\n0 0\n', '2 0\nkb\n2 0\n0 0\n', '1 0\ny\n0 0\n', '2 1\nyc\n2 0\n0 0\n', '2 0\nye\n2 0\n0 0\n', '3 6\nter\n3 0\n0 0\n2 0\n', '2 0\nic\n2 0\n0 0\n', '3 5\nxea\n0 3\n0 0\n0 2\n', '2 0\ncy\n2 0\n0 0\n', '2 0\nhc\n2 0\n0 0\n', '2 3\ndw\n2 0\n0 0\n', '10 0\nzlsssrxujq\n4 5\n0 0\n0 0\n10 9\n0 0\n0 3\n0 6\n0 0\n8 7\n0 2\n', '3 4\nvea\n0 3\n0 0\n0 2\n', '2 6\nez\n2 0\n0 0\n', '3 1\ntqe\n3 0\n0 0\n2 0\n', '1 2\ny\n0 0\n', '2 4\ndy\n2 0\n0 0\n', '2 3\new\n2 0\n0 0\n', '2 1\nci\n2 0\n0 0\n', '3 0\nser\n3 0\n0 0\n2 0\n', '2 1\new\n2 0\n0 0\n', '3 1\nxea\n0 3\n0 0\n0 2\n', '1 4\nz\n0 0\n', '2 1\ney\n2 0\n0 0\n', '10 19\npttbarkrfa\n6 7\n3 0\n8 0\n5 0\n9 0\n2 0\n4 10\n0 0\n0 0\n0 0\n', '3 0\neqt\n3 0\n0 0\n2 0\n', '2 3\nwd\n2 0\n0 0\n', '2 5\ndy\n2 0\n0 0\n', '3 7\nxda\n0 3\n0 0\n0 2\n', '2 4\nwd\n2 0\n0 0\n', '4 1\nacba\n2 3\n0 0\n0 4\n0 0\n', '4 2\nacba\n2 3\n0 0\n0 4\n0 0\n', '2 0\nyf\n2 0\n0 0\n', '2 5\nxf\n2 0\n0 0\n', '2 0\ney\n2 0\n0 0\n', '2 0\nci\n2 0\n0 0\n', '2 10\nez\n2 0\n0 0\n', '2 3\nxd\n2 0\n0 0\n', '8 0\nkadradny\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n', '3 1\nret\n3 0\n0 0\n2 0\n', '2 4\ndx\n2 0\n0 0\n', '1 4\ny\n0 0\n', '4 9\nabab\n2 3\n0 0\n0 4\n0 0\n', '2 8\ndy\n2 0\n0 0\n', '3 1\nwea\n0 3\n0 0\n0 2\n', '2 1\nez\n2 0\n0 0\n', '2 2\ncy\n2 0\n0 0\n', '3 0\nqes\n3 0\n0 0\n2 0\n', '2 4\nwe\n2 0\n0 0\n', '2 2\nck\n2 0\n0 0\n', '3 0\nter\n3 0\n0 0\n2 0\n', '2 4\ndw\n2 0\n0 0\n', '2 8\nez\n2 0\n0 0\n', '2 3\nxe\n2 0\n0 0\n', '2 4\njc\n2 0\n0 0\n'], 'is_valid_test': None, 'output': ['etq\n', 'cceeggrrrrwwwwwwyyzz\n', 'ddyy\n', 'baab\n', 'esq\n', 'eeyy\n', 'wae\n', 'z\n', 'eqt\n', 'babb\n', 'eexx\n', 'eeww\n', 'ddww\n', 'cj\n', 'dy\n', 'ert\n', 'daarkkcnay\n', 'bk\n', 'rrttttrrppfaabbkka\n', 'bbaa\n', 'eqs\n', 'ex\n', 'ck\n', 'cy\n', 'errtt\n', 'daarkkdnay\n', 'ey\n', 'eerrtt\n', 'xae\n', 'aaaabbbbddmmsswwwwxx\n', 'y\n', 'uru\n', 'ffffggnypigmo\n', 'aabbba\n', 'we\n', 'ci\n', 'ffyy\n', 'aabb\n', 'eqqss\n', 'cckk\n', 'eevv\n', 'ccii\n', 'yc\n', 'ic\n', 'qlsujxrszs\n', 'ffffggnypggiimo\n', 'ers\n', 'vae\n', 'wd\n', 'eezz\n', 'dz\n', 'etr\n', 'ch\n', 'qlsuzxrsjjs\n', 'sre\n', 'ze\n', 'zd\n', 'trfaaaatrkbbp\n', 'equ\n', 'qet\n', 'ddxx\n', 'daarkkcnaay\n', 'kb\n', 'darkdnay\n', 'ccjj\n', 'jc\n', 'yd\n', 'ye\n', 'qte\n', 'rte\n', 'xd\n', 'baaaab\n', 'aawe\n', 'kc\n', 'fy\n', 'ez\n', 'xea\n', 'darkcnay\n', 'qltujxrszs\n', 'rtf\n', 'fz\n', 'bj\n', 'baaba\n', 'ffxx\n', 'bbba\n', 'tru\n', 'ccyy\n', 'ib\n', 'xad\n', 'xc\n', 'qlsuzxrsjs\n', 'uqe\n', 'aave\n', 'aaxe\n', 'gz\n', 'eax\n', 'caaba\n', 'axe\n', 'awe\n', 'wad\n', 'wbe\n', 'eesstt\n', 'eeqqtt\n', 'ffffgnypgimo\n', 'eettrr\n', 'euq\n', 'jb\n', 'eav\n', 'ew\n', 'ffww\n', 'baaca\n', 'utr\n', 'ffgnypigmo\n', 'x\n', 'xe\n', 'zc\n', 'frs\n', 'qlsuzsrxjjs\n', 'trfaaaatrkbp\n', 'dnaydark\n', 'wae\n', 'z\n', 'eeyy\n', 'eeyy\n', 'bk\n', 'y\n', 'cy\n', 'ey\n', 'eerrtt\n', 'ci\n', 'xae\n', 'yc\n', 'ch\n', 'wd\n', 'qlsujxrszs\n', 'vae\n', 'ze\n', 'qet\n', 'y\n', 'yd\n', 'we\n', 'ic\n', 'ers\n', 'we\n', 'xae\n', 'z\n', 'ye\n', 'rrttttrrppfaabbkka\n', 'qte\n', 'ddww\n', 'yd\n', 'xad\n', 'ddww\n', 'caaba\n', 'caaba\n', 'fy\n', 'ffxx\n', 'ye\n', 'ic\n', 'ze\n', 'ddxx\n', 'darkdnay\n', 'etr\n', 'xd\n', 'y\n', 'baaaab\n', 'yd\n', 'wae\n', 'ze\n', 'yc\n', 'esq\n', 'eeww\n', 'kc\n', 'ert\n', 'wd\n', 'ze\n', 'eexx\n', 'ccjj\n']}
----------------------------------------------------------------------------------------------------
solutions
{'language': ['PYTHON3', 'PYTHON3', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'JAVA', 'JAVA', 'JAVA', 'JAVA', 'JAVA', 'JAVA', 'JAVA', 'JAVA', 'JAVA'], 'solution': ["import sys\nI=lambda:[*map(int, sys.stdin.readline().split())]\n\nleft = []\nright = []\nn, k = I()\nparents = [-1] * n\ns = input()\nfor i in range(n):\n\tl, r = I()\n\tl -= 1\n\tr -= 1\n\tleft.append(l)\n\tright.append(r)\n\tif l >= 0:\n\t\tparents[l] = i\n\tif r >= 0:\n\t\tparents[r] = i\n\ncovered = [0] * n\ncovered.append(1)\norder = []\ncurr = 0\nwhile len(order) < n:\n\tif covered[left[curr]]:\n\t\tif covered[curr]:\n\t\t\tif covered[right[curr]]:\n\t\t\t\tcurr = parents[curr]\n\t\t\telse:\n\t\t\t\tcurr = right[curr]\n\t\telse:\n\t\t\tcovered[curr] = 1\n\t\t\torder.append(curr)\n\telse:\n\t\tcurr = left[curr]\n\nafter = 'a'\nwant = [0] * n\ncurr = s[order[-1]]\nfor i in range(n - 2, -1, -1):\n\tnew = s[order[i]]\n\tif new != curr:\n\t\tafter = curr\n\t\tcurr = new\n\tif curr < after:\n\t\twant[order[i]] = 1\n\ndist = [float('inf')] * n\nfor v in order:\n\tif want[v]:\n\t\tdist[v] = 0\n\telif left[v] >= 0:\n\t\tdist[v] = dist[left[v]] + 1\n\ndupe = [0] * n\nchecked = [0] * n\ncurr = 0\nlef = k\nwhile lef > 0 and curr != -1:\n\tif dupe[curr]:\n\t\tif left[curr] >= 0 and dupe[left[curr]] == 0 and checked[left[curr]] == 0:\n\t\t\tcurr = left[curr]\n\t\telif right[curr] >= 0 and dupe[right[curr]] == 0 and checked[right[curr]] == 0:\n\t\t\tcurr = right[curr]\n\t\telse:\n\t\t\tcurr = parents[curr]\n\telse:\n\t\tif dist[curr] < lef:\n\t\t\tlef -= dist[curr] + 1\n\t\t\tdupe[curr] = 1\n\t\t\tfor i in range(dist[curr]):\n\t\t\t\tcurr = left[curr]\n\t\t\t\tdupe[curr] = 1\n\t\telse:\n\t\t\tchecked[curr] = 1\n\t\t\tcurr = parents[curr]\n\nout = []\nfor guy in order:\n\tif dupe[guy]:\n\t\tout.append(2 * s[guy])\n\telse:\n\t\tout.append(s[guy])\nprint(''.join(out))", '\'\'\' E. Middle Duplication\nhttps://codeforces.com/contest/1623/problem/E\n\'\'\'\n\nimport io, os, sys\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n\nDEBUG = os.environ.get(\'debug\') is not None\n\nif DEBUG:\n    from inspect import currentframe, getframeinfo\n    from re import search\n\ndef debug(*args):\n    if not DEBUG: return\n    frame = currentframe().f_back\n    s = getframeinfo(frame).code_context[0]\n    r = search(r"\\((.*)\\)", s).group(1)\n    vnames = r.split(\', \')\n    var_and_vals = [f\'{var}={val}\' for var, val in zip(vnames, args)]\n    prefix = f\'{currentframe().f_back.f_lineno:02d}: \'\n    print(f\'{prefix}{", ".join(var_and_vals)}\')\n\n\nINF = float(\'inf\')\n\n# -----------------------------------------\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n            else:\n                stack.pop()\n                if not stack: break\n                to = stack[-1].send(to)\n        return to\n    return wrappedfunc\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    S = input().decode().strip()\n\n    L, R = [-1]*N, [-1]*N\n    for p in range(N):\n        l, r = map(int, input().split())\n        L[p], R[p] = l-1, r-1\n\n    # inorder\n    inorder = []\n\n    @bootstrap\n    def dfs1(u):\n        if L[u] > -1: yield dfs1(L[u])\n        inorder.append(u)\n        if R[u] > -1: yield dfs1(R[u])\n        yield None\n    dfs1(0)\n\n    # can duplicate if next different node exists and is greater\n    good = [False]*N\n    last = \'\'\n    for i in range(N-2, -1, -1):\n        u, v = inorder[i], inorder[i+1]\n        if S[u] != S[v]: last = S[v]\n        if S[u] < last: good[u] = True\n\n    # greedily duplicate following inorder \n    # cost = cost if duplicate u; equals distance from u to nearest dup ancestor\n    dup = [False]*N\n\n    @bootstrap\n    def dfs2(u, cost=1):\n        nonlocal K\n        if cost > K: yield\n\n        # dup leftmost possible descendant\n        if L[u] > -1:\n            yield dfs2(L[u], cost+1)\n            \n        # left subtree dup; cost to dup u alr counted\n        if L[u] > -1 and dup[L[u]]: \n            dup[u] = True\n\n        # left subtree undup; subtract cost to dup u and its ancestors\n        elif good[u]:\n            dup[u] = True\n            K -= cost\n        \n        # can only dup right subtree if u dup\n        if R[u] > -1 and dup[u]: \n            yield dfs2(R[u], 1)\n        \n        yield None\n\n    dfs2(0)\n\n    # output\n    print(\'\'.join(S[u]*2 if dup[u] else S[u] for u in inorder))\n\n\nif __name__ == \'__main__\':\n    main()\n\n', '#include <bits/stdc++.h>\nconst int N = 200005;\nint n, k, rem;\nchar c[N];\nint ls[N], rs[N], fa[N];\nint cst[N];\nint from[N];\nbool vis[N], coled[N];\nvoid dfs(int x, int &tt) {\n  if (!x) return;\n  dfs(ls[x], tt), from[++tt] = x, dfs(rs[x], tt);\n  return;\n}\ninline void add(int x) {\n  for (int i = 1; x; x = ls[x], ++i) cst[x] = i;\n  return;\n}\ninline void col(int x) {\n  while (x && !coled[x]) {\n    --rem;\n    add(rs[x]);\n    coled[x] = 1;\n    x = fa[x];\n  }\n  return;\n}\nint main(void) {\n  scanf("%d%d%s", &n, &k, c + 1), rem = k;\n  for (int i = 1; i <= n; ++i) {\n    scanf("%d%d", ls + i, rs + i);\n    if (ls[i]) fa[ls[i]] = i;\n    if (rs[i]) fa[rs[i]] = i;\n  }\n  int tt = 0;\n  dfs(1, tt);\n  vis[n] = 0;\n  for (int i = n - 1; i >= 1; --i)\n    if (c[from[i]] < c[from[i + 1]] ||\n        (c[from[i]] == c[from[i + 1]] && vis[i + 1]))\n      vis[i] = 1;\n  add(1);\n  for (int i = 1; i <= n; ++i) {\n    if (coled[from[i]]) continue;\n    if (cst[from[i]] != 0 && cst[from[i]] <= rem && vis[i]) col(from[i]);\n  }\n  for (int i = 1; i <= n; ++i) {\n    putchar(c[from[i]]);\n    if (coled[from[i]]) putchar(c[from[i]]);\n  }\n  putchar(\'\\n\');\n  return 0;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nint ls[maxn], rs[maxn], good[maxn], a[maxn], cp[maxn];\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  for (int i = 1; i <= n; ++i) a[i] = s[i - 1] - 'a';\n  for (int i = 1; i <= n; ++i) cin >> ls[i] >> rs[i];\n  vector<int> b;\n  function<void(int)> dfs = [&](int u) {\n    if (ls[u]) dfs(ls[u]);\n    b.push_back(u);\n    if (rs[u]) dfs(rs[u]);\n  };\n  dfs(1);\n  good[b[n - 1]] = 0;\n  for (int i = n - 2; i >= 0; --i) {\n    if (a[b[i]] < a[b[i + 1]] || (a[b[i]] == a[b[i + 1]] && good[b[i + 1]]))\n      good[b[i]] = 1;\n  }\n  function<void(int)> dfs2 = [&](int u) {\n    if (!u) return;\n    vector<int> c;\n    int p = u;\n    while (p && !good[p]) {\n      c.push_back(p);\n      p = ls[p];\n    }\n    if (good[p] && c.size() + 1 <= k) {\n      k -= c.size() + 1;\n      cp[p] = 1, dfs2(ls[p]), dfs2(rs[p]);\n      while (!c.empty()) {\n        cp[c.back()] = 1, dfs2(rs[c.back()]), c.pop_back();\n      }\n    }\n  };\n  dfs2(1);\n  string ans;\n  function<void(int)> dfs3 = [&](int u) {\n    if (ls[u]) dfs3(ls[u]);\n    ans += a[u] + 'a';\n    if (cp[u]) ans += a[u] + 'a';\n    if (rs[u]) dfs3(rs[u]);\n  };\n  dfs3(1);\n  cout << ans << '\\n';\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nconst int inf = 2147483647;\nlong long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') x = x * 10ll + ch - '0', ch = getchar();\n  return x * f;\n}\nint n, k, lc[N], rc[N], a[N], id, dep[N], dfn, L[N], R[N], fa[N];\nchar d[N];\nbool v[N];\nstring str, s;\nlong long o[N];\nvoid add(int x, long long v) {\n  for (; x <= n; x += (x & (-x))) o[x] += v;\n}\nvoid Add(int l, int r, long long v) { add(l, v), add(r + 1, -v); }\nlong long query(int x) {\n  long long t = 0;\n  for (; x; x -= (x & (-x))) t += o[x];\n  return t;\n}\nvoid dfs1(int x) {\n  if (lc[x]) dep[lc[x]] = dep[x] + 1, dfs1(lc[x]);\n  s += str[x - 1];\n  a[++id] = x;\n  if (rc[x]) dep[rc[x]] = dep[x] + 1, dfs1(rc[x]);\n}\nvoid dfs2(int x) {\n  L[x] = ++dfn;\n  if (lc[x]) dfs2(lc[x]);\n  if (rc[x]) dfs2(rc[x]);\n  R[x] = dfn;\n}\nvoid dfs3(int x) {\n  if (lc[x]) dfs3(lc[x]);\n  putchar(str[x - 1]);\n  if (v[x]) putchar(str[x - 1]);\n  if (rc[x]) dfs3(rc[x]);\n}\nint main() {\n  n = read(), k = read();\n  cin >> str;\n  for (int i = 1; i <= n; i++) {\n    lc[i] = read(), rc[i] = read();\n    if (lc[i]) fa[lc[i]] = i;\n    if (rc[i]) fa[rc[i]] = i;\n  }\n  s += '#';\n  dfs1(1);\n  s += ' ';\n  d[n] = ' ';\n  for (int i = n - 1; i; i--)\n    if (s[i] == s[i + 1])\n      d[i] = d[i + 1];\n    else\n      d[i] = s[i + 1];\n  dfs2(1);\n  for (int i = 1; i <= n; i++) Add(L[i], L[i], dep[i] + 1);\n  for (int i = 1; i <= n; i++) {\n    if (v[a[i]]) continue;\n    if (s[i] < d[i] && query(L[a[i]]) <= k) {\n      int t = a[i];\n      while (t && !v[t]) {\n        v[t] = true;\n        k--;\n        Add(L[t], R[t], -1);\n        t = fa[t];\n      }\n    } else if (s[i] > d[i])\n      Add(L[a[i]], R[a[i]], inf);\n  }\n  dfs3(1);\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 202020;\nint n, k;\nstring c;\nint l[maxn], r[maxn];\nvector<int> in_order;\nvoid build_in_order(int u) {\n  if (u == 0) return;\n  build_in_order(l[u]);\n  in_order.push_back(u);\n  build_in_order(r[u]);\n}\nbool good[maxn];\nbool duplicated[maxn];\nvoid dfs(int u, int cost = 1) {\n  if (u == 0) return;\n  if (cost > k) return;\n  dfs(l[u], cost + 1);\n  if (duplicated[l[u]]) {\n    duplicated[u] = true;\n  } else if (good[u]) {\n    duplicated[u] = true;\n    k -= cost;\n  }\n  if (duplicated[u]) dfs(r[u], 1);\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n >> k;\n  cin >> c;\n  c = ' ' + c;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  build_in_order(1);\n  char last_diff = c[in_order.back()];\n  for (int i = n - 2; i >= 0; --i) {\n    int u = in_order[i];\n    int v = in_order[i + 1];\n    if (c[u] != c[v]) {\n      last_diff = c[v];\n    }\n    if (c[u] < last_diff) {\n      good[u] = true;\n    }\n  }\n  dfs(1);\n  for (auto u : in_order) {\n    cout << c[u];\n    if (duplicated[u]) cout << c[u];\n  }\n  return 0;\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char c = getchar();\n  for (; !isdigit(c); c = getchar())\n    if (c == \'-\') f = -1;\n  for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + (c ^ 48);\n  return x * f;\n}\ninline void out(int x) {\n  if (x > 9) out(x / 10);\n  putchar(x % 10 + 48);\n}\ninline void print(int x) {\n  if (x < 0) putchar(\'-\'), x = -x;\n  out(x), puts("");\n}\nconst int N = 2e5 + 10;\nchar s[N];\nint son[N][2], ord[N], cpy[N], f[N], n, k, cnt;\nvoid dfs1(int x) {\n  if (!x) return;\n  dfs1(son[x][0]), ord[cnt++] = x, dfs1(son[x][1]);\n}\nvoid dfs2(int x, int cost) {\n  if (!x) return;\n  if (cost > k) return;\n  dfs2(son[x][0], cost + 1);\n  if (cpy[son[x][0]])\n    cpy[x] = 1;\n  else if (f[x])\n    cpy[x] = 1, k -= cost;\n  if (cpy[x]) dfs2(son[x][1], 1);\n}\nint main() {\n  n = read(), k = read();\n  scanf("%s", s + 1);\n  for (int i = 1; i <= n; i++) son[i][0] = read(), son[i][1] = read();\n  dfs1(1);\n  for (int i = n - 1, lst = n - 1; i; i--) {\n    if (s[ord[i - 1]] != s[ord[i]]) lst = i;\n    if (s[ord[i - 1]] < s[ord[lst]]) f[ord[i - 1]] = 1;\n  }\n  dfs2(1, 1);\n  for (int i = 0; i < n; i++) {\n    printf("%c", s[ord[i]]);\n    if (cpy[ord[i]]) printf("%c", s[ord[i]]);\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nvoid io(string in = "", string out = "", string err = "") {\n  if (fopen(in.c_str(), "r")) {\n    freopen(in.c_str(), "r", stdin);\n    freopen(out.c_str(), "w", stdout);\n  }\n}\nvoid conv();\nint main() {\n  io(""\n     ".inp",\n     ""\n     ".out");\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int Q = 1;\n  while (Q--) {\n    conv();\n  }\n  return 0;\n}\nvoid dfs(int i, vector<int>& ord, const vector<array<int, 2>>& x) {\n  if (i >= 0) {\n    dfs(x[i][0], ord, x);\n    ord.push_back(i);\n    dfs(x[i][1], ord, x);\n  }\n}\nbool dfs(int i, int cost, int& k, vector<bool>& dup, const vector<bool>& sp,\n         const vector<array<int, 2>>& x) {\n  if (i >= 0 && cost <= k) {\n    if (dfs(x[i][0], cost + 1, k, dup, sp, x))\n      dup[i] = 1;\n    else if (sp[i])\n      dup[i] = 1, k -= cost;\n    if (dup[i]) dfs(x[i][1], 1, k, dup, sp, x);\n    return dup[i];\n  }\n  return 0;\n}\nvoid conv() {\n  int N, K;\n  string c;\n  cin >> N >> K >> c;\n  vector<array<int, 2>> x(N);\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      cin >> x[i][j];\n      --x[i][j];\n    }\n  }\n  vector<int> ord;\n  dfs(0, ord, x);\n  vector<bool> sp(N, 0);\n  char lst = c[ord.back()];\n  for (int i = N - 2; i >= 0; --i) {\n    int u = ord[i], v = ord[i + 1];\n    if (c[u] != c[v]) lst = c[v];\n    if (c[u] < lst) sp[u] = 1;\n  }\n  vector<bool> dup(N, 0);\n  dfs(0, 1, K, dup, sp, x);\n  for (int i : ord) {\n    for (int t = 1 + dup[i]; t--;) {\n      cout << c[i];\n    }\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint l[200005], r[200005];\nint ans_string_pos[200005];\nint pre[200005];\nint to_pos = 0;\nint check_double[200005], check_fa[200005];\nchar s[200005];\nint n, k;\nvoid build(int pos) {\n  if (pos) {\n    build(l[pos]);\n    ans_string_pos[pos] = ++to_pos;\n    pre[to_pos] = pos;\n    build(r[pos]);\n  }\n}\nvoid pri(int pos) {\n  if (pos) {\n    pri(l[pos]);\n    cout << s[pos];\n    if (check_double[pos]) cout << s[pos];\n    pri(r[pos]);\n  }\n}\nint dfs(int pos, int dep) {\n  if (l[pos] && dfs(l[pos], dep + 1)) check_double[pos] = 1;\n  if (r[pos]) {\n    if (check_double[pos] || (check_fa[ans_string_pos[pos]] && k >= dep)) {\n      if (!check_double[pos]) {\n        check_double[pos] = 1;\n        k -= dep;\n      }\n      dfs(r[pos], 1);\n    } else if (dfs(r[pos], 0x3f3f3f3f))\n      check_double[pos] = 1;\n  } else if (!check_double[pos] && check_fa[ans_string_pos[pos]] && k >= dep) {\n    check_double[pos] = 1;\n    k -= dep;\n  }\n  return check_double[pos];\n}\nvoid solve() {\n  cin >> n >> k >> (s + 1);\n  for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  build(1);\n  for (int i = n - 1; i > 0; i--) {\n    if (s[pre[i]] != s[pre[i + 1]]) {\n      check_fa[i] = (s[pre[i]] < s[pre[i + 1]]);\n    } else {\n      check_fa[i] = check_fa[i + 1];\n    }\n  }\n  dfs(1, 1);\n  pri(1);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  solve();\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint fa[200000 + 5], chain[200000 + 5], dep[200000 + 5];\nchar s[200000 + 5];\nint p[200000 + 5], l[200000 + 5], r[200000 + 5], m;\nvoid dfs(int u) {\n  if (!u) return;\n  if (l[u]) {\n    fa[l[u]] = u;\n    dep[l[u]] = dep[u] + 1;\n    chain[l[u]] = chain[u];\n  }\n  dfs(l[u]);\n  p[++m] = u;\n  if (r[u]) {\n    fa[r[u]] = u;\n    dep[r[u]] = dep[u] + 1;\n    chain[r[u]] = r[u];\n  }\n  dfs(r[u]);\n}\nbool vis[200000 + 5], minn[200000 + 5];\nint main() {\n  int n, k, i, j;\n  scanf("%d%d", &n, &k);\n  scanf("%s", s + 1);\n  for (i = 1; i <= n; i++) scanf("%d%d", &l[i], &r[i]);\n  chain[1] = dep[1] = 1;\n  fa[1] = 0;\n  vis[0] = true;\n  dfs(1);\n  for (i = n - 1; i >= 1; i--)\n    if (s[p[i]] < s[p[i + 1]])\n      minn[i] = true;\n    else if (s[p[i]] == s[p[i + 1]])\n      minn[i] = minn[i + 1];\n  for (i = 1; i <= n; i++) {\n    if (minn[i]) {\n      if (dep[p[i]] - dep[chain[p[i]]] + 1 <= k && vis[fa[chain[p[i]]]] &&\n          !vis[p[i]]) {\n        int u = p[i];\n        while (u == l[fa[u]] && !vis[u]) vis[u] = true, k--, u = fa[u];\n        if (!vis[u]) vis[u] = true, k--;\n      }\n    }\n  }\n  for (i = 1; i <= n; i++) {\n    printf("%c", s[p[i]]);\n    if (vis[p[i]]) printf("%c", s[p[i]]);\n  }\n  printf("\\n");\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int N, K;\n  string S;\n  cin >> N >> K >> S;\n  vector<int> L(N), R(N);\n  for (int i = 0; i < N; ++i) {\n    cin >> L[i] >> R[i];\n    --L[i], --R[i];\n  }\n  vector<int> r;\n  function<void(int)> Pre = [&](int v) {\n    if (v == -1) {\n      return;\n    }\n    Pre(L[v]);\n    r.push_back(v);\n    Pre(R[v]);\n  };\n  Pre(0);\n  string next(N, '*');\n  for (int i = N - 2; i >= 0; --i) {\n    next[r[i]] = (S[r[i + 1]] == S[r[i]] ? next : S)[r[i + 1]];\n  }\n  void(37);\n  void(37);\n  vector<int> need(N, 1);\n  vector<int> vis(N);\n  function<void(int)> Dfs = [&](int v) {\n    void(37);\n    if (L[v] != -1) {\n      need[L[v]] = need[v] + 1;\n      Dfs(L[v]);\n      vis[v] |= vis[L[v]];\n    }\n    if (!vis[v] && need[v] <= K && next[v] > S[v]) {\n      vis[v] = true;\n      K -= need[v];\n    }\n    if (vis[v] && R[v] != -1) {\n      Dfs(R[v]);\n    }\n  };\n  Dfs(0);\n  string res;\n  for (auto v : r) {\n    res += string(1 + vis[v], S[v]);\n  }\n  cout << res << '\\n';\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nvector<array<int, 2>> adj;\nvector<int> nxt;\nvector<int> lst;\nvector<int> ord;\nvector<bool> mark;\nvector<int> depth;\nvector<int> p;\nvoid dfs(int curr, int par, bool left = false) {\n  if (curr == -1) return;\n  if (par != -1) {\n    depth[curr] = depth[par] + 1;\n  }\n  if (left) {\n    lst[curr] = lst[par];\n  } else {\n    lst[curr] = par;\n  }\n  dfs(adj[curr][0], curr, true);\n  ord.push_back(curr);\n  p[curr] = par;\n  dfs(adj[curr][1], curr, false);\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  string c;\n  cin >> c;\n  adj.resize(n);\n  nxt.resize(n, -1);\n  lst.resize(n, -1);\n  depth.resize(n);\n  p.resize(n);\n  for (int i = 0; i < n; i++) {\n    int l, r;\n    cin >> l >> r;\n    --l, --r;\n    adj[i][0] = l;\n    adj[i][1] = r;\n  }\n  dfs(0, -1);\n  for (int i = ord.size() - 1; i >= 0; i--) {\n    int curr = ord[i];\n    if (i == ord.size() - 1) {\n      nxt[curr] = -1;\n    } else {\n      if (c[curr] != c[ord[i + 1]]) {\n        nxt[curr] = c[ord[i + 1]] - \'a\';\n      } else {\n        nxt[curr] = nxt[ord[i + 1]];\n      }\n    }\n  }\n  string ans = "";\n  mark.resize(n, false);\n  for (int i = 0; i < ord.size(); i++) {\n    int curr = ord[i];\n    if (!mark[curr] && nxt[curr] != -1 && c[curr] - \'a\' < nxt[curr]) {\n      bool up = false;\n      up |= lst[curr] == -1 && k >= depth[curr] + 1;\n      up |= lst[curr] != -1 && mark[lst[curr]] &&\n            k >= depth[curr] - depth[lst[curr]];\n      for (int x = curr; up && x != lst[curr] && !mark[x]; x = p[x]) {\n        mark[x] = true;\n        --k;\n      }\n    }\n    if (mark[curr]) {\n      ans += c[curr];\n    }\n    ans += c[curr];\n  }\n  cout << ans << "\\n";\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nint SIZE(T(&t)) {\n  return t.size();\n}\ntemplate <typename T, size_t N>\nint SIZE(T (&t)[N]) {\n  return N;\n}\nstring to_string(char t) { return "\'" + string({t}) + "\'"; }\nstring to_string(bool t) { return t ? "true" : "false"; }\nstring to_string(const string& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)), _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += t[i];\n  }\n  return \'"\' + ret + \'"\';\n}\nstring to_string(const char* t) {\n  string ret(t);\n  return to_string(ret);\n}\ntemplate <size_t N>\nstring to_string(const bitset<N>& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)); i <= min(x2, SIZE(t) - 1); ++i) {\n    ret += t[i] + \'0\';\n  }\n  return to_string(ret);\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1 = 0, int x2 = 1e9, Coords... C);\ntemplate <typename T, typename S>\nstring to_string(const pair<T, S>& t) {\n  return "(" + to_string(t.first) + ", " + to_string(t.second) + ")";\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1, int x2, Coords... C) {\n  string ret = "[";\n  x1 = min(x1, SIZE(t));\n  auto e = begin(t);\n  advance(e, x1);\n  for (int i = x1, _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += to_string(*e, C...) + (i != _i ? ", " : "");\n    e = next(e);\n  }\n  return ret + "]";\n}\ntemplate <int Index, typename... Ts>\nstruct print_tuple {\n  string operator()(const tuple<Ts...>& t) {\n    string ret = print_tuple<Index - 1, Ts...>{}(t);\n    ret += (Index ? ", " : "");\n    return ret + to_string(get<Index>(t));\n  }\n};\ntemplate <typename... Ts>\nstruct print_tuple<0, Ts...> {\n  string operator()(const tuple<Ts...>& t) { return to_string(get<0>(t)); }\n};\ntemplate <typename... Ts>\nstring to_string(const tuple<Ts...>& t) {\n  const auto Size = tuple_size<tuple<Ts...>>::value;\n  return print_tuple<Size - 1, Ts...>{}(t);\n}\nvoid dbgr() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgr(Heads H, Tails... T) {\n  cout << to_string(H) << " | ";\n  dbgr(T...);\n}\nvoid dbgs() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgs(Heads H, Tails... T) {\n  cout << H << " ";\n  dbgs(T...);\n}\nconst int N = 2e5 + 5;\nconst long long INF = 1e18 + 7;\nconst int MAXA = 1e9;\nconst int B = sqrt(N) + 5;\nint l[N], r[N], pv[N];\nbool dou[N], ok[N];\nstring s;\ndeque<int> pos[N];\nint n, k;\nvoid dfs(int u) {\n  if (u == 0) return;\n  dfs(l[u]);\n  dfs(r[u]);\n  if (pos[l[u]].size() > pos[r[u]].size()) {\n    swap(pos[u], pos[l[u]]);\n    pos[u].push_back(u);\n    for (int i : pos[r[u]]) {\n      pos[u].push_back(i);\n    }\n    pos[r[u]].clear();\n  } else {\n    swap(pos[u], pos[r[u]]);\n    pos[u].push_front(u);\n    reverse(pos[l[u]].begin(), pos[l[u]].end());\n    for (int i : pos[l[u]]) {\n      pos[u].push_front(i);\n    }\n    pos[l[u]].clear();\n  }\n}\nbool dfs_opt(int u, int h) {\n  bool f = false;\n  if (ok[pv[u]] && k >= h) {\n    k -= h;\n    dou[u] = true;\n    if (l[u]) dfs_opt(l[u], 1);\n    if (r[u]) dfs_opt(r[u], 1);\n    return true;\n  } else {\n    if (l[u]) f |= dfs_opt(l[u], h + 1);\n    if (f) dou[u] = true;\n    if (dou[u] && r[u]) dfs_opt(r[u], 1);\n    return dou[u];\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  cin >> s;\n  s = " " + s;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  dfs(1);\n  string first = " ";\n  for (int i : pos[1]) first += s[i];\n  s = first;\n  for (int i = 0; i < n; ++i) pv[pos[1][i]] = i + 1;\n  int l = 1;\n  for (int i = 1; i < n; ++i) {\n    if (s[i] != s[i + 1]) {\n      if (s[i] < s[i + 1]) {\n        for (int j = l; j <= i; ++j) ok[j] = true;\n      }\n      l = i + 1;\n    }\n  }\n  dfs_opt(1, 1);\n  for (int i = 1; i <= n; ++i) {\n    cout << s[i];\n    if (dou[pos[1][i - 1]]) cout << s[i];\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nconst int N = 200007;\nint le[N], ri[N];\nint id[N], fn[N];\nint a[N], nxt[N], clc;\nint tag[N], dup[N];\nstring s;\nvoid dfs(int x) {\n  if (x == 0) return;\n  dfs(le[x]);\n  id[fn[x] = ++clc] = x;\n  a[clc] = s[x] - 'a' + 1;\n  dfs(ri[x]);\n}\nint gao(int x, int r) {\n  if (x == 0) return 0;\n  if (r <= 0) return 0;\n  int use = gao(le[x], r - 1);\n  if (use) {\n    dup[x] = 1;\n    r -= use + 1;\n    return gao(ri[x], r) + use + 1;\n  } else {\n    if (tag[x]) {\n      dup[x] = 1;\n      return gao(ri[x], r - 1) + 1;\n    } else {\n      dup[x] = 0;\n      return 0;\n    }\n  }\n}\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  cin >> s;\n  s = ' ' + s;\n  for (int i = 1; i <= n; i++) {\n    cin >> le[i] >> ri[i];\n  }\n  clc = 0;\n  dfs(1);\n  a[clc + 1] = 0;\n  for (int i = clc; i >= 1; i--) {\n    if (a[i] != a[i + 1]) {\n      nxt[i] = a[i + 1];\n    } else {\n      nxt[i] = nxt[i + 1];\n    }\n    assert(nxt[i] != a[i]);\n    if (nxt[i] > a[i]) {\n      tag[id[i]] = 1;\n    } else {\n      tag[id[i]] = 0;\n    }\n  }\n  for (int i = 1; i <= n; i++) dup[i] = 0;\n  gao(1, k);\n  for (int i = 1; i <= n; i++) {\n    char ch = s[id[i]];\n    cout << ch;\n    if (dup[id[i]]) cout << ch;\n  }\n  cout << '\\n';\n}\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int t = 1;\n  while (t--) solve();\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10, mod = 1e9 + 7;\nchar val[N];\nint n, k, lft[N], done[N], dup[N], rt[N], depth[N], ord[N];\nvector<int> order;\nstring ans, ans2;\nvoid dfs(int node = 1, int par = 1) {\n  depth[node] = depth[par] + 1;\n  if (lft[node]) dfs(lft[node], node);\n  order.push_back(node);\n  ord[node] = order.size() - 1;\n  ans.push_back(val[node]);\n  if (rt[node]) dfs(rt[node], node);\n}\nvoid dfs2(int node, int &dep, int ynf3) {\n  if (lft[node]) dfs2(lft[node], dep, ynf3);\n  if (dep > depth[node]) {\n    done[ord[node]] = 1;\n    dep = depth[node];\n  } else if (dup[ord[node]] && depth[node] - dep <= k && ynf3) {\n    k -= depth[node] - dep;\n    done[ord[node]] = 1;\n    dep = depth[node];\n  }\n  if (rt[node]) dfs2(rt[node], dep, done[ord[node]]);\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> k;\n  string st;\n  cin >> st;\n  for (int i = 1; i <= n; i++) {\n    val[i] = st[i - 1];\n    cin >> lft[i] >> rt[i];\n  }\n  dfs();\n  dup[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (ans[i] == ans[i + 1])\n      dup[i] = dup[i + 1];\n    else if (ans[i] < ans[i + 1])\n      dup[i] = 1;\n  }\n  int dep = 0;\n  dfs2(1, dep, 1);\n  for (int i = 0; i < ans.size(); i++) {\n    ans2.push_back(ans[i]);\n    if (done[i]) ans2.push_back(ans[i]);\n  }\n  cout << ans2;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nlong long MOD = 10000007;\ndouble eps = 1e-12;\nusing namespace std;\nconst int maxn = 202020;\nint n, k;\nstring c;\nint l[maxn], r[maxn];\nvector<int> in_order;\nvoid build_in_order(int u) {\n  if (u == 0) return;\n  build_in_order(l[u]);\n  in_order.push_back(u);\n  build_in_order(r[u]);\n}\nbool good[maxn];\nbool duplicated[maxn];\nvoid dfs(int u, int cost = 1) {\n  if (u == 0) return;\n  if (cost > k) return;\n  dfs(l[u], cost + 1);\n  if (duplicated[l[u]]) {\n    duplicated[u] = true;\n  } else if (good[u]) {\n    duplicated[u] = true;\n    k -= cost;\n  }\n  if (duplicated[u]) dfs(r[u], 1);\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n >> k;\n  cin >> c;\n  c = ' ' + c;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  build_in_order(1);\n  char last_diff = c[in_order.back()];\n  for (int i = n - 2; i >= 0; --i) {\n    int u = in_order[i];\n    int v = in_order[i + 1];\n    if (c[u] != c[v]) {\n      last_diff = c[v];\n    }\n    if (c[u] < last_diff) {\n      good[u] = true;\n    }\n  }\n  dfs(1);\n  for (auto u : in_order) {\n    cout << c[u];\n    if (duplicated[u]) cout << c[u];\n  }\n  return 0;\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nlong long __gcd(long long a, long long b) {\n  return b == 0 ? a : __gcd(b, a % b);\n}\ntypedef pair<pair<int, int>, int> III;\nint par[1 << 18][18];\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<int> l(n), r(n);\n  par[0][0] = -1;\n  for (int i = 0; i < n; i++) {\n    cin >> l[i] >> r[i];\n    l[i]--;\n    r[i]--;\n    if (l[i] >= 0) par[l[i]][0] = i;\n    if (r[i] >= 0) par[r[i]][0] = i;\n  }\n  for (int j = 0; j < 17; j++) {\n    for (int i = 0; i < n; i++) {\n      if (par[i][j] < 0)\n        par[i][j + 1] = -1;\n      else\n        par[i][j + 1] = par[par[i][j]][j];\n    }\n  }\n  vector<int> ids;\n  function<void(int)> dfs = [&](int id) {\n    if (l[id] >= 0) dfs(l[id]);\n    ids.push_back(id);\n    if (r[id] >= 0) dfs(r[id]);\n  };\n  dfs(0);\n  vector<bool> b(n);\n  for (int i = 0; i < n; i++) {\n    int le = i;\n    while (i + 1 < n && s[ids[i]] == s[ids[i + 1]]) i++;\n    if (i + 1 == n || s[ids[i + 1]] < s[ids[i]]) {\n      for (int j = le; j <= i; j++) b[ids[j]] = true;\n    }\n  }\n  vector<bool> used(n);\n  string ans;\n  function<void(int)> dfs3 = [&](int id) {\n    if (l[id] >= 0) dfs3(l[id]);\n    ans.push_back(s[id]);\n    if (r[id] >= 0) dfs3(r[id]);\n  };\n  function<void(int)> dfs2 = [&](int id) {\n    if (l[id] >= 0) dfs2(l[id]);\n    if (!used[id]) {\n      if (!b[id]) {\n        int cur = id;\n        int ad = 1;\n        for (int j = 17; j >= 0; j--) {\n          int p = par[cur][j];\n          if (p >= 0 && !used[p]) {\n            ad += (1 << j);\n            cur = p;\n          }\n        }\n        if (ad <= k) {\n          k -= ad;\n          cur = id;\n          while (cur >= 0 && !used[cur]) {\n            used[cur] = true;\n            cur = par[cur][0];\n          }\n        }\n      }\n    }\n    if (used[id]) {\n      ans.push_back(s[id]);\n      ans.push_back(s[id]);\n      if (r[id] >= 0) dfs2(r[id]);\n    } else {\n      ans.push_back(s[id]);\n      if (r[id] >= 0) dfs3(r[id]);\n    }\n  };\n  dfs2(0);\n  cout << ans << "\\n";\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  solve();\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int w = 200010;\nint n, k;\nstring s;\nint l[w], r[w];\nbool good[w];\nbool cpy[w];\nvector<int> vec;\nvoid build(int u) {\n  if (l[u]) build(l[u]);\n  vec.push_back(u);\n  if (r[u]) build(r[u]);\n}\nvoid dfs(int u, int cnt) {\n  if (cnt > k) return;\n  if (l[u]) dfs(l[u], cnt + 1);\n  if (cpy[l[u]]) {\n    cpy[u] = true;\n  } else if (good[u]) {\n    cpy[u] = true;\n    k -= cnt;\n  }\n  if (cpy[u] && r[u]) dfs(r[u], 1);\n}\nint main() {\n  cin >> n >> k;\n  cin >> s;\n  s = \' \' + s;\n  for (int i = 1; i <= n; i++) {\n    int a, b;\n    scanf("%d%d", &a, &b);\n    l[i] = a, r[i] = b;\n  }\n  build(1);\n  char last = s[vec[n - 1]];\n  for (int i = n - 2; i >= 0; i--) {\n    int a = vec[i], b = vec[i + 1];\n    if (s[a] != s[b]) {\n      last = s[b];\n    }\n    if (s[a] < last) {\n      good[a] = true;\n    }\n  }\n  dfs(1, 1);\n  for (int i = 0; i < vec.size(); i++) {\n    int t = vec[i];\n    cout << s[t];\n    if (cpy[t]) cout << s[t];\n  }\n  cout << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \' \' << H;\n  debug_out(T...);\n}\nconst long long MOD = 1e9 + 7;\nconst int N = 2e5 + 1;\nint l[N], r[N], lm[N], p[N][20], nxt[N];\nvector<char> s(N);\nint n, k;\nvoid lmq(int cur) {\n  lm[cur] = cur;\n  if (l[cur] > 0) {\n    p[l[cur]][0] = cur;\n    lmq(l[cur]);\n    lm[cur] = lm[l[cur]];\n  }\n  if (r[cur] > 0) {\n    p[r[cur]][0] = cur;\n    lmq(r[cur]);\n  }\n}\nvoid setnext(int cur, int rlp) {\n  if (r[cur] > 0) {\n    nxt[cur] = lm[r[cur]];\n    setnext(r[cur], rlp);\n  } else {\n    nxt[cur] = rlp;\n  }\n  if (l[cur] > 0) setnext(l[cur], cur);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  lmq(1);\n  setnext(1, 0);\n  for (int i = 1; i < 20; i++) {\n    for (int j = 1; j <= n; j++) {\n      p[j][i] = p[p[j][i - 1]][i - 1];\n    }\n  }\n  vector<bool> dup(n + 1, 0), ndup(n + 1, 0);\n  vector<int> checkdup(n + 1, 0);\n  int cur = lm[1];\n  vector<int> seq;\n  while (cur != 0) {\n    seq.push_back(cur);\n    cur = nxt[cur];\n  }\n  for (int ind = n - 1; ind > 0; ind--) {\n    if (s[seq[ind]] > s[seq[ind - 1]]) {\n      checkdup[seq[ind - 1]] = 1;\n    }\n    if (s[seq[ind]] == s[seq[ind - 1]]) {\n      checkdup[seq[ind - 1]] = checkdup[seq[ind]];\n    }\n    if (s[seq[ind]] < s[seq[ind - 1]]) {\n      checkdup[seq[ind - 1]] = -1;\n    }\n  }\n  for (int ind = 0; ind < n && k > 0; ind++) {\n    int cur = seq[ind];\n    if (dup[cur] || ndup[cur]) {\n      cur = nxt[cur];\n      continue;\n    }\n    if (checkdup[cur] == 1) {\n      int len = 1, temp = cur;\n      for (int i = 19; i >= 0; i--) {\n        if (p[temp][i] > 0 && !dup[p[temp][i]]) {\n          len += (1 << i);\n          temp = p[temp][i];\n        }\n      }\n      if (len <= k) {\n        k -= len;\n        temp = cur;\n        while (len--) {\n          dup[temp] = 1;\n          temp = p[temp][0];\n        }\n      }\n      cur = nxt[cur];\n    } else {\n      queue<int> q;\n      q.push(cur);\n      while (!q.empty()) {\n        int temp = q.front();\n        q.pop();\n        if (ndup[temp] == 1) continue;\n        ndup[temp] = 1;\n        if (l[temp] > 0) {\n          q.push(l[temp]);\n        }\n        if (r[temp] > 0) {\n          q.push(r[temp]);\n        }\n      }\n      cur = nxt[cur];\n    }\n  }\n  int start = lm[1];\n  while (start != 0) {\n    if (dup[start]) {\n      cout << s[start] << s[start];\n    } else {\n      cout << s[start];\n    }\n    start = nxt[start];\n  }\n  cout << "\\n";\n  return 0;\n}\n', '#include <bits/stdc++.h>\n#pragma GCC optimize("O3")\n#pragma GCC optimize("unroll-loops")\nusing namespace std;\nconstexpr long long mod = 1000000007;\nconst long long INF = mod * mod;\ntemplate <typename T>\nvoid chmin(T& a, T b) {\n  a = min(a, b);\n}\ntemplate <typename T>\nvoid chmax(T& a, T b) {\n  a = max(a, b);\n}\ntemplate <typename T>\nvoid cinarray(vector<T>& v) {\n  for (int i = 0; i < v.size(); i++) cin >> v[i];\n}\ntemplate <typename T>\nvoid coutarray(vector<T>& v) {\n  for (int i = 0; i < v.size(); i++) {\n    if (i > 0) cout << " ";\n    cout << v[i];\n  }\n  cout << "\\n";\n}\nlong long mod_pow(long long x, long long n, long long m = mod) {\n  if (n < 0) {\n    long long res = mod_pow(x, -n, m);\n    return mod_pow(res, m - 2, m);\n  }\n  if (abs(x) >= m) x %= m;\n  if (x < 0) x += m;\n  if (x == 0) return 0;\n  long long res = 1;\n  while (n) {\n    if (n & 1) res = res * x % m;\n    x = x * x % m;\n    n >>= 1;\n  }\n  return res;\n}\nstruct modint {\n  int n;\n  modint() : n(0) { ; }\n  modint(long long m) {\n    if (m < 0 || mod <= m) {\n      m %= mod;\n      if (m < 0) m += mod;\n    }\n    n = m;\n  }\n  operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) {\n  a.n += b.n;\n  if (a.n >= mod) a.n -= mod;\n  return a;\n}\nmodint operator-=(modint& a, modint b) {\n  a.n -= b.n;\n  if (a.n < 0) a.n += mod;\n  return a;\n}\nmodint operator*=(modint& a, modint b) {\n  a.n = ((long long)a.n * b.n) % mod;\n  return a;\n}\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, long long n) {\n  if (n == 0) return modint(1);\n  modint res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\nlong long inv(long long a, long long p) {\n  return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) {\n  a = a / b;\n  return a;\n}\nconst int max_n = 1 << 10;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n  fact[0] = modint(1);\n  for (int i = 0; i < max_n - 1; i++) {\n    fact[i + 1] = fact[i] * modint(i + 1);\n  }\n  factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n  for (int i = max_n - 2; i >= 0; i--) {\n    factinv[i] = factinv[i + 1] * modint(i + 1);\n  }\n}\nmodint comb(int a, int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n  if (a < 0 || b < 0 || a < b) return 0;\n  return fact[a] * factinv[a - b];\n}\nlong long gcd(long long a, long long b) {\n  a = abs(a);\n  b = abs(b);\n  if (a < b) swap(a, b);\n  while (b) {\n    long long r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\nconst long double eps = 1e-8;\nconst long double pi = acosl(-1.0);\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nusing mP = pair<modint, modint>;\nint par[1 << 18][18];\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<int> l(n), r(n);\n  par[0][0] = -1;\n  for (int i = 0; i < n; i++) {\n    cin >> l[i] >> r[i];\n    l[i]--;\n    r[i]--;\n    if (l[i] >= 0) par[l[i]][0] = i;\n    if (r[i] >= 0) par[r[i]][0] = i;\n  }\n  for (int j = 0; j < 17; j++) {\n    for (int i = 0; i < n; i++) {\n      if (par[i][j] < 0)\n        par[i][j + 1] = -1;\n      else\n        par[i][j + 1] = par[par[i][j]][j];\n    }\n  }\n  vector<int> ids;\n  function<void(int)> dfs = [&](int id) {\n    if (l[id] >= 0) dfs(l[id]);\n    ids.push_back(id);\n    if (r[id] >= 0) dfs(r[id]);\n  };\n  dfs(0);\n  vector<bool> b(n);\n  for (int i = 0; i < n; i++) {\n    int le = i;\n    while (i + 1 < n && s[ids[i]] == s[ids[i + 1]]) i++;\n    if (i + 1 == n || s[ids[i + 1]] < s[ids[i]]) {\n      for (int j = le; j <= i; j++) b[ids[j]] = true;\n    }\n  }\n  vector<bool> used(n);\n  string ans;\n  function<void(int)> dfs3 = [&](int id) {\n    if (l[id] >= 0) dfs3(l[id]);\n    ans.push_back(s[id]);\n    if (r[id] >= 0) dfs3(r[id]);\n  };\n  function<void(int)> dfs2 = [&](int id) {\n    if (l[id] >= 0) dfs2(l[id]);\n    if (!used[id]) {\n      if (!b[id]) {\n        int cur = id;\n        int ad = 1;\n        for (int j = 18 - 1; j >= 0; j--) {\n          int p = par[cur][j];\n          if (p >= 0 && !used[p]) {\n            ad += (1 << j);\n            cur = p;\n          }\n        }\n        if (ad <= k) {\n          k -= ad;\n          cur = id;\n          while (cur >= 0 && !used[cur]) {\n            used[cur] = true;\n            cur = par[cur][0];\n          }\n        }\n      }\n    }\n    if (used[id]) {\n      ans.push_back(s[id]);\n      ans.push_back(s[id]);\n      if (r[id] >= 0) dfs2(r[id]);\n    } else {\n      ans.push_back(s[id]);\n      if (r[id] >= 0) dfs3(r[id]);\n    }\n  };\n  dfs2(0);\n  cout << ans << "\\n";\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, n, m, t, l[200500], r[200500], siz[200500], tp[200500], it,\n    id[200500], dep[200500], sb[200500], fa[200500];\nchar s[200500];\nint q[200500];\nstring res;\nvoid dfs0(int x, int d) {\n  if (!x) return;\n  dep[x] = d;\n  fa[l[x]] = fa[r[x]] = x;\n  dfs0(l[x], d + 1);\n  q[++it] = x;\n  dfs0(r[x], d + 1);\n  siz[x] = 1 + siz[l[x]] + siz[r[x]];\n}\nvoid dfs01(int x, int to) {\n  if (!x) return;\n  tp[x] = to;\n  id[x] = ++it;\n  if (siz[l[x]] >= siz[r[x]]) {\n    dfs01(l[x], to);\n    dfs01(r[x], r[x]);\n  } else {\n    dfs01(r[x], to);\n    dfs01(l[x], l[x]);\n  }\n}\nstruct SB {\n  int f[800500], t[805000];\n  void push(int id, int l, int r) {\n    t[(id << 1)] = t[((id << 1) + 1)] = t[id];\n    f[(id << 1)] = ((t[id] < 1) ? -1000000 : (((l + r) >> 1) - l + 1));\n    f[((id << 1) + 1)] = ((t[id] < 1) ? -1000000 : (r - ((l + r) >> 1)));\n    t[id] = 0;\n  }\n  void ass(int id, int l, int r, int x, int y, int w) {\n    if (x <= l && r <= y) {\n      t[id] = w;\n      f[id] = ((w < 1) ? -1000000 : (r - l + 1));\n      return;\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (x <= ((l + r) >> 1)) ass((id << 1), l, ((l + r) >> 1), x, y, w);\n    if (y > ((l + r) >> 1))\n      ass(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y, w);\n    f[id] = max(-1000000, f[(id << 1)] + f[((id << 1) + 1)]);\n  }\n  int get(int id, int l, int r, int x, int y) {\n    if (x <= l && r <= y) {\n      return f[id];\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (y <= ((l + r) >> 1)) return get((id << 1), l, ((l + r) >> 1), x, y);\n    if (x > ((l + r) >> 1))\n      return get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y);\n    return max(-1000000, get((id << 1), l, ((l + r) >> 1), x, y) +\n                             get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y));\n  }\n} SB;\nvoid hld_ass(int x, int w) {\n  while (x) {\n    SB.ass(1, 1, n, id[tp[x]], id[x], 1);\n    x = fa[tp[x]];\n  }\n}\nint hld_get(int x, int w = 0) {\n  while (x) {\n    w += SB.get(1, 1, n, id[tp[x]], id[x]);\n    w = max(w, -1000000);\n    x = fa[tp[x]];\n  }\n  return w;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> m >> s + 1;\n  for (i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs0(1, 1);\n  it = 0;\n  dfs01(1, 1);\n  for (i = n; i >= 1; i--) {\n    if (s[q[i]] == s[q[i + 1]]) {\n      sb[i] = sb[i + 1];\n    } else {\n      sb[i] = (s[q[i]] < s[q[i + 1]]);\n    }\n  }\n  for (i = 1; i <= n; i++) {\n    res += s[q[i]];\n    if (SB.get(1, 1, n, id[q[i]], id[q[i]])) {\n      res += s[q[i]];\n      continue;\n    }\n    if (sb[i]) {\n      k = hld_get(q[i]);\n      if (k + m >= dep[q[i]]) {\n        res += s[q[i]];\n        m -= (dep[q[i]] - k);\n        hld_ass(q[i], 1);\n      }\n    } else {\n      SB.ass(1, 1, n, id[q[i]], id[q[i]], -1000000);\n    }\n  }\n  cout << res;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 100;\nconst int MOD = 1e9 + 7;\nvoid Add(int &a, int b) {\n  a += b;\n  a -= a >= MOD ? MOD : 0;\n}\nint Mul(int a, int b) { return 1ll * a * b % MOD; }\nstring out, st;\nint n, k, Left[N], Right[N], f[N], TIME, tin[N], p[N], flag[N];\nvoid dfs1(int u) {\n  if (Left[u]) dfs1(Left[u]);\n  tin[u] = ++TIME;\n  p[TIME] = u;\n  out += st[u];\n  if (Right[u]) dfs1(Right[u]);\n}\nbool dfs2(int u, int d, bool ok = true) {\n  if (Left[u]) flag[u] = dfs2(Left[u], d + 1, ok);\n  if (ok && !flag[u] && f[tin[u]] && k >= d) {\n    k -= d;\n    flag[u] = true;\n  }\n  if (ok && flag[u])\n    cout << st[u] << st[u];\n  else\n    cout << st[u];\n  if (Right[u]) dfs2(Right[u], 1, flag[u] && ok);\n  return flag[u];\n}\nvoid Solve() {\n  cin >> n >> k;\n  cin >> st;\n  st = '~' + st;\n  for (int i = 1; i <= n; ++i) {\n    cin >> Left[i] >> Right[i];\n  }\n  out = '~';\n  dfs1(1);\n  f[n] = 0;\n  for (int i = n - 1; i >= 1; --i)\n    if ((out[i] < out[i + 1]) || (out[i] == out[i + 1] && f[i + 1])) f[i] = 1;\n  dfs2(1, 1);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  int test = 1;\n  while (test--) Solve();\n}\n", '#include <bits/stdc++.h>\n#pragma GCC optimize("O3")\n#pragma GCC target("sse4")\nusing namespace std;\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << \'\\\'\' << x << \'\\\'\'; }\nvoid __print(const char* x) { cerr << \'\\"\' << x << \'\\"\'; }\nvoid __print(const string& x) { cerr << \'\\"\' << x << \'\\"\'; }\nvoid __print(bool x) { cerr << (x ? "true" : "false"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V>& x) {\n  cerr << \'{\';\n  __print(x.first);\n  cerr << ", ";\n  __print(x.second);\n  cerr << \'}\';\n}\ntemplate <typename T>\nvoid __print(const T& x) {\n  int first = 0;\n  cerr << \'{\';\n  for (auto& i : x) cerr << (first++ ? ", " : ""), __print(i);\n  cerr << "}";\n}\nvoid _print() { cerr << "]\\n"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << ", ";\n  _print(v...);\n}\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 200001;\nint N, K;\nstring S;\nstring nxt;\nint L[MX], R[MX];\nbool dup[MX];\nint P[MX];\nstring ans;\nvector<int> ord;\nvoid ordDfs(int v) {\n  if (v == 0) return;\n  ordDfs(L[v]);\n  ord.push_back(v);\n  ordDfs(R[v]);\n}\nvoid dfs(int v, int lstDup) {\n  if (v == 0) return;\n  P[L[v]] = v;\n  P[R[v]] = v;\n  dfs(L[v], lstDup + 1);\n  if (!dup[v] && nxt[v] > S[v] && lstDup <= K) {\n    int cv = v;\n    K -= lstDup;\n    while (lstDup) {\n      dup[cv] = true;\n      cv = P[cv];\n      lstDup--;\n    }\n  }\n  if (dup[v]) {\n    lstDup = 0;\n    dfs(R[v], lstDup + 1);\n  }\n}\nvoid buildAns(int v) {\n  if (v == 0) return;\n  buildAns(L[v]);\n  ans += S[v];\n  if (dup[v]) ans += S[v];\n  buildAns(R[v]);\n}\nvoid solve() {\n  cin >> N >> K;\n  cin >> S;\n  S = " " + S;\n  for (int i = 1; i < (N + 1); i++) cin >> L[i] >> R[i];\n  for (int i = 0; i < (N + 1); i++) nxt += \' \';\n  ordDfs(1);\n  nxt[ord[N - 1]] = \'a\' - 1;\n  for (int i = (N - 1) - 1; i >= 0; i--) {\n    if (S[ord[i]] == S[ord[i + 1]]) {\n      nxt[ord[i]] = nxt[ord[i + 1]];\n    } else\n      nxt[ord[i]] = S[ord[i + 1]];\n  }\n  P[1] = -1;\n  dfs(1, 1);\n  buildAns(1);\n  cout << ans << nl;\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  int T = 1;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint T[200010][2], tid[200010], deep[200010];\nchar s[200010], t[200010];\nbool mark[200010], mark2[200010];\nint n, k, idx;\nvoid DFS(int u) {\n  if (T[u][0]) {\n    deep[T[u][0]] = deep[u] + 1;\n    DFS(T[u][0]);\n  }\n  tid[++idx] = u;\n  t[idx] = s[u];\n  if (T[u][1]) {\n    deep[T[u][1]] = deep[u] + 1;\n    DFS(T[u][1]);\n  }\n}\nbool DFS2(int u, int top) {\n  bool flag = false;\n  if (T[u][0]) {\n    if (DFS2(T[u][0], top)) flag = true;\n  }\n  if (flag) mark2[u] = true;\n  if (mark[u] && !flag) {\n    if (deep[u] - deep[top] + 1 <= k) {\n      k -= (deep[u] - deep[top] + 1);\n      mark2[u] = true;\n      flag = true;\n    }\n  }\n  if (T[u][1] && flag) DFS2(T[u][1], T[u][1]);\n  return flag;\n}\nint main() {\n  scanf("%d%d", &n, &k);\n  scanf("%s", s + 1);\n  for (int i = 1; i <= n; ++i) scanf("%d%d", &T[i][0], &T[i][1]);\n  DFS(1);\n  int p = n;\n  for (int i = n; i >= 1; --i) {\n    if (t[p] > t[i]) mark[tid[i]] = true;\n    if (t[i - 1] != t[i]) p = i;\n  }\n  DFS2(1, 1);\n  for (int i = 1; i <= n; ++i) {\n    printf("%c", t[i]);\n    if (mark2[tid[i]]) printf("%c", t[i]);\n  }\n  printf("\\n");\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst long long N = 200010;\nlong long lt[N], rt[N], copyy[N], copyy1[N];\nlong long n, k;\nchar a[N];\nstring ans;\nvector<long long> s1;\nvoid dfs1(long long u) {\n  if (lt[u]) dfs1(lt[u]);\n  s1.push_back(u);\n  if (rt[u]) dfs1(rt[u]);\n}\nvoid dfs2(long long u) {\n  vector<long long> s2;\n  if (!u) return;\n  long long p = u;\n  while (p && !copyy[p]) {\n    s2.push_back(p);\n    p = lt[p];\n  }\n  if (copyy[p] && s2.size() < k) {\n    k -= s2.size() + 1;\n    copyy1[p] = 1;\n    dfs2(lt[p]), dfs2(rt[p]);\n    while (s2.size()) {\n      copyy1[s2.back()] = 1;\n      dfs2(rt[s2.back()]);\n      s2.pop_back();\n    }\n  }\n}\nvoid dfs3(long long u) {\n  if (lt[u]) dfs3(lt[u]);\n  ans += a[u];\n  if (copyy1[u]) ans += a[u];\n  if (rt[u]) dfs3(rt[u]);\n}\nvoid solve() {\n  cin >> n >> k >> a + 1;\n  for (long long i = 1; i <= n; i++) cin >> lt[i] >> rt[i];\n  dfs1(1);\n  for (long long i = n - 2; i >= 0; i--) {\n    if (a[s1[i]] < a[s1[i + 1]])\n      copyy[s1[i]] = 1;\n    else if (a[s1[i]] > a[s1[i + 1]])\n      continue;\n    else if (copyy[s1[i + 1]])\n      copyy[s1[i]] = 1;\n  }\n  dfs2(1);\n  dfs3(1);\n  cout << ans << endl;\n}\nsigned main() {\n  solve();\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\nconst int M = 4e5 + 1;\nconst long long MOD = 1e9 + 7;\nconst long long MOD1 = 998244353;\nconst long long INF = 1e17;\nconst int inf = 1e9;\nlong long n, m, k;\nstring s;\nvector<int> l, r, pos;\nvector<char> val;\nvector<bool> dup, good;\nint dfs1(int node, int len) {\n  if (node == 0) return 0;\n  int before = dfs1(l[node], len);\n  pos[before + len] = node;\n  return before + 1 + dfs1(r[node], len + before + 1);\n}\nvoid dfs2(int node, int depth) {\n  if (depth > k || node == 0) return;\n  dfs2(l[node], depth + 1);\n  if (dup[l[node]])\n    dup[node] = true;\n  else if (good[node]) {\n    dup[node] = true;\n    k -= depth;\n  }\n  if (dup[node]) {\n    dfs2(r[node], 1);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  l.resize(n + 1);\n  r.resize(n + 1);\n  val.resize(n + 1);\n  pos.resize(n + 1);\n  dup.resize(n + 1);\n  good.resize(n + 1);\n  for (int i = 1; i <= n; i++) {\n    char c;\n    cin >> c;\n    val[i] = c;\n  }\n  for (int i = 1; i <= n; i++) {\n    int l1, r1;\n    cin >> l1 >> r1;\n    l[i] = l1;\n    r[i] = r1;\n  }\n  s = dfs1(1, 0);\n  bool flag = false;\n  for (int i = n - 2; i >= 0; i--) {\n    if (val[pos[i]] < val[pos[i + 1]]) {\n      good[pos[i]] = true;\n      flag = true;\n    } else if (val[pos[i]] == val[pos[i + 1]] && flag) {\n      good[pos[i]] = true;\n    } else\n      flag = false;\n  }\n  dfs2(1, 1);\n  string ans = "";\n  for (int i = 0; i < n; i++) {\n    ans += val[pos[i]];\n    if (dup[pos[i]]) {\n      ans += val[pos[i]];\n    }\n  }\n  cout << ans << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int tc = 1;\n  for (int t = 1; t <= tc; t++) {\n    solve();\n  }\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)2e5 + 50, LOGN = 17;\nconst int INF = (int)1e9;\nint n, k;\nint ord[N], in[N], tim = 0;\nchar las[N];\nint lc[N], rc[N];\nint res[N];\nstring str;\nvoid dfs(int v) {\n  if (lc[v] != -1) dfs(lc[v]);\n  ord[tim] = v;\n  in[v] = tim++;\n  if (rc[v] != -1) dfs(rc[v]);\n}\nvoid solve(int v, int& rem) {\n  int la = -1;\n  int cur = v;\n  for (int i = 0; i < (rem); ++i) {\n    if (cur == -1) break;\n    if (las[cur] != ' ' && las[cur] > str[cur]) {\n      la = i;\n    }\n    cur = lc[cur];\n  }\n  cur = v;\n  vector<int> vs;\n  for (int i = 0; i < (la + 1); ++i) {\n    res[cur] = 1;\n    rem--;\n    vs.push_back(cur);\n    cur = lc[cur];\n  }\n  while (!vs.empty()) {\n    if (rc[vs.back()] != -1) solve(rc[vs.back()], rem);\n    vs.pop_back();\n  }\n}\nvoid print_ans(int v) {\n  if (lc[v] != -1) print_ans(lc[v]);\n  cout << str[v];\n  if (res[v]) cout << str[v];\n  if (rc[v] != -1) print_ans(rc[v]);\n}\nint pos[256];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  cin >> str;\n  for (int i = 0; i < (n); ++i) {\n    cin >> lc[i] >> rc[i];\n    lc[i]--, rc[i]--;\n  }\n  dfs(0);\n  fill(pos, pos + 256, INF);\n  for (int i = n - 1; i >= 0; i--) {\n    pos[str[ord[i]]] = i;\n    char f = ' ';\n    for (char c = 'a'; c <= 'z'; c++) {\n      if (c != str[ord[i]] && pos[f] > pos[c]) f = c;\n    }\n    las[ord[i]] = f;\n  }\n  solve(0, k);\n  assert(k >= 0);\n  print_ans(0);\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 2e5 + 10;\nint n, k;\nchar arr[MAX];\nint L[MAX], R[MAX];\nvector<int> order;\nchar nxt[MAX];\nint mark[MAX], dep[MAX];\nvoid dfs(int node) {\n  if (L[node]) {\n    dep[L[node]] = dep[node] + 1;\n    dfs(L[node]);\n  }\n  order.push_back(node);\n  if (R[node]) {\n    dep[R[node]] = dep[node] + 1;\n    dfs(R[node]);\n  }\n}\nvoid dfs2(int node, int last) {\n  if (L[node]) {\n    dfs2(L[node], last);\n    if (mark[L[node]]) mark[node] = 1;\n  }\n  cout << arr[node];\n  if (mark[node] || (k >= dep[node] - last && arr[node] < nxt[node])) {\n    if (!mark[node]) k -= (dep[node] - last);\n    mark[node] = 1;\n    cout << arr[node];\n    last = dep[node];\n  } else\n    last = -1e9;\n  if (R[node]) {\n    dfs2(R[node], last);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) cin >> arr[i];\n  for (int i = 1; i <= n; ++i) cin >> L[i] >> R[i];\n  dep[1] = 1;\n  dfs(1);\n  nxt[order[n - 1]] = 'a';\n  for (int i = n - 2; i >= 0; --i) {\n    if (arr[order[i]] == arr[order[i + 1]])\n      nxt[order[i]] = nxt[order[i + 1]];\n    else\n      nxt[order[i]] = arr[order[i + 1]];\n  }\n  dfs2(1, 0);\n  return 0;\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, k, l[N], r[N], ls;\nbool f[N], vis[N];\nchar c[N];\nvector<int> a;\nvoid back(int u) {\n  if (!u) return;\n  back(l[u]);\n  a.push_back(u);\n  back(r[u]);\n}\nvoid dfs(int u, int sum) {\n  if (!u || sum > k) return;\n  dfs(l[u], sum + 1);\n  if (vis[l[u]])\n    vis[u] = 1;\n  else if (f[u])\n    vis[u] = 1, k -= sum;\n  if (vis[u]) dfs(r[u], 1);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> (c + 1);\n  for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  back(1);\n  ls = 0;\n  c[0] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    int u = a[i], v = a[i + 1];\n    if (c[u] != c[v]) ls = v;\n    if (c[u] < c[ls]) f[u] = 1;\n  }\n  dfs(1, 1);\n  for (auto i : a) {\n    cout << c[i];\n    if (vis[i]) cout << c[i];\n  }\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar c[200010];\nint l[200010];\nint r[200010];\nchar d[200010];\nint ind[200010];\nint nxt[200010];\nbool needa[200010];\nconst int LOG = 20;\nint bu[LOG][200010];\nbool chosen[200010];\nint pos[200010];\nint x = 1;\nvoid dfs(int u) {\n  if (!u) return;\n  dfs(l[u]);\n  pos[u] = x;\n  d[x] = c[u];\n  ind[x] = u;\n  ++x;\n  dfs(r[u]);\n  if (l[u]) bu[0][l[u]] = u;\n  if (r[u]) bu[0][r[u]] = u;\n}\nvector<int> wanna;\nint notcol(int u) {\n  int ans = 1;\n  for (int i = LOG - 1; i >= 0; --i) {\n    if (bu[i][u] && !chosen[bu[i][u]]) {\n      ans += 1 << i;\n      u = bu[i][u];\n    }\n  }\n  return ans;\n}\nvoid print(int u) {\n  if (!u) return;\n  print(l[u]);\n  cout << (chosen[u] ? string(2, c[u]) : string(1, c[u]));\n  print(r[u]);\n}\nset<int> badupperpos;\nint gt() {\n  if (badupperpos.empty()) return 1e9;\n  return *badupperpos.begin();\n}\nvoid dfs3(int i) {\n  if (!i) return;\n  int position = pos[i];\n  if (needa[position]) {\n    int pre = gt();\n    if (pre < position) goto end;\n    int needk = notcol(i);\n    if (needk > k) goto end;\n    k -= needk;\n    int j = i;\n    while (true) {\n      chosen[j] = true;\n      if (j == 1) break;\n      if (chosen[bu[0][j]]) break;\n      j = bu[0][j];\n    }\n    badupperpos.clear();\n  }\nend:\n  if (!needa[position]) badupperpos.insert(position);\n  dfs3(l[i]);\n  dfs3(r[i]);\n  if (badupperpos.count(position)) badupperpos.erase(position);\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) {\n    cin >> c[i];\n  }\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  dfs(1);\n  for (int i = n; i >= 1; --i) {\n    if (d[i] != d[i + 1])\n      nxt[i] = i + 1;\n    else\n      nxt[i] = nxt[i + 1];\n    needa[i] = d[nxt[i]] > d[i];\n    if (needa[i]) wanna.push_back(ind[i]);\n  }\n  for (int i = 1; i < LOG; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      bu[i][j] = bu[i - 1][bu[i - 1][j]];\n    }\n  }\n  dfs3(1);\n  print(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nconst int MAXN = 200005;\nlong long qpow(long long d, long long z) {\n  long long res = 1;\n  for (; z; z >>= 1) {\n    if (z & 1) res = res * d % MOD;\n    d = d * d % MOD;\n  }\n  return res;\n}\nint n, k;\nchar str[MAXN];\nint ch[MAXN][2], fa[MAXN];\nint p[MAXN], rk[MAXN], cur = 0;\nint dep[MAXN];\nvoid inord(int x) {\n  if (x == 0) return;\n  dep[x] = dep[fa[x]] + 1;\n  inord(ch[x][0]);\n  p[++cur] = x;\n  rk[x] = cur;\n  inord(ch[x][1]);\n}\nint diff[MAXN];\nbool rep[MAXN];\nint curdep;\nvoid solve(int x, int fas) {\n  if (x == 0) return;\n  solve(ch[x][0], fas);\n  if (fas == 0) {\n    int i = rk[x];\n    int z = diff[i];\n    if (str[x] < str[p[z]] && dep[x] - curdep <= k) {\n      int rc = dep[x] - curdep, xd = x;\n      for (int i = 1; i <= rc; i++) {\n        rep[xd] = 1;\n        xd = fa[xd];\n      }\n      k -= rc;\n      curdep = dep[x];\n    } else {\n      if (!rep[x]) fas++;\n    }\n  }\n  solve(ch[x][1], fas);\n  if (curdep >= dep[x]) curdep--;\n}\nint main() {\n  scanf("%d%d", &n, &k);\n  scanf("%s", str + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", &ch[i][0], &ch[i][1]);\n    fa[ch[i][0]] = fa[ch[i][1]] = i;\n  }\n  fa[0] = 0;\n  dep[1] = 1;\n  str[n + 1] = 0;\n  inord(1);\n  for (int i = n; i >= 1; i--) {\n    if (str[p[i]] != str[p[i + 1]])\n      diff[i] = i + 1;\n    else\n      diff[i] = diff[i + 1];\n  }\n  curdep = 0;\n  solve(1, 0);\n  for (int i = 1; i <= n; i++) {\n    printf("%c", str[p[i]]);\n    if (rep[p[i]]) printf("%c", str[p[i]]);\n  }\n  printf("\\n");\n  return 0;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint l[200005], r[200005], good[200005];\nchar m[200005], nxt[200005];\nstring s, t;\nstring res;\nvector<int> v;\nvoid dfs1(int u) {\n  if (!u) return;\n  dfs1(l[u]);\n  t += s[u];\n  v.push_back(u);\n  dfs1(r[u]);\n}\nbool dfs(int u, int h, bool goodSub) {\n  if (!u) return false;\n  bool used = false;\n  if (dfs(l[u], h + 1, goodSub)) {\n    used = true;\n  }\n  if ((good[u] && h <= k) && !used) {\n    k -= h;\n    used = true;\n  }\n  if (used) {\n    res += s[u];\n    res += s[u];\n  } else {\n    res += s[u];\n  }\n  if (used && goodSub) {\n    dfs(r[u], 1, goodSub);\n  } else {\n    dfs(r[u], k + 1, false);\n  }\n  return used;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> n >> k;\n  cin >> s;\n  s = '#' + s;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs1(1);\n  char cur = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    m[v[i]] = cur;\n    cur = max(cur, t[i]);\n    if (i != n - 1) {\n      if (t[i] == t[i + 1])\n        nxt[v[i]] = nxt[v[i + 1]];\n      else\n        nxt[v[i]] = t[i + 1];\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (s[i] < nxt[i]) {\n      good[i] = 1;\n    }\n  }\n  dfs(1, 1, true);\n  cout << res << endl;\n  return 0;\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nvoid main0();\nint main() {\n  clock_t start, end;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  main0();\n  return 0;\n}\nconst int dx[8] = {0, 1, -1, 0, 1, 1, -1, -1};\nconst int dy[8] = {1, 0, 0, -1, 1, -1, -1, 1};\nconst int N = 2e5 + 5;\nconst int M = 1e5;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3f;\nconst int mod = 998244353;\nconst double eps = 1e-6;\nmt19937 rnd(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return y < x ? x = y, 1 : 0;\n}\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return y > x ? x = y, 1 : 0;\n}\nint n, k;\nstring s;\nint lc[N], rc[N];\nint ord[N];\nint idx[N];\nint p = 0;\nint flag[N];\nvoid dfs1(int u) {\n  if (lc[u]) dfs1(lc[u]);\n  ord[++p] = u;\n  idx[u] = p;\n  if (rc[u]) dfs1(rc[u]);\n}\nint rep[N];\nint dfs2(int u, int k) {\n  if (k == 0) return 0;\n  int cost = 0;\n  if (lc[u]) cost += dfs2(lc[u], k - 1);\n  if (flag[u] || cost) {\n    rep[u] = 1, cost++;\n    if (rc[u]) cost += dfs2(rc[u], k - cost);\n  }\n  return cost;\n}\nvoid main0() {\n  cin >> n >> k >> s;\n  s = "$" + s;\n  for (int i = 1; i <= n; ++i) {\n    cin >> lc[i] >> rc[i];\n  }\n  dfs1(1);\n  flag[ord[n]] = 0;\n  for (int i = n - 1; i >= 1; --i) {\n    int cur = ord[i];\n    int nxt = ord[i + 1];\n    flag[cur] = (s[cur] == s[nxt] ? flag[nxt] : s[cur] < s[nxt]);\n  }\n  dfs2(1, k);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= rep[ord[i]] + 1; ++j) {\n      cout << s[ord[i]];\n    }\n  }\n  cout << endl;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nlong long MAXN = 2e5 + 10;\nvoid f(long long cur, vector<pair<long long, long long>> &g) {\n  if (cur == -1) return;\n  f(g[cur].first, g);\n  pos.push_back(cur);\n  f(g[cur].second, g);\n}\nvector<vector<long long>> jump(30, vector<long long>(MAXN));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 29; i >= 0; i--) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(MAXN);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = "";\n  f(0, g);\n  for (auto &a : pos) initial += s[a];\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  long long operations = 0;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      while (cur and taken[cur] == 0) {\n        assert(operations++ < 1e6);\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nint n, k, l[maxn], r[maxn];\nchar c[maxn];\nvector<int> v;\nvoid dfs(int u) {\n  if (!u) return;\n  dfs(l[u]);\n  v.push_back(u);\n  dfs(r[u]);\n}\nint f[maxn], g[maxn];\nvoid calc(int u, int cst) {\n  if (!u || cst > k) return;\n  calc(l[u], cst + 1);\n  if (g[l[u]])\n    g[u] = 1;\n  else if (f[u])\n    g[u] = 1, k -= cst;\n  if (g[u]) calc(r[u], 1);\n}\nint main() {\n  scanf("%d%d%s", &n, &k, c + 1);\n  for (int i = 1; i <= n; ++i) scanf("%d%d", &l[i], &r[i]);\n  dfs(1);\n  for (int i = n - 2; i >= 0; --i) {\n    if (c[v[i]] < c[v[i + 1]])\n      f[v[i]] = 1;\n    else if (c[v[i]] == c[v[i + 1]])\n      f[v[i]] = f[v[i + 1]];\n  }\n  calc(1, 1);\n  for (int i = 0; i < n; ++i) {\n    putchar(c[v[i]]);\n    if (g[v[i]]) putchar(c[v[i]]);\n  }\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar c[200010];\nint l[200010];\nint r[200010];\nchar d[200010];\nint ind[200010];\nint nxt[200010];\nbool needa[200010];\nconst int LOG = 20;\nint bu[LOG][200010];\nbool chosen[200010];\nint pos[200010];\nint x = 1;\nvoid dfs(int u) {\n  if (!u) return;\n  dfs(l[u]);\n  pos[u] = x;\n  d[x] = c[u];\n  ind[x] = u;\n  ++x;\n  dfs(r[u]);\n  if (l[u]) bu[0][l[u]] = u;\n  if (r[u]) bu[0][r[u]] = u;\n}\nvector<int> wanna;\nint notcol(int u) {\n  int ans = 1;\n  for (int i = LOG - 1; i >= 0; --i) {\n    if (bu[i][u] && !chosen[bu[i][u]]) {\n      ans += 1 << i;\n      u = bu[i][u];\n    }\n  }\n  return ans;\n}\nvoid print(int u) {\n  if (!u) return;\n  print(l[u]);\n  cout << (chosen[u] ? string(2, c[u]) : string(1, c[u]));\n  print(r[u]);\n}\nset<int> badupperpos;\nint gt() {\n  if (badupperpos.empty()) return 1e9;\n  return *badupperpos.begin();\n}\nvoid dfs3(int i) {\n  if (!i) return;\n  int position = pos[i];\n  if (!needa[position]) badupperpos.insert(position);\n  dfs3(l[i]);\n  if (needa[position] && !chosen[i]) {\n    int pre = gt();\n    if (pre < position) goto end;\n    int needk = notcol(i);\n    if (needk > k) goto end;\n    k -= needk;\n    int j = i;\n    while (true) {\n      chosen[j] = true;\n      if (j == 1) break;\n      if (chosen[bu[0][j]]) break;\n      j = bu[0][j];\n    }\n    badupperpos.clear();\n  }\nend:\n  dfs3(r[i]);\n  if (badupperpos.count(position)) badupperpos.erase(position);\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) {\n    cin >> c[i];\n  }\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  dfs(1);\n  for (int i = n; i >= 1; --i) {\n    if (d[i] != d[i + 1])\n      nxt[i] = i + 1;\n    else\n      nxt[i] = nxt[i + 1];\n    needa[i] = d[nxt[i]] > d[i];\n    if (needa[i]) wanna.push_back(ind[i]);\n  }\n  for (int i = 1; i < LOG; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      bu[i][j] = bu[i - 1][bu[i - 1][j]];\n    }\n  }\n  dfs3(1);\n  print(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\n#pragma GCC optimize("Ofast")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma")\n#pragma GCC optimize("unroll-loops")\nusing namespace std;\nlong long MOD = 10000007;\ndouble eps = 1e-12;\nusing namespace std;\nconst int maxn = 202020;\nint n, k;\nstring c;\nint l[maxn], r[maxn];\nvector<int> in_order;\nvoid build_in_order(int u) {\n  if (u == 0) return;\n  build_in_order(l[u]);\n  in_order.push_back(u);\n  build_in_order(r[u]);\n}\nbool good[maxn];\nbool duplicated[maxn];\nvoid dfs(int u, int cost = 1) {\n  if (u == 0) return;\n  if (cost > k) return;\n  dfs(l[u], cost + 1);\n  if (duplicated[l[u]]) {\n    duplicated[u] = true;\n  } else if (good[u]) {\n    duplicated[u] = true;\n    k -= cost;\n  }\n  if (duplicated[u]) dfs(r[u], 1);\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n >> k;\n  cin >> c;\n  c = \' \' + c;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  build_in_order(1);\n  char last_diff = c[in_order.back()];\n  for (int i = n - 2; i >= 0; --i) {\n    int u = in_order[i];\n    int v = in_order[i + 1];\n    if (c[u] != c[v]) {\n      last_diff = c[v];\n    }\n    if (c[u] < last_diff) {\n      good[u] = true;\n    }\n  }\n  dfs(1);\n  for (auto u : in_order) {\n    cout << c[u];\n    if (duplicated[u]) cout << c[u];\n  }\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nint n, k, ls[N], rs[N], nxt[N], cost[N];\nstring cc, ss = "$", res = "";\nvector<int> order = {0};\nbool good[N], vis[N];\nvoid dfs1(int v) {\n  if (ls[v]) dfs1(ls[v]);\n  ss += string(1, cc[v]);\n  order.push_back(v);\n  if (rs[v]) dfs1(rs[v]);\n}\nvoid dfs2(int v) {\n  if (cost[v] > k) return;\n  if (ls[v]) cost[ls[v]] = cost[v] + 1, dfs2(ls[v]);\n  if (ls[v] && vis[ls[v]])\n    vis[v] = 1;\n  else if (good[v])\n    vis[v] = 1, k -= cost[v];\n  if (rs[v] && vis[v]) cost[rs[v]] = 1, dfs2(rs[v]);\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n >> k;\n  cin >> cc;\n  cc = "$" + cc;\n  for (int i = 1; i <= n; ++i) cin >> ls[i] >> rs[i];\n  dfs1(1);\n  nxt[n] = n + 1;\n  for (int i = n - 1; i >= 1; --i) {\n    if (ss[i] != ss[i + 1])\n      nxt[i] = i + 1;\n    else\n      nxt[i] = nxt[i + 1];\n  }\n  for (int i = 1; i <= n; ++i)\n    good[order[i]] = (nxt[i] != n + 1 && ss[i] < ss[nxt[i]]);\n  cost[1] = 1;\n  dfs2(1);\n  for (int i = 1; i <= n; ++i) res += string(vis[order[i]] ? 2 : 1, ss[i]);\n  cout << res << \'\\n\';\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nconst int iinf = (int)1e9 + 10;\nconst long long linf = (long long)1e18 + 10;\nint n, k;\nstring s;\nconst int maxn = 2e5 + 10;\nint l[maxn], r[maxn], dup[maxn], ans[maxn];\nvoid get_str(vector<int>& res, int v) {\n  if (v == 0) return;\n  get_str(res, l[v]);\n  res.push_back(v);\n  get_str(res, r[v]);\n}\nvoid dfs(int v, int left) {\n  if (v == 0 || left > k) return;\n  dfs(l[v], left + 1);\n  if (ans[l[v]] || dup[v]) {\n    if (!ans[l[v]] && dup[v]) {\n      k -= left;\n    }\n    ans[v] = 1;\n    dfs(r[v], 1);\n  }\n}\nvoid out_ans(int v) {\n  if (v == 0) return;\n  out_ans(l[v]);\n  cout << s[v];\n  if (ans[v]) cout << s[v];\n  out_ans(r[v]);\n}\nvoid solve() {\n  cin >> n >> k;\n  string t;\n  cin >> t;\n  s = " ";\n  for (char c : t) s.push_back(c);\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  vector<int> res;\n  get_str(res, 1);\n  char prv = 0;\n  for (int i = (int)res.size() - 1; i >= 0; i--) {\n    if (prv != 0 && prv > s[res[i]]) {\n      dup[res[i]] = 1;\n    }\n    if (i > 0 && s[res[i]] != s[res[i - 1]]) prv = s[res[i]];\n  }\n  dfs(1, 1);\n  out_ans(1);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t;\n  t = 1;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nvector<int> o;\nvector<pair<int, int>> v;\nvoid dfs(int u) {\n  if (v[u].first != 0) dfs(v[u].first);\n  o.push_back(u);\n  if (v[u].second != 0) dfs(v[u].second);\n}\nbool dup[200008];\nbool rdup[200008];\nint k;\nbool dfs2(int u, int d) {\n  bool l = 0, r, ret = 0;\n  if (v[u].first != 0) l = dfs2(v[u].first, d + 1);\n  if (l == 1) {\n    rdup[u] = 1;\n    if (v[u].second != 0) r = dfs2(v[u].second, 1);\n    ret = 1;\n  } else {\n    if (dup[u] == 1 && d <= k) {\n      k -= d;\n      rdup[u] = 1;\n      ret = 1;\n      if (v[u].second != 0) r = dfs2(v[u].second, 1);\n    }\n  }\n  return ret;\n}\nint main() {\n  int n;\n  cin >> n >> k;\n  string second;\n  cin >> second;\n  int l, r;\n  v.push_back({0, 0});\n  for (int i = 0; i < n; i++) {\n    cin >> l >> r;\n    v.push_back({l, r});\n  }\n  dfs(1);\n  for (int i = 0; i < n + 1; i++) {\n    dup[i] = 0;\n    rdup[i] = 0;\n  }\n  for (int i = n - 2; i >= 0; i--) {\n    if (second[o[i] - 1] < second[o[i + 1] - 1]) {\n      dup[o[i]] = 1;\n    } else if (second[o[i] - 1] == second[o[i + 1] - 1] && dup[o[i + 1]] == 1) {\n      dup[o[i]] = 1;\n    }\n  }\n  dfs2(1, 1);\n  for (int i = 0; i < n; i++) {\n    cout << second[o[i] - 1];\n    if (rdup[o[i]] == 1) {\n      cout << second[o[i] - 1];\n    }\n  }\n  cout << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\n#pragma GCC optimize("Ofast")\n#pragma GCC target("sse,sse2,sse3,ssse3,sse4,avx,avx2")\n#pragma GCC optimization("O3")\n#pragma GCC optimization("unroll-loops")\nusing namespace std;\nvoid pre() {}\nint arr[2][200001];\nstring s;\nvector<pair<char, int>> d;\nvoid dfs(int i) {\n  if (arr[0][i] != -1) dfs(arr[0][i]);\n  d.push_back({s[i], i});\n  if (arr[1][i] != -1) dfs(arr[1][i]);\n}\nbool is_marked[200001]{0};\nbool is_doubled[200001]{0};\nint tot_b;\nvoid dfs2(int i, int cost, bool &is_child_marked) {\n  if (i == -1) return;\n  bool is_m = 0;\n  dfs2(arr[0][i], cost + 1, is_m);\n  is_child_marked = is_m;\n  if (!is_m && is_marked[i] && cost <= tot_b) {\n    tot_b -= cost;\n    is_child_marked = 1;\n    is_doubled[i] = 1;\n  } else if (is_m) {\n    is_doubled[i] = 1;\n  }\n  if (is_child_marked) {\n    dfs2(arr[1][i], 1, is_m);\n  }\n}\nvoid solve() {\n  int n, k, a, b;\n  cin >> n >> tot_b;\n  cin >> s;\n  for (int i = 0; i < n; i++) {\n    cin >> arr[0][i] >> arr[1][i];\n    arr[0][i]--;\n    arr[1][i]--;\n  }\n  dfs(0);\n  for (int i = 0; i < n - 1; i++) {\n    if (d[i].first >= d[i + 1].first) {\n      continue;\n    }\n    is_marked[d[i].second] = 1;\n    for (int j = i - 1; j >= 0; j--) {\n      if (d[j].first != d[i].first) break;\n      is_marked[d[j].second] = 1;\n    }\n  }\n  bool asdaa = 0;\n  dfs2(0, 1, asdaa);\n  for (int i = 0; i < n; i++) {\n    cout << d[i].first;\n    if (is_doubled[d[i].second]) cout << d[i].first;\n  }\n  cout << "\\n";\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  pre();\n  long long int num = 1;\n  for (long long int i = 0; i < num; i++) {\n    solve();\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nvoid foo() {\n  int n, k;\n  cin >> n >> k;\n  string c;\n  cin >> c;\n  vector<int> L(n), R(n), p(n, -1);\n  for (int i = 0; i < n; i++) {\n    cin >> L[i] >> R[i];\n    L[i]--;\n    R[i]--;\n    if (L[i] != -1) p[L[i]] = i;\n    if (R[i] != -1) p[R[i]] = i;\n  }\n  vector<int> preorder;\n  vector<int> order;\n  vector<int> pos(n);\n  vector<int> pos_pre(n);\n  function<void(int)> dfs = [&](int v) {\n    if (v == -1) return;\n    pos_pre[v] = preorder.size();\n    preorder.push_back(v);\n    dfs(L[v]);\n    pos[v] = order.size();\n    order.push_back(v);\n    dfs(R[v]);\n  };\n  dfs(0);\n  vector<bool> want(n);\n  for (int j = n - 2; j >= 0; j--) {\n    int v = order[j];\n    int nxt = order[j + 1];\n    if (c[v] == c[nxt]) {\n      want[v] = want[nxt];\n    } else {\n      want[v] = c[v] < c[nxt];\n    }\n  }\n  vector<bool> d(n);\n  int cnt = 0;\n  vector<int> cnt_top(n, -1);\n  for (int j = 0; j < n; j++) {\n    int v = order[j];\n    if (cnt_top[v] != -1) {\n      if (p[v] != -1) {\n        cnt_top[p[v]] = cnt_top[v] - !d[v];\n      }\n      if (R[v] != -1) {\n        cnt_top[R[v]] = cnt_top[v] + !d[R[v]];\n      }\n    }\n    if (!want[v] && !d[v]) {\n      if (p[v] == -1) break;\n      int nxt = j + 1;\n      while (nxt < n && pos_pre[order[nxt]] > pos_pre[v]) {\n        nxt++;\n      }\n      j = nxt - 1;\n    }\n    if (!want[v] || d[v]) {\n      continue;\n    }\n    if (p[v] != -1 && R[p[v]] == v) {\n      if (!d[p[v]]) {\n        int nxt = j + 1;\n        while (nxt < n && pos_pre[order[nxt]] > pos_pre[v]) {\n          nxt++;\n        }\n        j = nxt - 1;\n        continue;\n      }\n      cnt_top[v] = 1;\n    } else if (L[v] != -1 && cnt_top[L[v]] != -1) {\n      cnt_top[v] = cnt_top[L[v]] - 1;\n    } else if (cnt_top[v] != -1) {\n      continue;\n    } else {\n      cnt_top[v] = 0;\n      for (int x = v; x >= 0; x = p[x]) {\n        if (d[x]) break;\n        cnt_top[v]++;\n      }\n    }\n    if (cnt_top[v] + cnt > k) {\n      continue;\n    }\n    cnt += cnt_top[v];\n    for (int x = v; x >= 0 && !d[x]; x = p[x]) {\n      d[x] = true;\n      cnt_top[x] = 0;\n    }\n    if (R[v] != -1) {\n      cnt_top[R[v]] = -1;\n    }\n  }\n  string ans = "";\n  for (int v : order) {\n    ans += c[v];\n    if (d[v]) ans += c[v];\n  }\n  cout << ans << \'\\n\';\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  foo();\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize("O3,unroll-loops")\n#pragma target optimize("avx2,bmi,bmi2,lzcnt,popcnt")\ntemplate <class T>\nbool chmin(T &a, T b) {\n  return b < a and (a = b, true);\n}\ntemplate <class T>\nbool chmax(T &a, T b) {\n  return b > a and (a = b, true);\n}\nconst int maxn = 2e5 + 5;\nvector<int> vec;\nvector<int> stk;\nint ch[maxn][2];\nbool add[maxn];\nbool dub[maxn];\nint n, m;\nvoid dfs(int u) {\n  if (!u) return;\n  dfs(ch[u][0]);\n  vec.emplace_back(u);\n  ((void)0);\n  dfs(ch[u][1]);\n}\nvoid dfs2(int u) {\n  if (!u) return;\n  stk.emplace_back(u);\n  dfs2(ch[u][0]);\n  if (m >= stk.size() and add[u] and !dub[u]) {\n    for (int v : stk) dub[v] = 1;\n    m -= stk.size();\n    stk.clear();\n  }\n  if (add[u] or dub[u]) dfs2(ch[u][1]);\n  if (!stk.empty() and stk.back() == u) stk.pop_back();\n}\nvoid solve() {\n  string str, tmp;\n  cin >> n >> m;\n  cin >> str;\n  str = "@" + str;\n  for (int i = 1; i <= n; i++) cin >> ch[i][0] >> ch[i][1];\n  dfs(1);\n  for (int i = n - 2; ~i; i--)\n    add[vec[i]] = (str[vec[i]] < str[vec[i + 1]]) or\n                  (str[vec[i]] == str[vec[i + 1]] and add[vec[i + 1]]);\n  dfs2(1);\n  ((void)0);\n  ((void)0);\n  ((void)0);\n  string ans;\n  for (int v : vec) {\n    ans.push_back(str[v]);\n    if (dub[v]) ans.push_back(str[v]);\n  }\n  cout << ans << \'\\n\';\n}\nsigned main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  int T = 1;\n  while (T--) solve();\n  return 0;\n}\n', '#include <bits/stdc++.h>\nint ll[200000], rr[200000], pp[200000];\nchar cc[200000 + 1], profit[200000];\nint i_, j_;\nvoid dfs1(int i) {\n  if (i == -1) return;\n  dfs1(rr[i]);\n  if (i_ == -1 || cc[i_] != cc[i]) j_ = i_, i_ = i;\n  profit[i] = j_ != -1 && cc[i] < cc[j_];\n  dfs1(ll[i]);\n}\nchar bad[200000], dup[200000];\nint kk[200000], k_;\nint count(int i) {\n  if (i != -1 && bad[i]) return 0x3f3f3f3f;\n  if (i == -1 || dup[i]) return 0;\n  if (kk[i]) return kk[i];\n  return (kk[i] = count(pp[i]) + 1);\n}\nvoid mark(int i) {\n  while (i != -1 && !dup[i]) dup[i] = 1, i = pp[i];\n}\nvoid dfs2(int i) {\n  int k;\n  if (i == -1) return;\n  dfs2(ll[i]);\n  if (!dup[i]) {\n    if (profit[i] && (k = count(i)) <= k_)\n      k_ -= k, mark(i);\n    else\n      bad[i] = 1;\n  }\n  dfs2(rr[i]);\n}\nchar ans[200000 * 2 + 1];\nint n_;\nvoid dfs3(int i) {\n  if (i == -1) return;\n  dfs3(ll[i]);\n  ans[n_++] = cc[i];\n  if (dup[i]) ans[n_++] = cc[i];\n  dfs3(rr[i]);\n}\nint main() {\n  int n, i;\n  scanf("%d%d%s", &n, &k_, cc);\n  pp[0] = -1;\n  for (i = 0; i < n; i++) {\n    scanf("%d%d", &ll[i], &rr[i]), ll[i]--, rr[i]--;\n    if (ll[i] != -1) pp[ll[i]] = i;\n    if (rr[i] != -1) pp[rr[i]] = i;\n  }\n  i_ = j_ = -1, dfs1(0);\n  dfs2(0);\n  dfs3(0);\n  printf("%s\\n", ans);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nbool ckmin(T &a, const T &b) {\n  return a > b ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T &a, const T &b) {\n  return a < b ? a = b, 1 : 0;\n}\nnamespace debug {\nvoid __print(int x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << \'\\\'\' << x << \'\\\'\'; }\nvoid __print(const string &x) { cerr << \'\\"\' << x << \'\\"\'; }\nvoid __print(const char *x) { cerr << \'\\"\' << x << \'\\"\'; }\nvoid __print(bool x) { cerr << (x ? "true" : "false"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V> &x) {\n  cerr << \'{\';\n  __print(x.first);\n  cerr << \',\';\n  __print(x.second);\n  cerr << \'}\';\n}\ntemplate <typename T>\nvoid __print(const T &x) {\n  int f = 0;\n  cerr << \'{\';\n  for (auto z : x) cerr << (f++ ? "," : ""), __print(z);\n  cerr << "}";\n}\nvoid _print() { cerr << "]\\n"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << ", ";\n  _print(v...);\n}\n}  // namespace debug\nusing namespace debug;\nconst char nl = \'\\n\';\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  string st;\n  cin >> st;\n  vector<int> redosled;\n  vector<int> dep(n);\n  vector<int> levi(n), desni(n);\n  for (int i = 0; i < n; ++i) {\n    int l, r;\n    cin >> l >> r;\n    --l, --r;\n    levi[i] = l;\n    desni[i] = r;\n  }\n  function<void(int)> dfs = [&](int s) {\n    if (levi[s] != -1) {\n      dep[levi[s]] = dep[s] + 1;\n      dfs(levi[s]);\n    }\n    redosled.push_back(s);\n    if (desni[s] != -1) {\n      dep[desni[s]] = dep[s] + 1;\n      dfs(desni[s]);\n    }\n  };\n  dfs(0);\n  vector<bool> dobar(n);\n  auto resi = [&](int l, int r) {\n    if (r != n && st[redosled[r]] > st[redosled[l]]) {\n      for (int i = l; i < r; ++i) {\n        dobar[i] = true;\n      }\n    } else {\n      for (int i = l; i < r; ++i) {\n        dobar[i] = false;\n      }\n    }\n  };\n  for (int i = 0, j = 0; i < n; i = j) {\n    while (j < n && st[redosled[j]] == st[redosled[i]]) ++j;\n    resi(i, j);\n  }\n  {\n    vector<bool> novi(n);\n    for (int i = 0; i < n; ++i) {\n      novi[redosled[i]] = dobar[i];\n    }\n    dobar = novi;\n  }\n  const int LG = 18;\n  vector<vector<int> > up(n, vector<int>(LG, -1));\n  function<void(int, int)> dfs2 = [&](int s, int p) {\n    up[s][0] = p;\n    for (int i = 1; i < LG; ++i) {\n      if (up[s][i - 1] == -1) {\n        up[s][i] = -1;\n        continue;\n      }\n      up[s][i] = up[up[s][i - 1]][i - 1];\n    }\n    int l = levi[s];\n    int r = desni[s];\n    if (l != -1) {\n      dfs2(l, s);\n    }\n    if (r != -1) {\n      dfs2(r, s);\n    }\n  };\n  dfs2(0, -1);\n  vector<bool> marked(n);\n  ;\n  function<void(int)> dfs3 = [&](int s) {\n    int l = levi[s];\n    int r = desni[s];\n    if (l != -1) dfs3(l);\n    cout << st[s];\n    if (r != -1) dfs3(r);\n  };\n  function<void(int)> dfs4 = [&](int s) {\n    if (levi[s] != -1) dfs4(levi[s]);\n    if (!marked[s] && dobar[s]) {\n      int tren = s;\n      int ides = -1;\n      int ima = -1;\n      if (!marked[0]) {\n        ides = -1;\n        ima = dep[tren] + 1;\n      } else {\n        ides = tren;\n        for (int i = LG - 1; i >= 0; --i) {\n          int x = up[ides][i];\n          if (x == -1) continue;\n          if (marked[x]) continue;\n          ides = x;\n        }\n        ides = up[ides][0];\n        ima = dep[tren] - dep[ides];\n      }\n      if (ima <= k) {\n        k -= ima;\n        while (1) {\n          if (tren == ides) break;\n          marked[tren] = true;\n          tren = up[tren][0];\n        }\n      }\n    }\n    cout << st[s];\n    if (marked[s]) {\n      cout << st[s];\n      if (desni[s] != -1) dfs4(desni[s]);\n    } else {\n      if (desni[s] != -1) dfs3(desni[s]);\n    }\n  };\n  dfs4(0);\n  cout << nl;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int testCases = 1;\n  while (testCases--) solve();\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200005;\nint n, k, ss, dfns;\nint l[maxn], r[maxn], cst[maxn], vis[maxn], st[maxn], ok[maxn];\nstring s;\nvoid dfs(int x) {\n  if (x == 0) return;\n  dfs(l[x]), st[++ss] = x, dfs(r[x]);\n}\nvoid down(int x) {\n  if (x == 0) return;\n  if (cst[x] > k) return;\n  cst[l[x]] = cst[x] + 1, down(l[x]);\n  if (vis[l[x]])\n    vis[x] = 1;\n  else if (ok[x])\n    k -= cst[x], vis[x] = 1;\n  if (vis[x]) cst[r[x]] = 1, down(r[x]);\n}\nint main() {\n  scanf("%d%d", &n, &k), cin >> s, s = " " + s;\n  for (int i = 1; i <= n; i++) scanf("%d%d", &l[i], &r[i]);\n  dfs(1);\n  for (int i = n - 1; i >= 1; i--) {\n    ok[st[i]] = ok[st[i + 1]];\n    if (s[st[i]] > s[st[i + 1]]) ok[st[i]] = 0;\n    if (s[st[i]] < s[st[i + 1]]) ok[st[i]] = 1;\n  }\n  cst[1] = 1, down(1);\n  for (int i = 1; i <= n; i++) {\n    putchar(s[st[i]]);\n    if (vis[st[i]]) putchar(s[st[i]]);\n  }\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint tin[N], left_child[N], right_child[N], dup[N];\nvoid dfs1(vector<int> &seq, int cur, int &t) {\n  if (left_child[cur] >= 0) dfs1(seq, left_child[cur], t);\n  seq.push_back(cur);\n  tin[cur] = t;\n  t++;\n  if (right_child[cur] >= 0) dfs1(seq, right_child[cur], t);\n}\nvoid dfs2(set<int> &st, vector<int> &seq, vector<int> &suf, int cur, int n,\n          int &k) {\n  st.insert(tin[cur]);\n  if (left_child[cur] >= 0) dfs2(st, seq, suf, left_child[cur], n, k);\n  if (suf[tin[cur]] && st.find(tin[cur]) != st.end() &&\n      *st.begin() >= tin[cur]) {\n    int sz = (int)st.size();\n    if (sz <= k) {\n      k -= sz;\n      while (!st.empty()) {\n        dup[seq[*st.begin()]] = 1;\n        st.erase(st.begin());\n      }\n    }\n  }\n  if (right_child[cur] >= 0) dfs2(st, seq, suf, right_child[cur], n, k);\n  st.erase(tin[cur]);\n}\nstring solve() {\n  int n, k;\n  string str, res = "";\n  cin >> n >> k >> str;\n  for (int i = 0; i < n; i++) {\n    dup[i] = 0;\n    cin >> left_child[i] >> right_child[i];\n    left_child[i]--;\n    right_child[i]--;\n  }\n  vector<int> seq;\n  int t = 0;\n  dfs1(seq, 0, t);\n  string in_str = str;\n  for (int i = 0; i < n; i++) str[i] = in_str[seq[i]];\n  vector<int> suf(n);\n  for (int i = n - 2; i >= 0; i--) {\n    if (str[i] < str[i + 1])\n      suf[i] = 1;\n    else if (str[i] > str[i + 1])\n      suf[i] = 0;\n    else if (str[i] == str[i + 1])\n      suf[i] = suf[i + 1];\n  }\n  set<int> st;\n  dfs2(st, seq, suf, 0, n, k);\n  for (int i = 0; i < n; i++) {\n    res.push_back(str[i]);\n    if (dup[seq[i]]) res.push_back(str[i]);\n  }\n  return res;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cout << solve() << "\\n";\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n  int l, r, lst;\n  char c;\n} a[200005];\nint n, k, lst, h[200005];\nbool vis[200005];\nchar s[200005];\ninline void dfs(int x, int fa) {\n  if (!x) return;\n  h[x] = h[fa] + 1;\n  dfs(a[x].l, x);\n  a[lst].lst = x;\n  lst = x;\n  dfs(a[x].r, x);\n}\ninline int work(int x) {\n  if (!a[x].lst || a[a[x].lst].c != a[x].c) return a[x].lst;\n  return a[x].lst = work(a[x].lst);\n}\ninline void dfs2(int x, int now) {\n  if (!x) return;\n  dfs2(a[x].l, now);\n  if (vis[a[x].l]) {\n    vis[x] = 1;\n  } else {\n    if (a[x].c < a[a[x].lst].c && h[x] - now <= k) {\n      k -= h[x] - now;\n      vis[x] = 1;\n    }\n  }\n  if (vis[x]) dfs2(a[x].r, h[x]);\n}\ninline void dfs3(int x) {\n  if (!x) return;\n  dfs3(a[x].l);\n  putchar(a[x].c);\n  if (vis[x]) putchar(a[x].c);\n  dfs3(a[x].r);\n  return;\n}\nint main() {\n  scanf("%d%d", &n, &k);\n  scanf("%s", s + 1);\n  for (int i = 1; i <= n; i++) {\n    a[i].c = s[i];\n    scanf("%d%d", &a[i].l, &a[i].r);\n  }\n  dfs(1, 1);\n  for (int i = 1; i <= n; i++) {\n    work(i);\n  }\n  dfs2(1, 0);\n  dfs3(1);\n  puts("");\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nchar s[N], ans[N * 2];\nint box[26], node[N], flag[N], fa[N][25];\nint l[N], r[N], nex[N], cnt = 0;\nvoid dfs(int x) {\n  if (!x) return;\n  for (int i = 1; i <= 20; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];\n  dfs(l[x]);\n  ans[++cnt] = s[x];\n  node[cnt] = x;\n  dfs(r[x]);\n}\nvoid floodfill(int x) {\n  if (!x) return;\n  if (flag[x] != 0) return;\n  flag[x] = -1;\n  floodfill(l[x]);\n  floodfill(r[x]);\n}\nint getans(int x) {\n  if (flag[x] == 1 || x == 0) return 0;\n  return getans(fa[x][0]) + 1;\n}\nvoid DFS(int x) {\n  if (!x) return;\n  DFS(l[x]);\n  ans[++cnt] = s[x];\n  if (flag[x] == 1) ans[++cnt] = s[x];\n  DFS(r[x]);\n}\nint getfa(int x, int y) {\n  for (int i = 20; i >= 0; i--)\n    if (y >= (1 << i)) {\n      x = fa[x][i];\n      y -= (1 << i);\n    }\n  return x;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  scanf("%s", s + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d %d", &l[i], &r[i]);\n    fa[l[i]][0] = fa[r[i]][0] = i;\n  }\n  fa[0][0] = 0;\n  flag[0] = 1;\n  dfs(1);\n  memset(nex, 0x3f, sizeof(nex));\n  memset(box, 0x3f, sizeof(box));\n  for (int i = n; i >= 1; i--) {\n    box[ans[i] - \'a\'] = i;\n    for (int j = 0; j <= 25; j++) {\n      if (j != ans[i] - \'a\') nex[i] = min(nex[i], box[j]);\n    }\n  }\n  for (int i = 1; i <= cnt; i++) {\n    if (flag[node[i]] != 0) continue;\n    if (nex[i] == 0x3f3f3f3f || ans[nex[i]] < ans[i]) {\n      floodfill(node[i]);\n      continue;\n    }\n    int val = getfa(node[i], m);\n    if (flag[val]) {\n      for (int j = node[i]; flag[j] == 0; j = fa[j][0]) {\n        flag[j] = 1;\n        m--;\n      }\n    } else\n      floodfill(node[i]);\n  }\n  cnt = 0;\n  DFS(1);\n  for (int i = 1; i <= cnt; i++) printf("%c", ans[i]);\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e8;\nconst int MX = 2e5 + 5;\nvector<int> vorder;\nint dup[MX], lc[MX], rc[MX], good[MX], seek[MX];\nstring labels, corder;\nvoid ino(int curr) {\n  if (curr == -1) return;\n  ino(lc[curr]);\n  vorder.push_back(curr);\n  corder += labels[curr];\n  ino(rc[curr]);\n}\nvoid dfs1(int curr) {\n  if (curr == -1) return;\n  seek[curr] = INF;\n  dfs1(lc[curr]);\n  dfs1(rc[curr]);\n  if (lc[curr] != -1) seek[curr] = 1 + seek[lc[curr]];\n  if (good[curr]) seek[curr] = 1;\n}\nint dfs2(int curr, int k) {\n  if (curr == -1) return k;\n  if (seek[curr] <= k) {\n    k--;\n    dup[curr] = 1;\n    k = dfs2(lc[curr], k);\n    return dfs2(rc[curr], k);\n  }\n  return k;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n, k;\n  cin >> n >> k;\n  cin >> labels;\n  for (int i = 0; i < n; i++) {\n    cin >> lc[i] >> rc[i];\n    lc[i]--;\n    rc[i]--;\n  }\n  ino(0);\n  corder += '@';\n  char last;\n  for (int i = n - 1; i >= 0; i--) {\n    if (corder[i] != corder[i + 1]) last = corder[i + 1];\n    good[vorder[i]] = corder[i] < last;\n  }\n  memset(dup, 0, sizeof dup);\n  dfs1(0);\n  dfs2(0, k);\n  for (int v : vorder) {\n    if (dup[v])\n      cout << labels[v] << labels[v];\n    else\n      cout << labels[v];\n  }\n  cout << '\\n';\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\ntemplate <typename T>\nbool chmax(T &x, const T &y) {\n  return (x < y) ? (x = y, true) : false;\n}\ntemplate <typename T>\nbool chmin(T &x, const T &y) {\n  return (x > y) ? (x = y, true) : false;\n}\ntemplate <typename T>\nint flg(T x, int i) {\n  return (x >> i) & 1;\n}\ntemplate <typename T>\nvoid print(const vector<T> &v, T x = 0) {\n  int n = v.size();\n  for (int i = 0; i < n; i++) cout << v[i] + x << (i == n - 1 ? '\\n' : ' ');\n  if (v.empty()) cout << '\\n';\n}\ntemplate <typename T>\nvoid printn(const vector<T> &v, T x = 0) {\n  int n = v.size();\n  for (int i = 0; i < n; i++) cout << v[i] + x << '\\n';\n}\ntemplate <typename T>\nint lb(const vector<T> &v, T x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\ntemplate <typename T>\nint ub(const vector<T> &v, T x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\ntemplate <typename T>\nvoid rearrange(vector<T> &v) {\n  sort(begin(v), end(v));\n  v.erase(unique(begin(v), end(v)), end(v));\n}\ntemplate <typename T>\nvector<int> id_sort(const vector<T> &v, bool greater = false) {\n  int n = v.size();\n  vector<int> ret(n);\n  iota(begin(ret), end(ret), 0);\n  sort(begin(ret), end(ret),\n       [&](int i, int j) { return greater ? v[i] > v[j] : v[i] < v[j]; });\n  return ret;\n}\ntemplate <typename S, typename T>\npair<S, T> operator+(const pair<S, T> &p, const pair<S, T> &q) {\n  return make_pair(p.first + q.first, p.second + q.second);\n}\ntemplate <typename S, typename T>\npair<S, T> operator-(const pair<S, T> &p, const pair<S, T> &q) {\n  return make_pair(p.first - q.first, p.second - q.second);\n}\ntemplate <typename S, typename T>\nistream &operator>>(istream &is, pair<S, T> &p) {\n  S a;\n  T b;\n  is >> a >> b;\n  p = make_pair(a, b);\n  return is;\n}\ntemplate <typename S, typename T>\nostream &operator<<(ostream &os, const pair<S, T> &p) {\n  return os << p.first << ' ' << p.second;\n}\nstruct io_setup {\n  io_setup() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout << fixed << setprecision(15);\n  }\n} io_setup;\nconst int inf = (1 << 30) - 1;\nconst ll INF = (1LL << 60) - 1;\nconst int MOD = 1000000007;\nstring S;\ntemplate <bool directed = false>\nstruct Graph {\n  const int n;\n  vector<int> l, r;\n  vector<int> vs;\n  string ans;\n  vector<bool> flag;\n  Graph(int n) : n(n), l(n, -1), r(n, -1), flag(n, false) {}\n  void euler_tour(int now) {\n    if (l[now] != -1) euler_tour(l[now]);\n    vs.push_back(now);\n    if (r[now] != -1) euler_tour(r[now]);\n  }\n  int dfs(int now, int k) {\n    int ret = 0;\n    bool used = false;\n    if (l[now] != -1) {\n      int x = dfs(l[now], max(k - 1, 0));\n      ret += x;\n      k -= x;\n      if (x > 0) used = true;\n    }\n    if (k > 0 && !used && flag[now]) used = true;\n    ans += S[now];\n    if (used) k--, ret++, ans += S[now];\n    if (r[now] != -1) {\n      int y = dfs(r[now], (used ? k : 0));\n      ret += y;\n      k -= y;\n    }\n    return ret;\n  }\n  void solve(int k) {\n    euler_tour(0);\n    for (int i = 0; i < n;) {\n      int j = 0;\n      while (i + j < n && S[vs[i + j]] == S[vs[i]]) j++;\n      bool tmp = (i + j < n && S[vs[i]] < S[vs[i + j]]);\n      for (int k = 0; k < j; k++) flag[vs[i + k]] = tmp;\n      i += j;\n    }\n    dfs(0, k);\n    cout << ans << '\\n';\n  }\n};\nint main() {\n  int N, K;\n  cin >> N >> K >> S;\n  Graph<true> G(N);\n  for (int i = 0; i < N; i++) {\n    int l, r;\n    cin >> l >> r;\n    l--, r--;\n    if (l >= 0) G.l[i] = l;\n    if (r >= 0) G.r[i] = r;\n  }\n  G.solve(K);\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nconst int mx = 2e5 + 5;\nint n, k, cnt, L[mx], R[mx], elem[mx], nxt[mx];\nbool dupe[mx];\nstring tmpStr;\nvector<char> S;\nvoid build(int cur) {\n  if (~L[cur]) build(L[cur]);\n  S.push_back(tmpStr[cur]);\n  elem[cur] = cnt++;\n  if (~R[cur]) build(R[cur]);\n}\nbool inorder(int cur, int cst) {\n  int spos = elem[cur];\n  if (~L[cur]) dupe[spos] = inorder(L[cur], cst + 1);\n  if (!dupe[spos] and S[spos] < S[nxt[spos]] and cst <= k) {\n    dupe[spos] = 1;\n    k -= cst;\n  }\n  if (~R[cur] and dupe[spos]) inorder(R[cur], 1);\n  return dupe[spos];\n}\nint main() {\n  cin >> n >> k >> tmpStr;\n  for (int i = 0; i < n; i++) cin >> L[i] >> R[i], L[i]--, R[i]--;\n  build(0);\n  nxt[n - 1] = n - 1;\n  for (int i = n - 2; ~i; i--) nxt[i] = (S[i] != S[i + 1]) ? i + 1 : nxt[i + 1];\n  inorder(0, 1);\n  for (int i = 0; i < n; i++) {\n    cout << S[i];\n    if (dupe[i]) cout << S[i];\n  }\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nchar BB[1 << 16], *SB = BB, *TB = BB;\ntemplate <typename T>\nvoid read(T &n) {\n  T w = 1;\n  n = 0;\n  char ch =\n      (SB == TB && (TB = (SB = BB) + fread(BB, 1, 1 << 15, stdin), SB == TB)\n           ? EOF\n           : *SB++);\n  while (!isdigit(ch)) {\n    if (ch == '-') w = -1;\n    ch = (SB == TB && (TB = (SB = BB) + fread(BB, 1, 1 << 15, stdin), SB == TB)\n              ? EOF\n              : *SB++);\n  }\n  while (isdigit(ch)) {\n    n = (n << 3) + (n << 1) + (ch & 15);\n    ch = (SB == TB && (TB = (SB = BB) + fread(BB, 1, 1 << 15, stdin), SB == TB)\n              ? EOF\n              : *SB++);\n  }\n  n *= w;\n}\ntemplate <typename T>\ninline void exg(T &a, T &b) {\n  a ^= b ^= a ^= b;\n}\ntemplate <typename T>\ninline void chkmn(T &a, const T &b) {\n  (a > b) && (a = b);\n}\ntemplate <typename T>\ninline void chkmx(T &a, const T &b) {\n  (a < b) && (a = b);\n}\ninline int min(const int &a, const int &b) { return a < b ? a : b; }\ninline int max(const int &a, const int &b) { return a > b ? a : b; }\ninline long long min(const long long &a, const long long &b) {\n  return a < b ? a : b;\n}\ninline long long max(const long long &a, const long long &b) {\n  return a > b ? a : b;\n}\nint MOD;\ninline int adt(const int &a) { return (a % MOD + MOD) % MOD; }\ninline int inc(const int &a, const int &b) {\n  return a + b >= MOD ? a + b - MOD : a + b;\n}\ninline int dec(const int &a, const int &b) {\n  return a - b < 0 ? a - b + MOD : a - b;\n}\ninline int mul(const int &a, const int &b) { return 1LL * a * b % MOD; }\ninline int sqr(const int &a) { return 1LL * a * a % MOD; }\ninline int cub(const int &a) { return 1LL * a * a % MOD * a % MOD; }\ninline void Adt(int &a) { a = (a % MOD + MOD) % MOD; }\ninline void Inc(int &a, const int &b) { ((a += b) >= MOD) && (a -= MOD); }\ninline void Dec(int &a, const int &b) { ((a -= b) < 0) && (a += MOD); }\ninline void Mul(int &a, const int &b) { a = 1LL * a * b % MOD; }\ninline void Sqr(int &a) { a = 1LL * a * a % MOD; }\ninline void Cub(int &a) { a = 1LL * a * a % MOD * a % MOD; }\ninline int fsp(int a, int x = MOD - 2) {\n  int res = 1;\n  while (x) {\n    if (x & 1) Mul(res, a);\n    Sqr(a), x >>= 1;\n  }\n  return res;\n}\nconst int maxn = 2e5 + 5;\nint n, k, tot;\nint lc[maxn], rc[maxn], ord[maxn], fa[maxn];\nbool fl[maxn], ok[maxn];\nchar S[maxn];\nvoid DFS(int u) {\n  if (!u) return;\n  DFS(lc[u]), ord[++tot] = u, DFS(rc[u]);\n}\nvoid Solve(int u, int co) {\n  if (!u || co > k) return;\n  Solve(lc[u], co + 1);\n  if (fl[lc[u]])\n    fl[u] = 1;\n  else if (ok[u])\n    fl[u] = 1, k -= co;\n  if (fl[u]) Solve(rc[u], 1);\n}\nvoid Output(int u) {\n  if (!u) return;\n  Output(lc[u]);\n  cout << S[u];\n  if (fl[u]) cout << S[u];\n  Output(rc[u]);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k >> (S + 1);\n  for (int i = (1); i <= (n); ++i) cin >> lc[i] >> rc[i];\n  DFS(1);\n  int p = ord[n];\n  for (int i = (n - 1); i >= (1); --i) {\n    if (S[ord[i]] ^ S[ord[i + 1]]) p = ord[i + 1];\n    if (S[ord[i]] < S[p]) ok[ord[i]] = 1;\n  }\n  Solve(1, 1);\n  Output(1);\n  return 0;\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nint n, k, l[200010], r[200010], pos[200010];\nchar c[200010];\nvector<int> seq;\nvoid precalc(int u) {\n  if (l[u]) precalc(l[u]);\n  seq.push_back(u);\n  if (r[u]) precalc(r[u]);\n}\nbool good[200010], isDup[200010];\nvoid dfs(int u, int cost) {\n  if (!u || cost > k) return;\n  dfs(l[u], cost + 1);\n  if (isDup[l[u]])\n    isDup[u] = 1;\n  else if (good[u])\n    isDup[u] = 1, k -= cost;\n  if (isDup[u]) dfs(r[u], 1);\n}\nint main() {\n  scanf("%d%d", &n, &k);\n  scanf("%s", c + 1);\n  for (int i = 1; i <= n; i++) scanf("%d%d", &l[i], &r[i]);\n  precalc(1);\n  char lst = c[seq.back()];\n  for (int i = n - 2; i >= 0; i--) {\n    int u = seq[i], v = seq[i + 1];\n    if (c[u] != c[v]) lst = c[v];\n    if (c[u] < lst) good[u] = 1;\n  }\n  dfs(1, 1);\n  for (auto u : seq) {\n    putchar(c[u]);\n    if (isDup[u]) putchar(c[u]);\n  }\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int mx = 2e5 + 5, ml = 18;\nint n, k, cnt, L[mx], R[mx], dep[mx], nxt[mx], node[mx], up[mx][ml], dupe[mx],\n    bad[mx];\nstring tmpS;\nvector<char> S, ans;\nvoid inorder(int cur) {\n  int l = L[cur], r = R[cur];\n  for (int i = 1; i < ml; i++) up[cur][i] = up[up[cur][i - 1]][i - 1];\n  up[l][0] = up[r][0] = cur;\n  dep[l] = dep[r] = dep[cur] + 1;\n  if (l) inorder(l);\n  node[++cnt] = cur;\n  S[cnt] = tmpS[cur];\n  if (r) inorder(r);\n}\nvoid fillBad(int cur) {\n  if (bad[cur]) return;\n  bad[cur] = 1;\n  if (L[cur]) fillBad(L[cur]);\n  if (R[cur]) fillBad(R[cur]);\n}\nint main() {\n  cin >> n >> k >> tmpS;\n  for (int i = 1; i < n + 1; i++) cin >> L[i] >> R[i];\n  tmpS = " " + tmpS;\n  S.resize(n + 1);\n  inorder(1);\n  for (int i = n - 1; i; i--) {\n    if (S[i] != S[i + 1])\n      nxt[i] = i + 1;\n    else\n      nxt[i] = nxt[i + 1];\n  }\n  bad[0] = dupe[0] = 1;\n  for (int i = 1; i < n; i++) {\n    int cur = node[i], anc = cur;\n    if (bad[cur] or dupe[cur]) continue;\n    if (S[i] > S[nxt[i]]) {\n      fillBad(cur);\n      continue;\n    }\n    for (int x = ml - 1; ~x; x--)\n      if (!dupe[up[anc][x]]) anc = up[anc][x];\n    int cst = dep[cur] - dep[anc] + 1;\n    if (cst > k) continue;\n    k -= cst;\n    while (!dupe[cur]) dupe[cur] = 1, cur = up[cur][0];\n  }\n  for (int i = 1; i < n + 1; i++) {\n    ans.push_back(S[i]);\n    if (dupe[node[i]]) ans.push_back(S[i]);\n  }\n  for (char c : ans) cout << c;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 7;\nint n, k;\nstring s, t;\nvector<int> nodes;\nvector<pair<int, int>> g(N), p(N);\nvoid solveInitial(int u) {\n  if (~g[u].first) solveInitial(g[u].first);\n  nodes.push_back(u);\n  if (~g[u].second) solveInitial(g[u].second);\n}\nbool solve(int u, int c, bool canDup) {\n  bool dupPar = 0, ret = 0;\n  if (~g[u].first) ret = solve(g[u].first, c + 1, canDup);\n  t += s[u];\n  if (ret)\n    dupPar = 1, c = 0, t += s[u];\n  else {\n    if (c <= k && p[u].first > p[u].second && canDup)\n      dupPar = 1, k -= c, c = 0, t += s[u];\n  }\n  if (!dupPar) canDup = 0;\n  ret = 0;\n  if (~g[u].second) ret = solve(g[u].second, c + 1, canDup);\n  return dupPar;\n}\nvoid testCase() {\n  cin >> n >> k >> s;\n  for (int i = 0; i < n; i++)\n    cin >> g[i].first >> g[i].second, g[i].first--, g[i].second--;\n  solveInitial(0);\n  vector<int> v(26, 1e9);\n  for (int i = nodes.size() - 1; i >= 0; i--) {\n    char c = s[nodes[i]];\n    int l = 1e9, r = 1e9;\n    for (int j = c - 'a' + 1; j < 26; j++) r = min(r, v[j]);\n    for (int j = c - 'a' - 1; j >= 0; j--) l = min(l, v[j]);\n    p[nodes[i]] = {l, r};\n    v[c - 'a'] = i;\n  }\n  solve(0, 1, 1);\n  cout << t;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int T = 1;\n  while (T--) testCase();\n  return 0;\n}\n", '#include <bits/stdc++.h>\nlong getbit(long first, long second) { return ((first >> second) & 1); }\nusing namespace std;\nconst long N = 2e5 + 5;\nlong cnt, n, k, l[N], r[N], h[N];\nchar c[N];\nstring s;\nvector<long> so;\nbool dd[N], Next[N];\nvoid tao(long u, long pa) {\n  h[u] = h[pa] + 1;\n  if (l[u] != 0) tao(l[u], u);\n  s += c[u];\n  so.push_back(u);\n  if (r[u] != 0) tao(r[u], u);\n}\nvoid dfs(long u, long last) {\n  if (l[u] != 0) {\n    if (Next[l[u]] && cnt + h[l[u]] - h[last] <= k) {\n      dd[l[u]] = 1;\n      cnt += h[l[u]] - h[last];\n      last = u;\n      dfs(l[u], l[u]);\n    } else\n      dfs(l[u], last);\n  }\n  if (l[u] != 0 && dd[l[u]]) dd[u] = 1;\n  if (dd[u]) last = u;\n  if ((dd[u] || Next[u]) && cnt + h[u] - h[last] <= k) {\n    dd[u] = 1;\n    cnt += h[u] - h[last];\n    if (r[u] != 0) dfs(r[u], u);\n  }\n  if (r[u] != 0 && dd[r[u]]) dd[u] = 1;\n}\nvoid dfs1(long u) {\n  if (l[u] != 0) {\n    dfs1(l[u]);\n    dd[u] |= dd[l[u]];\n  }\n  if (r[u] != 0) {\n    dfs1(r[u]);\n    dd[u] |= dd[r[u]];\n  }\n}\nvoid tao1(long u) {\n  if (l[u] != 0) tao1(l[u]);\n  if (dd[u])\n    s += c[u], s += c[u];\n  else\n    s += c[u];\n  if (r[u] != 0) tao1(r[u]);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long i = 1; i <= n; i++) cin >> c[i];\n  for (long i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  s = "";\n  tao(1, 0);\n  for (long i = (long)s.size() - 1; i >= 0; i--)\n    if (i == (long)s.size() - 1)\n      Next[so[i]] = 0;\n    else if (s[i] < s[i + 1])\n      Next[so[i]] = 1;\n    else if (s[i] == s[i + 1])\n      Next[so[i]] = Next[so[i + 1]];\n    else\n      Next[so[i]] = 0;\n  dfs(1, 0);\n  dfs1(1);\n  s = "";\n  tao1(1);\n  cout << s << \'\\n\';\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200000;\nstruct node {\n  int left;\n  int right;\n};\nstruct node t[N + 5];\nint tot, id[N + 5], depth[N + 5];\nchar a[N + 5];\nbool col[N + 5];\nchar str[N + 5], dif[N + 5];\nvoid dfs(int place, int father) {\n  if (!place) return;\n  depth[place] = depth[father] + 1;\n  dfs(t[place].left, place);\n  str[++tot] = a[place];\n  id[place] = tot;\n  dfs(t[place].right, place);\n}\nvoid print(int place) {\n  if (!place) return;\n  print(t[place].left);\n  printf("%c", a[place]);\n  if (col[place]) printf("%c", a[place]);\n  print(t[place].right);\n}\nint k;\nbool add(int place, int top) {\n  bool ans = 0;\n  if (t[place].left && k) ans = add(t[place].left, top);\n  if (ans)\n    col[place] = 1;\n  else if (a[place] < dif[id[place]] && k >= depth[place] - depth[top]) {\n    k -= depth[place] - depth[top];\n    ans = 1;\n    col[place] = 1;\n  }\n  if (!ans) return 0;\n  if (t[place].right && k) add(t[place].right, place);\n  return 1;\n}\nint main() {\n  int n;\n  scanf("%d%d", &n, &k);\n  scanf("%s", a + 1);\n  for (int i = 1; i <= n; i++) scanf("%d%d", &t[i].left, &t[i].right);\n  dfs(1, 1);\n  dif[n] = str[n];\n  for (int i = n - 1; i >= 1; i--) {\n    if (str[i] == str[i + 1])\n      dif[i] = dif[i + 1];\n    else\n      dif[i] = str[i + 1];\n  }\n  add(1, 0);\n  print(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nint n, k, l[maxn], r[maxn], lans, to[maxn], lc2, bac[maxn], L[maxn], R[maxn],\n    t[maxn];\nchar c[maxn], c2[maxn], nxt[maxn];\nchar ans[maxn * 2];\nbool b[maxn], db[maxn];\nvoid ss1(int x) {\n  if (l[x]) ss1(l[x]);\n  c2[++lc2] = c[x];\n  to[x] = lc2;\n  bac[to[x]] = x;\n  if (r[x]) ss1(r[x]);\n  return;\n}\nint ss2(int x) {\n  L[x] = 9999999;\n  R[x] = 9999999;\n  if (l[x]) L[x] = ss2(l[x]);\n  if (r[x]) R[x] = ss2(r[x]);\n  if (b[x])\n    return t[x] = 1;\n  else\n    return t[x] = L[x] + 1;\n}\nbool ss3(int x) {\n  bool flag = false;\n  if (t[x] <= k) {\n    k--;\n    db[x] = true;\n    flag = true;\n    if (L[x] <= k) flag = flag | ss3(l[x]);\n    if (R[x] <= k && flag) ss3(r[x]);\n  }\n  return flag;\n}\nvoid ss4(int x) {\n  if (l[x]) ss4(l[x]);\n  ans[++lans] = c[x];\n  if (db[x]) {\n    ans[++lans] = c[x];\n  }\n  if (r[x]) ss4(r[x]);\n  return;\n}\nint main() {\n  scanf("%d%d", &n, &k);\n  scanf("%s", c + 1);\n  for (int i = 1; i <= n; i++) scanf("%d%d", &l[i], &r[i]);\n  ss1(1);\n  c2[lc2 + 1] = \'a\' - 5;\n  for (int i = lc2; i >= 1; i--) {\n    if (c2[i] == c2[i + 1])\n      nxt[i] = nxt[i + 1];\n    else\n      nxt[i] = c2[i + 1];\n    if (c2[i] < nxt[i]) b[bac[i]] = true;\n  }\n  ss2(1);\n  ss3(1);\n  ss4(1);\n  printf("%s\\n", ans + 1);\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint n, k, ls[200005], rs[200005];\nchar a[200005];\nint cnt, rk[200005];\nbool vis[200005];\nvoid get(int u) {\n  if (u == 0) return;\n  get(ls[u]);\n  rk[++cnt] = u;\n  get(rs[u]);\n}\nbool xz[200005];\nbool dfs(int u, int d) {\n  if (u == 0) return false;\n  if (dfs(ls[u], d + 1)) {\n    xz[u] = true;\n    dfs(rs[u], 1);\n  } else {\n    if (vis[u] && d <= k) {\n      k = k - d;\n      xz[u] = true;\n      dfs(rs[u], 1);\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nvoid print(int u) {\n  if (u == 0) return;\n  print(ls[u]);\n  printf("%c", a[u]);\n  if (xz[u] == true) {\n    printf("%c", a[u]);\n  }\n  print(rs[u]);\n}\nint main() {\n  scanf("%d%d\\n%s", &n, &k, a + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", &ls[i], &rs[i]);\n  }\n  get(1);\n  int nxt = 1;\n  for (int i = 1; i <= n; i++) {\n    while (nxt < n && a[rk[i]] == a[rk[nxt]]) nxt++;\n    if (a[rk[i]] < a[rk[nxt]]) vis[rk[i]] = true;\n  }\n  dfs(1, 1);\n  print(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint l[200100], r[200100];\nint p[200100];\nbool db[200100];\nbool du[200100];\nstring x;\nstring f = "";\nvector<int> v;\nvoid go(int cr) {\n  if (l[cr] != 0) go(l[cr]);\n  f += x[cr];\n  v.push_back(cr);\n  if (r[cr] != 0) go(r[cr]);\n}\nbool gr[200100];\nint go2(int cr, int d) {\n  int dk = 0;\n  if (l[cr] != 0) {\n    dk = go2(l[cr], d + 1);\n  }\n  if (!dk) {\n    if (k >= d && gr[cr]) {\n      k -= d;\n      dk = 1;\n    }\n  }\n  if (r[cr] != 0 && dk) {\n    go2(r[cr], 1);\n  }\n  if (dk) db[cr] = 1;\n  return dk;\n}\nint main() {\n  cin >> n >> k >> x;\n  x = \'0\' + x;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n    p[l[i]] = i;\n    p[r[i]] = i;\n  }\n  go(1);\n  int s[200100];\n  int nxt = 0;\n  for (int i = f.size() - 1; i >= 0; i--) {\n    s[i] = nxt;\n    if (i > 0) {\n      if (f[i] == f[i - 1]) continue;\n      nxt = f[i] - \'a\';\n    }\n  }\n  for (int i = 0; i < f.size(); i++) {\n    if (f[i] - \'a\' < s[i]) {\n      gr[v[i]] = 1;\n    }\n  }\n  go2(1, 1);\n  for (int i = 0; i < f.size(); i++) {\n    cout << f[i];\n    if (db[v[i]] == 1) cout << f[i];\n  }\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nstruct P {\n  int x, y;\n  bool operator<(const P &p) {\n    if (x != p.x)\n      return x < p.x;\n    else\n      return y < p.y;\n  }\n};\nint main() {\n  int n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  int tl, tr;\n  vector<int> l(n, -1), r(n, -1), p(n, -1);\n  for (int i = 0; i < n; ++i) {\n    scanf("%d %d", &tl, &tr);\n    l[i] = tl - 1;\n    r[i] = tr - 1;\n    if (tl > 0) {\n      p[tl - 1] = i;\n    }\n    if (tr > 0) {\n      p[tr - 1] = i;\n    }\n  }\n  int ancDist = sqrt(n);\n  vector<int> anc(n, -1);\n  vector<bool> ancR(n);\n  vector<int> toVisit;\n  vector<int> chInd;\n  vector<int> label;\n  vector<int> ancRct;\n  toVisit.push_back(0);\n  chInd.push_back(0);\n  ancRct.push_back(0);\n  while (toVisit.size() > 0) {\n    int ind = toVisit.back();\n    if (chInd.back() == 0) {\n      chInd[chInd.size() - 1]++;\n      if (l[ind] >= 0) {\n        toVisit.push_back(l[ind]);\n        chInd.push_back(0);\n        ancRct.push_back(max(0, ancRct.back() - 1));\n      }\n    } else if (chInd.back() == 1) {\n      if (toVisit.size() > ancDist) {\n        anc[ind] = toVisit[toVisit.size() - 1 - ancDist];\n      }\n      ancR[ind] = ancRct.back() == 0;\n      label.push_back(ind);\n      chInd[chInd.size() - 1]++;\n      if (r[ind] >= 0) {\n        toVisit.push_back(r[ind]);\n        chInd.push_back(0);\n        ancRct.push_back(ancDist);\n      }\n    } else {\n      toVisit.pop_back();\n      chInd.pop_back();\n      ancRct.pop_back();\n    }\n  }\n  char suf = \'a\' - 1;\n  vector<bool> dup(n);\n  vector<bool> duped(n);\n  for (int i = n - 1; i >= 0; --i) {\n    if (s[label[i]] < suf) {\n      dup[label[i]] = true;\n    }\n    if (i > 0 && s[label[i]] != s[label[i - 1]]) {\n      suf = s[label[i]];\n    }\n  }\n  for (int i = 0; i < n; ++i)\n    if (k > 0) {\n      if (dup[label[i]] && !duped[label[i]]) {\n        int ct = 1;\n        int ind = label[i];\n        bool pos = true;\n        while (pos && anc[ind] >= 0 && !duped[anc[ind]]) {\n          if (ct + ancDist <= k && ancR[ind]) {\n            ct += ancDist;\n            ind = anc[ind];\n          } else {\n            pos = false;\n          }\n        }\n        while (pos && p[ind] >= 0 && !duped[p[ind]]) {\n          if (ct + 1 <= k && l[p[ind]] == ind) {\n            ct += 1;\n            ind = p[ind];\n          } else {\n            pos = false;\n          }\n        }\n        if (pos) {\n          k -= ct;\n          ind = label[i];\n          do {\n            duped[ind] = true;\n            ind = p[ind];\n          } while (ind >= 0 && !duped[ind]);\n        }\n      }\n    }\n  for (int i = 0; i < n; ++i) {\n    cout << s[label[i]];\n    if (duped[label[i]]) {\n      cout << s[label[i]];\n    }\n  }\n  cout << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint n, k, ls[200005], rs[200005];\nint cnt, rk[200005];\nint f[200005][18];\nint vis[200005];\nchar a[200005];\nvoid dfs(int u) {\n  if (u == 0) return;\n  for (int i = 1; i < 18; i++) {\n    f[u][i] = f[f[u][i - 1]][i - 1];\n  }\n  dfs(ls[u]);\n  rk[++cnt] = u;\n  dfs(rs[u]);\n}\nbool get(int u) {\n  int t = k;\n  for (int i = 0; t; i++) {\n    if (t & 1) u = f[u][i];\n    t >>= 1;\n  }\n  return (u == 0 || vis[u] == 1);\n}\nvoid to(int u) {\n  if (u == 0) return;\n  if (vis[u] == 0) {\n    vis[u] = -1;\n    to(ls[u]);\n    to(rs[u]);\n  }\n}\nvoid print(int u) {\n  if (u == 0) return;\n  print(ls[u]);\n  printf("%c", a[u]);\n  if (vis[u] == 1) {\n    printf("%c", a[u]);\n  }\n  print(rs[u]);\n}\nint main() {\n  scanf("%d%d\\n%s", &n, &k, a + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", &ls[i], &rs[i]);\n    f[ls[i]][0] = f[rs[i]][0] = i;\n  }\n  f[0][0] = 0;\n  dfs(1);\n  int nxt = 1;\n  for (int i = 1; i < n; i++) {\n    int x = rk[i];\n    while (nxt < n && a[x] == a[rk[nxt]]) nxt++;\n    if (a[rk[i]] < a[rk[nxt]]) {\n      if (get(x)) {\n        while (vis[x] == 0) {\n          if (x == 0) break;\n          vis[x] = 1;\n          x = f[x][0];\n          k--;\n        }\n      }\n    } else\n      to(x);\n  }\n  print(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint32_t main() {\n  cin.tie(0)->sync_with_stdio(0);\n  long long n, k;\n  string s;\n  cin >> n >> k >> s;\n  vector<long long> l(n), r(n), val(n), d(n, 0), in;\n  for (long long i = 0; i < n; i++) {\n    cin >> l[i] >> r[i];\n    --l[i], --r[i];\n  }\n  function<void(long long)> dfs = [&](long long v) {\n    if (v == -1) return;\n    dfs(l[v]);\n    in.push_back(v);\n    dfs(r[v]);\n  };\n  dfs(0);\n  val[in.back()] = 0;\n  for (long long i = n - 2; i >= 0; i--) {\n    if (s[in[i]] == s[in[i + 1]])\n      val[in[i]] = val[in[i + 1]];\n    else if (s[in[i]] < s[in[i + 1]])\n      val[in[i]] = 1;\n    else\n      val[in[i]] = -1;\n  }\n  function<long long(long long, long long)> dfs2 = [&](long long v,\n                                                       long long t) {\n    if (v == -1 or t == 0) return 0ll;\n    long long x = dfs2(l[v], t - 1);\n    if (val[v] == 1 or x) x++;\n    if (x) d[v] = 1;\n    long long rem = t - x;\n    if (!d[v]) rem = 0;\n    x += dfs2(r[v], rem);\n    return x;\n  };\n  dfs2(0, k);\n  for (auto i : in) {\n    cout << s[i];\n    if (d[i]) cout << s[i];\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - \'0\', ch = getchar();\n  return f ? -x : x;\n}\ntemplate <class T>\nvoid print(T x) {\n  if (x < 0) putchar(\'-\'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + \'0\');\n}\ntemplate <class T>\nvoid print(T x, char let) {\n  print(x), putchar(let);\n}\ntemplate <class T1, class T2>\nvoid ckmin(T1& x, T2 y) {\n  if (x > y) x = y;\n}\ntemplate <class T1, class T2>\nvoid ckmax(T1& x, T2 y) {\n  if (x < y) x = y;\n}\nconst int N = 200005;\nconst int inf = 1e9;\nchar s[N];\nint ls[N], rs[N];\nint a[N], pat[N], p[N], ans[N], c;\nint n, k;\nvoid dfs(int u) {\n  if (!u) return;\n  dfs(ls[u]);\n  ++c, pat[c] = s[u], p[u] = c;\n  dfs(rs[u]);\n}\nvoid dfs0(int u) {\n  if (!u) return;\n  dfs0(ls[u]);\n  if (a[u])\n    printf("%c%c", s[u], s[u]);\n  else\n    printf("%c", s[u]);\n  dfs0(rs[u]);\n}\nint g(int u, int d) {\n  if (ls[u] && g(ls[u], d + 1)) a[u] = 1;\n  if (rs[u]) {\n    if (a[u] || (ans[p[u]] && k >= d)) {\n      if (!a[u]) a[u] = 1, k -= d;\n      if (g(rs[u], 1)) a[u] = 1;\n    } else {\n      if (g(rs[u], inf)) a[u] = 1;\n    }\n  } else {\n    if (a[u] || !(ans[p[u]] && k >= d))\n      ;\n    else\n      a[u] = 1, k -= d;\n  }\n  return a[u];\n}\nint main() {\n  scanf("%d%d%s", &n, &k, s + 1);\n  for (int i = (1); i <= (n); i++) ls[i] = read(), rs[i] = read();\n  dfs(1);\n  for (int i = (1); i <= (c); i++) pat[i] -= \'a\';\n  for (int i = (n - 1); i >= (0); i--)\n    ans[i] = pat[i] != pat[i + 1] ? (pat[i] < pat[i + 1]) : ans[i + 1];\n  g(1, 1);\n  dfs0(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize("O3")\nvector<int> inord;\nvoid liz(vector<int>& p, int ind, vector<bool>& isd) {\n  isd[ind] = 1;\n  if (p[ind] + 1 && !isd[p[ind]]) liz(p, p[ind], isd);\n}\nvoid inorder(vector<int>& l, vector<int>& r, vector<int>& gov, int ind, int g) {\n  if (l[ind] + 1) inorder(l, r, gov, l[ind], g + 1);\n  inord.push_back(ind);\n  gov[ind] = g;\n  if (r[ind] + 1) inorder(l, r, gov, r[ind], g + 1);\n}\nvoid solve(vector<int>& l, vector<int>& r, vector<int>& gov, vector<bool>& isd,\n           int ind, int& k, int gol, vector<int>& p, vector<bool>& iw) {\n  if (l[ind] + 1) solve(l, r, gov, isd, l[ind], k, gol, p, iw);\n  if (!isd[ind] && iw[ind] && gov[ind] - gol <= k) {\n    k -= gov[ind] - gol;\n    liz(p, ind, isd);\n  }\n  if (isd[ind]) gol = gov[ind];\n  if (isd[ind])\n    if (r[ind] + 1) solve(l, r, gov, isd, r[ind], k, gol, p, iw);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<int> l(n), r(n), p(n, -1), gov(n, 0);\n  for (int i = 0; n > i; ++i) {\n    cin >> l[i] >> r[i];\n    l[i]--;\n    r[i]--;\n    if (l[i] + 1) p[l[i]] = i;\n    if (r[i] + 1) p[r[i]] = i;\n  }\n  inorder(l, r, gov, 0, 0);\n  vector<bool> iw(n);\n  char lk = s[inord[n - 1]];\n  for (int i = n - 2; i >= 0; --i) {\n    iw[inord[i]] = s[inord[i]] < lk;\n    if (i > 0 && s[inord[i]] != s[inord[i - 1]]) lk = s[inord[i]];\n  }\n  vector<bool> isd(n);\n  solve(l, r, gov, isd, 0, k, -1, p, iw);\n  string s2;\n  for (int i = 0; n > i; ++i) {\n    s2.push_back(s[inord[i]]);\n    if (isd[inord[i]]) s2.push_back(s[inord[i]]);\n  }\n  cout << s2;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> ch[200005];\nint parent[20][200005], depth[200005];\nint isDuped[200005];\nstring second, s1 = "";\nint nextDifferent[200005];\nint n, k, c = 0;\nvoid nextChar(int u) {\n  if (ch[u].first != -1) {\n    nextChar(ch[u].first);\n  }\n  s1 += second[u];\n  if (ch[u].second != -1) {\n    nextChar(ch[u].second);\n  }\n}\nvoid dfs(int u, bool canDupe) {\n  if (ch[u].first != -1) {\n    depth[ch[u].first] = depth[u] + 1;\n    dfs(ch[u].first, canDupe);\n  }\n  if (isDuped[u] == -1 && canDupe) {\n    int target = 0;\n    if (s1[c] < s1[nextDifferent[c]]) target = 1;\n    int v = u;\n    for (int i = 19; i >= 0; i--) {\n      if (isDuped[parent[i][v]] == -1) {\n        v = parent[i][v];\n      }\n    }\n    if (depth[u] - depth[v] + 1 <= k && target == 1 &&\n        isDuped[parent[0][v]] != 0) {\n      v = u;\n      while (isDuped[v] == -1) {\n        isDuped[v] = 1;\n        k--;\n        v = parent[0][v];\n      }\n    }\n    if (target == 0) {\n      canDupe = 0;\n    }\n  }\n  c++;\n  if (ch[u].second != -1) {\n    depth[ch[u].second] = depth[u] + 1;\n    dfs(ch[u].second, canDupe);\n  }\n}\nvoid print(int u) {\n  if (ch[u].first != -1) {\n    print(ch[u].first);\n  }\n  cout << second[u];\n  if (isDuped[u] == 1) cout << second[u];\n  if (ch[u].second != -1) {\n    print(ch[u].second);\n  }\n}\nint main() {\n  cin >> n >> k >> second;\n  for (int i = 0; i < n; i++) {\n    isDuped[i] = -1;\n    int a, b;\n    cin >> a >> b;\n    if (a != 0) parent[0][a - 1] = i;\n    if (b != 0) parent[0][b - 1] = i;\n    ch[i] = {a - 1, b - 1};\n  }\n  for (int i = 1; i < 20; i++) {\n    for (int j = 0; j < n; j++) {\n      parent[i][j] = parent[i - 1][parent[i - 1][j]];\n    }\n  }\n  nextChar(0);\n  s1 += \'A\';\n  for (int i = n; i >= 0; i--) {\n    if (s1[i] != s1[i + 1])\n      nextDifferent[i] = i + 1;\n    else\n      nextDifferent[i] = nextDifferent[i + 1];\n  }\n  dfs(0, 1);\n  print(0);\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nchar s[MAXN];\nint ls[MAXN], rs[MAXN], anc[MAXN], firlef[MAXN];\nint dep[MAXN], dfn[MAXN], seq[MAXN], cur_dfn = 0;\nvoid dfs_tree(int u) {\n  firlef[ls[u]] = firlef[u];\n  firlef[rs[u]] = u;\n  for (int v : {ls[u], u, rs[u]})\n    if (v) {\n      if (v == u) {\n        dfn[u] = ++cur_dfn;\n        seq[cur_dfn] = u;\n        continue;\n      }\n      anc[v] = u;\n      dep[v] = dep[u] + 1;\n      dfs_tree(v);\n    }\n}\nint f[MAXN];\nint main(void) {\n  int n, d;\n  scanf("%d%d%s", &n, &d, s + 1);\n  for (int i = 1; i <= n; ++i) scanf("%d%d", &ls[i], &rs[i]);\n  dfs_tree(1);\n  for (int i = 1, j = 1; i <= n; i = j) {\n    while (j <= n && s[seq[i]] == s[seq[j]]) ++j;\n    f[seq[i]] = j > n || s[seq[j]] < s[seq[i]] ? 0 : 1;\n    for (int k = i + 1; k < j; ++k) f[seq[k]] = f[seq[i]];\n  }\n  int has = 0;\n  static int res[MAXN];\n  function<void(int)> set0 = [&](int u) {\n    if (u == 0 || res[u] != -1) return;\n    res[u] = 0;\n    if (ls[u]) set0(ls[u]);\n    if (rs[u]) set0(rs[u]);\n  };\n  function<void(int)> set1 = [&](int u) {\n    if (u == 0 || res[u] != -1) return;\n    res[u] = 1;\n    ++has;\n    if (anc[u]) set1(anc[u]);\n  };\n  memset(res, -1, sizeof(res));\n  for (int k = 1; k <= n; ++k) {\n    int u = seq[k];\n    if (res[u] != -1) continue;\n    if (f[u] == 0) {\n      set0(u);\n      continue;\n    }\n    int cnt = firlef[u] ? dep[u] - dep[firlef[u]] : dep[u] + 1;\n    if (has + cnt <= d)\n      set1(u);\n    else\n      set0(u);\n  }\n  for (int i = 1; i <= n; ++i) {\n    int u = seq[i];\n    putchar(s[u]);\n    if (res[u]) putchar(s[u]);\n  }\n  return 0;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 202020;\nint n, k, l[N], r[N];\nstring c;\nvector<int> a;\nbool good[N], vis[N];\nvoid dfs1(int u) {\n  if (u == 0) return;\n  dfs1(l[u]);\n  a.push_back(u);\n  dfs1(r[u]);\n}\nvoid dfs2(int u, int cost = 1) {\n  if (!u) return;\n  if (cost > k) return;\n  dfs2(l[u], cost + 1);\n  if (vis[l[u]])\n    vis[u] = 1;\n  else if (good[u]) {\n    vis[u] = 1;\n    k -= cost;\n  }\n  if (vis[u]) dfs2(r[u], 1);\n}\nint main() {\n  cin >> n >> k >> c;\n  c = ' ' + c;\n  for (int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  dfs1(1);\n  char ch = c[a.back()];\n  for (int i = n - 2; i >= 0; i--) {\n    int u = a[i], v = a[i + 1];\n    if (c[u] != c[v]) ch = c[v];\n    if (c[u] < ch) good[u] = true;\n  }\n  dfs2(1);\n  for (auto u : a) {\n    cout << c[u];\n    if (vis[u]) cout << c[u];\n  }\n}\n", '#include <bits/stdc++.h>\nint n, K, L[200010], R[200010], P[200010][20];\nchar s[200010];\nchar ans[200010], nxt[200010];\nint clk1, cnt[200010], who[200010], idx[200010];\nint clk2, bgn[200010], fin[200010];\nbool tree[800010];\nvoid dfs(int sn, int fa) {\n  P[sn][0] = fa;\n  for (int i = 1; i < 20; i++) P[sn][i] = P[P[sn][i - 1]][i - 1];\n  bgn[sn] = ++clk2;\n  if (L[sn]) dfs(L[sn], sn);\n  who[++clk1] = sn;\n  idx[sn] = clk1;\n  ans[clk1] = s[sn];\n  cnt[clk1] = 1;\n  if (R[sn]) dfs(R[sn], sn);\n  fin[sn] = clk2;\n}\nvoid modify(int id, int l, int r, int ql, int qr) {\n  if (ql <= l && r <= qr)\n    tree[id] = true;\n  else {\n    int nxt = id << 1, mid = (l + r) >> 1;\n    if (ql <= mid) modify(nxt, l, mid, ql, qr);\n    if (qr > mid) modify(nxt | 1, mid + 1, r, ql, qr);\n  }\n}\nbool query(int id, int l, int r, int qv) {\n  if (l == r)\n    return tree[id];\n  else if (tree[id])\n    return tree[id];\n  else {\n    int nxt = id << 1, mid = (l + r) >> 1;\n    return qv <= mid ? query(nxt, l, mid, qv) : query(nxt | 1, mid + 1, r, qv);\n  }\n}\nint main() {\n  scanf("%d%d%s", &n, &K, s + 1);\n  for (int i = 1; i <= n; i++) scanf("%d%d", &L[i], &R[i]);\n  dfs(1, 0);\n  for (int i = n; i; i--)\n    nxt[i] = ans[i] == ans[i + 1] ? nxt[i + 1] : ans[i + 1];\n  for (int i = 1; i <= n; i++) {\n    if (cnt[i] == 2) continue;\n    if (ans[i] > nxt[i])\n      modify(1, 1, n, bgn[who[i]], fin[who[i]]);\n    else if (!query(1, 1, n, bgn[who[i]])) {\n      int sm = 0;\n      for (int j = who[i], k = 19; k >= 0; k--)\n        if (P[j][k] && cnt[idx[P[j][k]]] != 2) sm |= 1 << k, j = P[j][k];\n      if (sm + 1 > K) continue;\n      for (int j = i; j && cnt[j] != 2; j = idx[P[who[j]][0]]) cnt[j] = 2, K--;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= cnt[i]; j++) printf("%c", ans[i]);\n  printf("\\n");\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nusing cd = complex<double>;\nmt19937 rnd(chrono::system_clock::now().time_since_epoch().count());\nconst long long N = 2e5 + 5;\nstring a, s;\nset<long long> g;\nlong long c[N], n, k, num[N], tot, L[N], R[N], ok[N];\nvoid dfs(long long u) {\n  if (L[u]) dfs(L[u]);\n  num[++tot] = u;\n  a += s[u];\n  if (R[u]) dfs(R[u]);\n}\nvoid solve(long long u, long long dp) {\n  if (!u || dp > k) return;\n  solve(L[u], dp + 1);\n  if (ok[L[u]])\n    ok[u] = 1;\n  else if (c[u])\n    ok[u] = 1, k -= dp;\n  if (ok[u]) solve(R[u], 1);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> s;\n  s = " " + s;\n  for (long long i = 1; i <= n; i++) {\n    cin >> L[i] >> R[i];\n  }\n  dfs(1);\n  a = " " + a;\n  for (long long i = 1; i <= n; i++) {\n    long long x = i;\n    while (x <= n && a[i] == a[x]) x++;\n    if (x > n) break;\n    if (a[x] > a[i]) {\n      for (long long j = i; j < x; j++) c[num[j]] = 1;\n    }\n    i = x - 1;\n  }\n  solve(1, 1);\n  for (long long i = 1; i <= n; i++) {\n    if (ok[num[i]]) cout << a[i];\n    cout << a[i];\n  }\n  cout << endl;\n}\n', '#include <bits/stdc++.h>\n#pragma GCC optimize("O3")\n#pragma GCC optimize("Ofast")\n#pragma GCC optimization("unroll-loops")\n#pragma GCC target("avx,avx2,fma")\nusing namespace std;\nconst long long mod = 998244353;\nint n, k, cnt;\nvector<pair<int, int>> ch;\nvector<int> f, good, add;\nstring s;\ninline void dfs1(const int &u) {\n  if (ch[u].first != -1) dfs1(ch[u].first);\n  f[cnt++] = u;\n  if (ch[u].second != -1) dfs1(ch[u].second);\n}\nint dfs(int u, int k) {\n  int ret = 0;\n  bool added = 0;\n  if (ch[u].first != -1) {\n    int l = dfs(ch[u].first, k - 1);\n    ret += l;\n    if (l) added = 1;\n  }\n  if (k > 0 && good[u]) added = 1;\n  if (added) ret++, add[u] = 1;\n  if (ch[u].second != -1) {\n    int r;\n    if (added)\n      r = dfs(ch[u].second, k - ret);\n    else\n      r = dfs(ch[u].second, 0);\n    ret += r;\n  }\n  return ret;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, k;\n  cin >> n >> k;\n  ch.resize(n);\n  f.resize(n);\n  good.resize(n);\n  add.resize(n);\n  cin >> s;\n  for (int i = 0; i < n; i++) {\n    cin >> ch[i].first >> ch[i].second;\n    ch[i].first--;\n    ch[i].second--;\n  }\n  dfs1(0);\n  for (int i = n - 2; i >= 0; i--) {\n    if (s[f[i]] == s[f[i + 1]])\n      good[f[i]] = good[f[i + 1]];\n    else if (s[f[i]] < s[f[i + 1]])\n      good[f[i]] = 1;\n    else\n      good[f[i]] = 0;\n  }\n  dfs(0, k);\n  string ans;\n  for (int i = 0; i < n; i++) {\n    ans += s[f[i]];\n    if (add[f[i]]) ans += s[f[i]];\n  }\n  cout << ans;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 10;\nint N, K, L[MAXN], R[MAXN];\nbool ans[MAXN], ok[MAXN];\nchar C[MAXN];\nint P[MAXN], id[MAXN], tp;\nstring str;\nvoid init(int u) {\n  if (L[u]) init(L[u]);\n  id[P[tp] = u] = tp, tp++;\n  if (R[u]) init(R[u]);\n}\nbool dfs(int u, int dep) {\n  if (dep > K) return false;\n  bool ret = false;\n  if (ok[id[u]]) ret = true;\n  bool tmp = false;\n  if (L[u])\n    tmp = dfs(L[u], dep + 1);\n  else\n    tmp = false;\n  if (tmp == false && ret) K -= dep;\n  ret |= tmp;\n  if (ret && R[u]) dfs(R[u], 1);\n  ans[u] = ret;\n  return ret;\n}\nvoid get(int u) {\n  if (!u) return;\n  get(L[u]);\n  str += C[u];\n  if (ans[u]) str += C[u];\n  get(R[u]);\n}\nint main() {\n  scanf("%d %d %s", &N, &K, C + 1);\n  for (int i = (1), iend = (N + 1); i < iend; ++i) {\n    scanf("%d %d", &L[i], &R[i]);\n  }\n  init(1);\n  for (int i = (N)-1, iend = (0); i >= iend; --i) {\n    if (C[P[i]] < C[P[i + 1]])\n      ok[i] = true;\n    else if (C[P[i]] == C[P[i + 1]])\n      ok[i] = ok[i + 1];\n  }\n  dfs(1, 1);\n  get(1);\n  cout << str << \'\\n\';\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nchar nxt[200005];\nstring s;\nvector<pair<int, char>> v;\nint l[200005], r[200005];\nint n, k;\nstring ans = "";\nvoid dfs(int x) {\n  if (l[x]) dfs(l[x]);\n  v.push_back({x, s[x]});\n  if (r[x]) dfs(r[x]);\n}\nbool dfs2(int x, int c, int val) {\n  bool ok = 0;\n  if (l[x]) ok = dfs2(l[x], c + 1, val);\n  if (ok) {\n    ans += s[x];\n    ans += s[x];\n  } else {\n    if (s[x] < nxt[x]) {\n      if (c + 1 <= k && val) {\n        ok = 1;\n        ans += s[x];\n        ans += s[x];\n        k -= c + 1;\n      }\n    }\n  }\n  if (!ok) ans += s[x];\n  if (r[x]) {\n    if (ok) {\n      dfs2(r[x], 0, val);\n    } else\n      ok = dfs2(r[x], c + 1, 0);\n  }\n  return ok;\n}\nvoid solve() {\n  cin >> n >> k;\n  cin >> s;\n  s = "." + s;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs(1);\n  v.push_back({n + 1, \'a\' - 1});\n  for (int i = n; i >= 1; i--) {\n    if (v[i - 1].second != v[i].second) {\n      nxt[v[i - 1].first] = v[i].second;\n    } else\n      nxt[v[i - 1].first] = nxt[v[i].first];\n  }\n  dfs2(1, 0, 1);\n  cout << ans << endl;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch > \'9\' || ch < \'0\') {\n    if (ch == \'-\') f = -1;\n    ch = getchar();\n  }\n  while (ch >= \'0\' && ch <= \'9\') {\n    x = x * 10 + ch - \'0\';\n    ch = getchar();\n  }\n  return x * f;\n}\nint t, n, k;\nint ls[200005], rs[200005];\nchar s[200005];\nvector<int> q;\nvoid dfs(int x) {\n  if (ls[x]) dfs(ls[x]);\n  q.push_back(x);\n  if (rs[x]) dfs(rs[x]);\n}\nint nxt[200005];\nbool ok[200005], db[200005];\nbool dfsls(int x, int k) {\n  if (!k) return 0;\n  if (ok[x]) return 1;\n  if (ls[x]) return dfsls(ls[x], k - 1);\n  return 0;\n}\nvoid dfs2(int x, bool r, string &ans) {\n  if (r) ok[x] |= dfsls(x, k);\n  ok[x] &= r;\n  if (ok[x] && k) k--, db[x] = 1;\n  if (ls[x]) {\n    dfs2(ls[x], db[x], ans);\n  }\n  ans += s[x];\n  if (db[x]) ans += s[x];\n  if (rs[x]) dfs2(rs[x], db[x], ans);\n  return;\n}\nint main() {\n  n = read(), k = read();\n  scanf("%s", s + 1);\n  for (int i = 1; i <= n; i++) ls[i] = read(), rs[i] = read();\n  dfs(1);\n  q.push_back(0);\n  for (int i = q.size() - 2; i >= 0; i--) {\n    if (s[q[i]] == s[q[i + 1]])\n      nxt[i] = nxt[i + 1];\n    else\n      nxt[i] = i + 1;\n  }\n  for (int i = 0; i < q.size() - 1; i++) {\n    if (s[q[nxt[i]]] > s[q[i]]) ok[q[i]] = 1;\n  }\n  string ans = "";\n  dfs2(1, 1, ans);\n  cout << ans;\n  return 0;\n}\n', '// package c1623;\n\nimport java.io.File;\nimport java.lang.invoke.MethodHandles;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n//\n// Codeforces Round #763 (Div. 2) 2021-12-28 05:35\n// E. Middle Duplication\n// https://codeforces.com/contest/1623/problem/E\n// time limit per test 1 second; memory limit per test 256 megabytes\n// public class Pseudo for \'Source should satisfy regex [^{}]*public\\s+(final)?\\s*class\\s+(\\w+).*\'\n//\n// A binary tree of n nodes is given. Nodes of the tree are numbered from 1 to n and the root is the\n// node 1. Each node can have no child, only one left child, only one right child, or both children.\n// For convenience, let\'s denote l_u and r_u as the left and the right child of the node u\n// respectively, l_u = 0 if u does not have the left child, and r_u = 0 if the node u does not have\n// the right child.\n//\n// Each node has a string label, initially is a single character c_u. Let\'s define the string\n// representation of the binary tree as the concatenation of the labels of the nodes in the .\n// Formally, let f(u) be the string representation of the tree rooted at the node u. f(u) is defined\n// as follows: <div class="MathJax_Display" style="text-align: center;"></div> f(u) = \\begin{cases}\n// \\texttt{<empty string>}, & \\text{if }u = 0; \\\\ f(l_u) + c_u + f(r_u) & \\text{otherwise},\n// \\end{cases} where + denotes the string concatenation operation.\n//\n// This way, the string representation of the tree is f(1).\n//\n// For each node, we can its label , that is, assign c_u with c_u + c_u, but only if u is the root\n// of the tree, or if its parent also has its label duplicated.\n//\n// You are given the tree and an integer k. What is the lexicographically smallest string\n// representation of the tree, if we can duplicate labels of at most k nodes?\n//\n// A string a is lexicographically smaller than a string b if and only if one of the following\n// holds:\n//  * a is a prefix of b, but a \\ne b;\n//  * in the first position where a and b differ, the string a has a letter that appears earlier in\n//    the alphabet than the corresponding letter in b. </div><div class="input-specification"><div\n// class="section-title">Input</div>\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Input\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Output\n//\n// Print a single line, containing the lexicographically smallest string representation of the tree\n// if at most k nodes have their labels duplicated.\n//\n// Example\n/*\ninput:\n4 3\nabab\n2 3\n0 0\n0 4\n0 0\n\noutput:\nbaaaab\n\ninput:\n8 2\nkadracyn\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndaarkkcyan\n\ninput:\n8 3\nkdaracyn\n2 5\n0 3\n0 4\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndarkcyan\n*/\n// Note\n//\n// The images below present the tree for the examples. The number in each node is the node number,\n// while the subscripted letter is its label. To the right is the string representation of the tree,\n// with each letter having the same color as the corresponding node.\n//\n// Here is the tree for the first example. Here we duplicated the labels of nodes 1 and 3. We should\n// not duplicate the label of node 2 because it would give us the string "", which is\n// lexicographically greater than "".\n// https://espresso.codeforces.com/30116fa124ec3edbd4c16ac29fa8eb45c19cc171.png\n//\n// In the second example, we can duplicate the labels of nodes 1 and 2. Note that only duplicating\n// the label of the root will produce a worse result than the initial string.\n// https://espresso.codeforces.com/e66a56b1c8dee019f4f4c138ee0333caf44b312c.png\n//\n// In the third example, we should not duplicate any character at all. Even though we would want to\n// duplicate the label of the node 3, by duplicating it we must also duplicate the label of the node\n// 2, which produces a worse result.\n// https://espresso.codeforces.com/19b0d4c5514801c166e9b3f0ef4c110939711a20.png\n//\n// There is no way to produce string "" from a tree with the initial string representation "" :(.\n//\npublic class C1623E {\n  static final int MOD = (int)1e9+7;\n  static final Random RAND = new Random();\n\n  static String solve(String s, int k, int[][] lr) {\n    // Note that both s and lr have length n + 1\n    int n = s.length() - 1;\n\n    // [parent, depth, subtree size, dfs-done, duplicate, in-order index]\n    //  0       1      2             3         4          5\n    int[][] nodes = dfsNodes(lr);\n\n    bfsInOrder(lr, nodes);\n\n    int[] ids = new int[n];\n    for (int i = 1; i <= n; i++) {\n      ids[nodes[i][5]] = i;\n    }\n\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    // System.out.format("%s\\n", Utils.trace(ids));\n\n    // Note that ids[] is 0-indexed!\n    int b = 0;\n    int avail = k;\n    while (b < n) {\n      int v = ids[b];\n      // System.out.format("  b:%d v:%d depth:%d k:%d\\n", b, v, nodes[v][1], k);\n      if (nodes[v][1] > k) {\n        // don\'t bother if v is too deep\n        b++;\n        continue;\n      }\n      char c = s.charAt(v);\n      int e = b + 1;\n      while (e < n && s.charAt(ids[e]) == c) {\n        e++;\n      }\n      boolean duplicate = e < n && s.charAt(ids[e]) > c;\n      // System.out.format("  b:%d v:%d e:%d dup:%b\\n", b, v, e, duplicate);\n      if (!duplicate) {\n        b = e;\n        continue;\n      }\n\n      // We may duplicate some nodes between [b,e) as long as there is budget\n      for (int i = b; i < e; i++) {\n        int id = ids[i];\n        if (nodes[id][4] == 1) {\n          // skip ones already decided to duplicate earlier (part chain).\n          continue;\n        }\n\n        // Can we afford duplicate i?\n        // walk up parent chain until a duplicated node or root\n        int needed = 0;\n        // w is the node id\n        int w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          needed++;\n          int p = nodes[w][0];\n          if (p != 0 && nodes[p][4] == 0 && nodes[p][5] < nodes[w][5]) {\n            // do not trigger duplicate of an ancestor in front as it will make things worse\n            needed = Integer.MAX_VALUE;\n            break;\n          }\n          // if (p != 0 && nodes[p][4])\n          w = nodes[w][0];\n        }\n        // System.out.format("    i:%d id:%d needed:%d avail:%d\\n", i, id, needed, avail);\n        if (needed > avail) {\n          continue;\n        }\n\n        // Set duplicate flag up the chain until an ancestor already set or the parent of root.\n        w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          nodes[w][4] = 1;\n          avail--;\n          w = nodes[w][0];\n        }\n        myAssert(avail >= 0);\n      }\n      b = e;\n    }\n    // System.out.format("%s\\n", Utils.trace(ids));\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    StringBuilder sb = new StringBuilder();\n    for (int v : ids) {\n      sb.append(s.charAt(v));\n      if (nodes[v][4] == 1) {\n        sb.append(s.charAt(v));\n      }\n    }\n    return sb.toString();\n  }\n\n  // [parent, depth, subtree size, done]\n  static int[][] dfsNodes(int[][] lr) {\n    int n = lr.length - 1;\n    int[][] nodes = new int[n + 1][6];\n    Stack<Integer> stack = new Stack<>();\n    stack.push(1);\n    nodes[1][1] = 1;\n    while (!stack.isEmpty()) {\n      int v = stack.peek();\n      // System.out.format("  v:%d %s\\n", v, Arrays.toString(nodes[v]));\n      int l = lr[v][0];\n      int r = lr[v][1];\n      if (l == 0 && r == 0) {\n        nodes[v][2] = 1;\n        nodes[v][3] = 1;\n        stack.pop();\n      } else if (l > 0 && r == 0) {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        } else {\n          nodes[v][2] = 1 + nodes[l][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else if (l == 0 && r > 0) {\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        } else {\n          nodes[v][2] = 1 + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        }\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        }\n        if (nodes[l][3] == 1 && nodes[r][3] == 1) {\n          nodes[v][2] = 1 + nodes[l][2] + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      }\n    }\n    return nodes;\n  }\n\n  // Fill nodes[i][5] which is the 0-based index of in-order traverse of the node.\n  // Note that both lr and nodes are 1-based\n  static void bfsInOrder(int[][] lr, int[][] nodes) {\n    int n = lr.length - 1;\n    Queue<int[]> q = new LinkedList<>();\n    q.add(new int[] {1, 0});\n    while (!q.isEmpty()) {\n      int[] e = q.poll();\n      int v = e[0];\n      int offset = e[1];\n      int l = lr[v][0];\n      int r = lr[v][1];\n      int idx = offset;\n      if (l > 0) {\n        q.add(new int[] {l, idx});\n        idx += nodes[l][2];\n      }\n      nodes[v][5] = idx++;\n      if (r > 0) {\n        q.add(new int[] {r, idx});\n      }\n    }\n  }\n\n  static String trace(int[] a) {\n    StringBuilder sb = new StringBuilder();\n    for (int v : a) {\n     if (sb.length() > 0) {\n       sb.append(\' \');\n     }\n      sb.append(v);\n    }\n    return sb.toString();\n  }\n\n  static void myAssert(boolean cond) {\n    if (!cond) {\n      throw new RuntimeException("Unexpected");\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner in = getInputScanner();\n    int n = in.nextInt();\n    int k = in.nextInt();\n    String s = \' \' + in.next();\n    int[][] lr = new int[n + 1][2];\n    for (int i = 1; i <= n; i++) {\n      lr[i][0] = in.nextInt();\n      lr[i][1] = in.nextInt();\n    }\n    String ans = solve(s, k, lr);\n    System.out.println(ans);\n    in.close();\n  }\n\n  static Scanner getInputScanner() {\n    try {\n      final String USERDIR = System.getProperty("user.dir");\n      final String CNAME = MethodHandles.lookup().lookupClass().getSimpleName();\n      final File fin = new File(USERDIR + "/io/c" + CNAME.substring(1,5) + "/" + CNAME + ".in");\n      return fin.exists() ? new Scanner(fin) : new Scanner(System.in);\n    } catch (Exception e) {\n      return new Scanner(System.in);\n    }\n  }\n}\n', 'import java.io.*;\nimport java.util.*;\n\npublic class Rana{\n    public static int rem;\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int k = Integer.parseInt(tokenizer.nextToken());\n        String lab = in.readLine();\n        node[] list = new node[n];\n        for (int i = 0; i < n; i++) {\n            list[i] = new node(i, lab.substring(i, i + 1));\n        }\n        for (int i = 0; i < n; i++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            int left = Integer.parseInt(tokenizer.nextToken()) - 1;\n            int right = Integer.parseInt(tokenizer.nextToken()) - 1;\n            if (left != -1) {\n                list[i].left = list[left];\n                list[left].parent = list[i];\n            }\n            if (right != -1) {\n                list[i].right = list[right];\n                list[right].parent = list[i];\n            }\n            \n        }\n        node[] order = new node[n];\n        inorder(order, 0, list[0]);\n        for (int i = 0; i < n; i++) {\n            order[i].inorder = i;\n        }\n        rem = k;\n        ArrayList<String> vals = new ArrayList<>();\n        for (int i = order.length - 1; i >= 0; i--) {\n            if (vals.size() == 0 || !order[i].label.equals(vals.get(vals.size() - 1))) {\n                vals.add(order[i].label);\n            }\n            if (vals.size() <= 1 || vals.get(vals.size() - 1).compareTo(vals.get(vals.size() - 2)) >= 0) {\n                order[i].good = false;\n            } else {\n                order[i].good = true;\n            }\n        }\n        \n        dfs(list[0], 1);\n       \n        StringBuilder b = new StringBuilder();\n        for (int i = 0; i < order.length; i++) {\n            b.append(order[i].label);\n            if (order[i].used) {\n                b.append(order[i].label);\n            }\n        }\n        System.out.println(b);\n        in.close();\n        out.close();\n    }\n\n    public static void dfs(node n, node c) {\n        if (n == null) {\n            return;\n        }\n        if (c != null) {\n            n.constraint = c;\n        }\n        dfs(n.left, c);\n        if (!n.good) {\n            c = n;\n        }\n        dfs(n.right, c);\n    }\n\n    public static void dfs(node n, int cost) {\n        if (n == null || n.used)\n            return;\n        dfs(n.left, cost + 1);\n        if (cost <= rem && n.good && !n.used) {\n            rem -= cost;\n            update(n);\n        }\n        if (n.used) {\n            dfs(n.right, 1);\n        }\n    }\n\n    public static void update(node n) {\n        // dfs(n, 0);\n        n.cost = 0;\n        n.used = true;\n        if (n.parent != null && !n.parent.used) {\n            update(n.parent);\n        }\n    }\n\n    public static int inorder(node[] order, int index, node n) {\n        if (n != null) {\n            index = inorder(order, index, n.left);\n            order[index++] = n;\n            index = inorder(order, index, n.right);\n        }\n        return index;\n    }\n\n    public static class node {\n        int id;\n        String label;\n        node left = null;\n        node right = null;\n        node parent = null;\n        node constraint = null;\n        int cost = 0;\n        boolean used = false;\n        boolean good = false;\n        int inorder = 0;\n\n        public node(int id, String label) {\n            this.id = id;\n            this.label = label;\n        }\n\n        public int cost() {\n            int val = 0;\n            node pointer = this;\n            while (pointer != null && !pointer.used) {\n                pointer = pointer.parent;\n                val++;\n            }\n            return cost = val;\n        }\n    }\n}', '//package round763;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class E {\n\tInputStream is;\n\tFastWriter out;\n\tString INPUT = "";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), K = ni();\n\t\tchar[] s = ns(n);\n\t\tint[][] lr = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tlr[i] = na(2);\n\t\t}\n\t\tt = new int[n];\n\t\trights = new int[n];\n\t\tp = 0;\n\t\tdfs(0, lr, 0);\n\t\tassert p == n;\n\t\tboolean[] good = new boolean[n];\n\t\tint h = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\twhile(h <= i || h < n && s[t[i]] == s[t[h]])h++;\n\t\t\tif(h < n && s[t[i]] < s[t[h]]){\n\t\t\t\tgood[i] = true;\n\t\t\t}\n\t\t}\n\t\tint[] ord = new int[n];\n\n\t\tint q = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(good[i]){\n\t\t\t\tord[q++] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tif(!good[i]){\n\t\t\t\tord[q++] = i;\n\t\t\t}\n\t\t}\n\n\t\tint[] par = new int[n];\n\t\tpar[0] = -1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(lr[i][0] != 0)par[lr[i][0]-1] = i;\n\t\t\tif(lr[i][1] != 0)par[lr[i][1]-1] = i;\n\t\t}\n\t\tint[][] spar = logstepParents(par);\n\n//\t\ttr(ord);\n//\t\ttr(good);\n//\t\ttr(par);\n//\t\ttr(t);\n\n\t\tboolean[] painted = new boolean[n];\n\t\tfor(int v : ord){\n\t\t\tif(!good[v])continue;\n\t\t\tv = t[v];\n\t\t\tif(painted[v])continue;\n\t\t\tint bo = v; // bo is not painted\n\t\t\tint he = 1;\n\t\t\tfor(int d = spar.length-1;d >= 0;d--){\n\t\t\t\tint sp = spar[d][bo];\n\t\t\t\tif(sp == -1 || painted[sp])continue;\n\t\t\t\tbo = sp;\n\t\t\t\the += 1<<d;\n\t\t\t}\n\t\t\tif(rights[bo] != rights[v])continue;\n\t\t\tif(he <= K){\n\t\t\t\tfor(int x = v;x != -1 && !painted[x];x = par[x]){\n\t\t\t\t\tpainted[x] = true;\n\t\t\t\t\tK--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tout.print(s[t[i]]);\n\t\t\tif(painted[t[i]]){\n\t\t\t\tout.print(s[t[i]]);\n\t\t\t}\n\t\t}\n\t\tout.println();\n\n\t}\n\n\tpublic static int[][] logstepParents(int[] par)\n\t{\n\t\tint n = par.length;\n\t\tint m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n-1))+1;\n\t\tint[][] pars = new int[m][n];\n\t\tpars[0] = par;\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tpars[j][i] = pars[j-1][i] == -1 ? -1 : pars[j-1][pars[j-1][i]];\n\t\t\t}\n\t\t}\n\t\treturn pars;\n\t}\n\n\n\tvoid dfs(int cur, int[][] lr, int nr)\n\t{\n\t\tif(cur == -1)return;\n\t\tdfs(lr[cur][0]-1, lr, nr);\n\t\trights[cur] = nr;\n\t\tt[p++] = cur;\n\t\tdfs(lr[cur][1]-1, lr, nr+1);\n\t}\n\n\tint[] t;\n\tint p = 0;\n\tint[] rights;\n\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new FastWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+"ms");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new E().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != \' \')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= \'0\' && b <= \'9\') || b == \'-\'));\n\t\tif(b == \'-\'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= \'0\' && b <= \'9\'){\n\t\t\t\tnum = num * 10 + (b - \'0\');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic static class FastWriter\n\t{\n\t\tprivate static final int BUF_SIZE = 1<<13;\n\t\tprivate final byte[] buf = new byte[BUF_SIZE];\n\t\tprivate final OutputStream out;\n\t\tprivate int ptr = 0;\n\n\t\tprivate FastWriter(){out = null;}\n\n\t\tpublic FastWriter(OutputStream os)\n\t\t{\n\t\t\tthis.out = os;\n\t\t}\n\n\t\tpublic FastWriter(String path)\n\t\t{\n\t\t\ttry {\n\t\t\t\tthis.out = new FileOutputStream(path);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new RuntimeException("FastWriter");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter write(byte b)\n\t\t{\n\t\t\tbuf[ptr++] = b;\n\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(char c)\n\t\t{\n\t\t\treturn write((byte)c);\n\t\t}\n\n\t\tpublic FastWriter write(char[] s)\n\t\t{\n\t\t\tfor(char c : s){\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(String s)\n\t\t{\n\t\t\ts.chars().forEach(c -> {\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(int l) {\n\t\t\tif (l >= 1000000000) return 10;\n\t\t\tif (l >= 100000000) return 9;\n\t\t\tif (l >= 10000000) return 8;\n\t\t\tif (l >= 1000000) return 7;\n\t\t\tif (l >= 100000) return 6;\n\t\t\tif (l >= 10000) return 5;\n\t\t\tif (l >= 1000) return 4;\n\t\t\tif (l >= 100) return 3;\n\t\t\tif (l >= 10) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(int x)\n\t\t{\n\t\t\tif(x == Integer.MIN_VALUE){\n\t\t\t\treturn write((long)x);\n\t\t\t}\n\t\t\tif(ptr + 12 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)\'-\');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)(\'0\'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(long l) {\n\t\t\tif (l >= 1000000000000000000L) return 19;\n\t\t\tif (l >= 100000000000000000L) return 18;\n\t\t\tif (l >= 10000000000000000L) return 17;\n\t\t\tif (l >= 1000000000000000L) return 16;\n\t\t\tif (l >= 100000000000000L) return 15;\n\t\t\tif (l >= 10000000000000L) return 14;\n\t\t\tif (l >= 1000000000000L) return 13;\n\t\t\tif (l >= 100000000000L) return 12;\n\t\t\tif (l >= 10000000000L) return 11;\n\t\t\tif (l >= 1000000000L) return 10;\n\t\t\tif (l >= 100000000L) return 9;\n\t\t\tif (l >= 10000000L) return 8;\n\t\t\tif (l >= 1000000L) return 7;\n\t\t\tif (l >= 100000L) return 6;\n\t\t\tif (l >= 10000L) return 5;\n\t\t\tif (l >= 1000L) return 4;\n\t\t\tif (l >= 100L) return 3;\n\t\t\tif (l >= 10L) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(long x)\n\t\t{\n\t\t\tif(x == Long.MIN_VALUE){\n\t\t\t\treturn write("" + x);\n\t\t\t}\n\t\t\tif(ptr + 21 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)\'-\');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)(\'0\'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(double x, int precision)\n\t\t{\n\t\t\tif(x < 0){\n\t\t\t\twrite(\'-\');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tx += Math.pow(10, -precision)/2;\n\t\t\t//\t\tif(x < 0){ x = 0; }\n\t\t\twrite((long)x).write(".");\n\t\t\tx -= (long)x;\n\t\t\tfor(int i = 0;i < precision;i++){\n\t\t\t\tx *= 10;\n\t\t\t\twrite((char)(\'0\'+(int)x));\n\t\t\t\tx -= (int)x;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(char c){\n\t\t\treturn write(c).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(int x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(double x, int precision){\n\t\t\treturn write(x, precision).writeln();\n\t\t}\n\n\t\tpublic FastWriter write(int... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(int x : xs) {\n\t\t\t\tif (!first) write(\' \');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(long... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(long x : xs) {\n\t\t\t\tif (!first) write(\' \');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln()\n\t\t{\n\t\t\treturn write((byte)\'\\n\');\n\t\t}\n\n\t\tpublic FastWriter writeln(int... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[] line)\n\t\t{\n\t\t\treturn write(line).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[]... map)\n\t\t{\n\t\t\tfor(char[] line : map)write(line).writeln();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(String s)\n\t\t{\n\t\t\treturn write(s).writeln();\n\t\t}\n\n\t\tprivate void innerflush()\n\t\t{\n\t\t\ttry {\n\t\t\t\tout.write(buf, 0, ptr);\n\t\t\t\tptr = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException("innerflush");\n\t\t\t}\n\t\t}\n\n\t\tpublic void flush()\n\t\t{\n\t\t\tinnerflush();\n\t\t\ttry {\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException("flush");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter print(byte b) { return write(b); }\n\t\tpublic FastWriter print(char c) { return write(c); }\n\t\tpublic FastWriter print(char[] s) { return write(s); }\n\t\tpublic FastWriter print(String s) { return write(s); }\n\t\tpublic FastWriter print(int x) { return write(x); }\n\t\tpublic FastWriter print(long x) { return write(x); }\n\t\tpublic FastWriter print(double x, int precision) { return write(x, precision); }\n\t\tpublic FastWriter println(char c){ return writeln(c); }\n\t\tpublic FastWriter println(int x){ return writeln(x); }\n\t\tpublic FastWriter println(long x){ return writeln(x); }\n\t\tpublic FastWriter println(double x, int precision){ return writeln(x, precision); }\n\t\tpublic FastWriter print(int... xs) { return write(xs); }\n\t\tpublic FastWriter print(long... xs) { return write(xs); }\n\t\tpublic FastWriter println(int... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(long... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(char[] line) { return writeln(line); }\n\t\tpublic FastWriter println(char[]... map) { return writeln(map); }\n\t\tpublic FastWriter println(String s) { return writeln(s); }\n\t\tpublic FastWriter println() { return writeln(); }\n\t}\n\n\tpublic void trnz(int... o)\n\t{\n\t\tfor(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+":"+o[i]+" ");\n\t\tSystem.out.println();\n\t}\n\n\t// print ids which are 1\n\tpublic void trt(long... o)\n\t{\n\t\tQueue<Integer> stands = new ArrayDeque<>();\n\t\tfor(int i = 0;i < o.length;i++){\n\t\t\tfor(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n\t\t}\n\t\tSystem.out.println(stands);\n\t}\n\n\tpublic void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?\'#\':\'.\');\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?\'#\':\'.\');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(long[]... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long[] r : b) {\n\t\t\t\tfor (long x : r) {\n\t\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\t\tSystem.out.print(x << ~i < 0 ? \'#\' : \'.\');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic void tf(long... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long x : b) {\n\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\tSystem.out.print(x << ~i < 0 ? \'#\' : \'.\');\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty("ONLINE_JUDGE") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n', 'import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1623e {\n\n    public static void main(String[] args) throws IOException {\n        int n = rni(), k = ni(), l[] = new int[n], r[] = new int[n], order[] = new int[n], next[] = new int[n], last[] = new int[n];\n        fill(next, -1);\n        char[] c = rcha();\n        boolean good[] = new boolean[n], chosen[] = new boolean[n];\n        for (int i = 0; i < n; ++i) {\n            l[i] = rni() - 1;\n            r[i] = ni() - 1;\n        }\n        dfs(l, r, 0, order, next, last);\n        while (last[lastv] != -1) {\n            if (c[lastv] > c[last[lastv]] || good[lastv] && c[lastv] == c[last[lastv]]) {\n                good[last[lastv]] = true;\n            }\n            lastv = last[lastv];\n        }\n        dep = new int[n];\n        anc = new int[n][20];\n        minbad = new int[n][20];\n        for (int[] row : anc) {\n            fill(row, -1);\n        }\n        for (int[] row : minbad) {\n            fill(row, n);\n        }\n        binary_lifting_dfs(l, r, 0, good, order);\n        int invord[] = new int[n];\n        for (int i = 0; i < n; ++i) {\n            invord[order[i]] = i;\n        }\n//        prln(order);\n        for (int x = 0; x < n; ++x) {\n            int i = invord[x];\n            if (good[i] && dist(i, chosen) <= k && minbad(i, chosen) >= order[i]) {\n//                prln(c[i]);\n//                prln(order[i], dist(i, chosen), minbad(i, chosen));\n                while (i != -1 && !chosen[i]) {\n                    chosen[i] = true;\n                    --k;\n                    i = anc[i][0];\n                }\n            }\n        }\n        StringBuilder ans = new StringBuilder();\n        gen(l, r, 0, ans, chosen, c);\n        prln(ans);\n        close();\n    }\n\n    static void gen(int l[], int r[], int i, StringBuilder s, boolean chosen[], char[] c) {\n        if (l[i] != -1) {\n            gen(l, r, l[i], s, chosen, c);\n        }\n        s.append(c[i]);\n        if (chosen[i]) {\n            s.append(c[i]);\n        }\n        if (r[i] != -1) {\n            gen(l, r, r[i], s, chosen, c);\n        }\n    }\n\n    static int minbad(int i, boolean chosen[]) {\n//        pr("call ");\n//        prln(i);\n        int ans = dep.length;\n        for (int j = anc[i].length - 1; j >= 0; --j) {\n//            prln(i, anc[i][j]);\n            if (anc[i][j] != -1 && !chosen[anc[i][j]]) {\n//                prln(i, ans, minbad[i][j], minbad[anc[i][j]][0]);\n                ans = min(ans, minbad[i][j]);\n                i = anc[i][j];\n            }\n        }\n        ans = min(ans, minbad[i][0]);\n        return ans;\n    }\n\n    static int dist(int i, boolean chosen[]) {\n        int d = dep[i];\n        for (int j = anc[i].length - 1; j >= 0; --j) {\n            if (anc[i][j] != -1 && !chosen[anc[i][j]]) {\n                i = anc[i][j];\n            }\n        }\n        return d - dep[i] + 1;\n    }\n\n    // initialization: dep[n], anc[n][lg(n)], fill(anc, -1)\n    static int dep[], anc[][], minbad[][];\n\n    static void binary_lifting_dfs(int l[], int r[], int i, boolean good[], int order[]) {\n        if (!good[i]) {\n            minbad[i][0] = order[i];\n        }\n        for (int j = 1; j < anc[i].length && anc[i][j - 1] >= 0; ++j) {\n            anc[i][j] = anc[anc[i][j - 1]][j - 1];\n            minbad[i][j] = min(minbad[i][j - 1], minbad[anc[i][j - 1]][j - 1]);\n        }\n        if (l[i] != -1) {\n            dep[l[i]] = dep[i] + 1;\n            anc[l[i]][0] = i;\n            binary_lifting_dfs(l, r, l[i], good, order);\n        }\n        if (r[i] != -1) {\n            dep[r[i]] = dep[i] + 1;\n            anc[r[i]][0] = i;\n            binary_lifting_dfs(l, r, r[i], good, order);\n        }\n    }\n\n    static int t = 0, lastv = -1, first = -1;\n\n    static void dfs(int l[], int r[], int i, int order[], int next[], int last[]) {\n        if (l[i] != -1) {\n            dfs(l, r, l[i], order, next, last);\n        }\n        if (t == 0) {\n            first = i;\n        }\n        order[i] = t++;\n        if (lastv != -1) {\n            next[lastv] = i;\n        }\n        last[i] = lastv;\n        lastv = i;\n        if (r[i] != -1) {\n            dfs(l, r, r[i], order, next, last);\n        }\n    }\n\n    static BufferedReader __i = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __o = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __r = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final long LMAX = 9223372036854775807L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n    static long gcd(long a, long b) {return b == 0 ? a : gcd(b, a % b);}\n    static int[] exgcd(int a, int b) {if (b == 0) return new int[] {1, 0, a}; int[] y = exgcd(b, a % b); return new int[] {y[1], y[0] - y[1] * (a / b), y[2]};}\n    static long[] exgcd(long a, long b) {if (b == 0) return new long[] {1, 0, a}; long[] y = exgcd(b, a % b); return new long[] {y[1], y[0] - y[1] * (a / b), y[2]};}\n    static int randInt(int min, int max) {return __r.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static void ria(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni();}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static void riam1(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static void rla(long[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nl();}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static void rda(double[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nd();}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static void rcha(char[] a) throws IOException {int n = a.length, i = 0; for (char c : rline().toCharArray()) a[i++] = c;}\n    static String rline() throws IOException {return __i.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__o.print(i);}\n    static void prln(int i) {__o.println(i);}\n    static void pr(long l) {__o.print(l);}\n    static void prln(long l) {__o.println(l);}\n    static void pr(double d) {__o.print(d);}\n    static void prln(double d) {__o.println(d);}\n    static void pr(char c) {__o.print(c);}\n    static void prln(char c) {__o.println(c);}\n    static void pr(char[] s) {__o.print(new String(s));}\n    static void prln(char[] s) {__o.println(new String(s));}\n    static void pr(String s) {__o.print(s);}\n    static void prln(String s) {__o.println(s);}\n    static void pr(Object o) {__o.print(o);}\n    static void prln(Object o) {__o.println(o);}\n    static void prln() {__o.println();}\n    static void pryes() {prln("yes");}\n    static void pry() {prln("Yes");}\n    static void prY() {prln("YES");}\n    static void prno() {prln("no");}\n    static void prn() {prln("No");}\n    static void prN() {prln("NO");}\n    static boolean pryesno(boolean b) {prln(b ? "yes" : "no"); return b;};\n    static boolean pryn(boolean b) {prln(b ? "Yes" : "No"); return b;}\n    static boolean prYN(boolean b) {prln(b ? "YES" : "NO"); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(\' \'), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(\' \'), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(\' \'), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(\' \'), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln("hlfd"); flush();}\n    static void flush() {__o.flush();}\n    static void close() {__o.close();}\n}', 'import java.io.*;\nimport java.util.*;\n\npublic class e {\n    public static int rem;\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int k = Integer.parseInt(tokenizer.nextToken());\n        String lab = in.readLine();\n        node[] list = new node[n];\n        for (int i = 0; i < n; i++) {\n            list[i] = new node(i, lab.substring(i, i + 1));\n        }\n        for (int i = 0; i < n; i++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            int left = Integer.parseInt(tokenizer.nextToken()) - 1;\n            int right = Integer.parseInt(tokenizer.nextToken()) - 1;\n            if (left != -1) {\n                list[i].left = list[left];\n                list[left].parent = list[i];\n            }\n            if (right != -1) {\n                list[i].right = list[right];\n                list[right].parent = list[i];\n            }\n            // System.out.println(list[i].left.id + " " + list[i].right.id);\n        }\n        node[] order = new node[n];\n        inorder(order, 0, list[0]);\n        for (int i = 0; i < n; i++) {\n            order[i].inorder = i;\n        }\n        rem = k;\n        ArrayList<String> vals = new ArrayList<>();\n        for (int i = order.length - 1; i >= 0; i--) {\n            if (vals.size() == 0 || !order[i].label.equals(vals.get(vals.size() - 1))) {\n                vals.add(order[i].label);\n            }\n            if (vals.size() <= 1 || vals.get(vals.size() - 1).compareTo(vals.get(vals.size() - 2)) >= 0) {\n                order[i].good = false;\n            } else {\n                order[i].good = true;\n            }\n        }\n        //dfs(list[0], null); // fix parent good values\n        dfs(list[0], 1);\n        /*for (int i = 0; i < order.length; i++) {\n            while (i + 1 < order.length && order[i + 1] == order[i].right && order[i + 1].cost() <= rem\n                    && (order[i + 1].good && (order[i + 1].constraint == null || order[i + 1].constraint.used))\n                    && !order[i + 1].used) {\n                i++;\n            }\n            if (order[i].cost() <= rem && (order[i].good && (order[i].constraint == null || order[i].constraint.used))\n                    && !order[i].used) {\n                rem -= order[i].cost;\n                update(order[i]);\n            }\n        }*/\n        StringBuilder b = new StringBuilder();\n        for (int i = 0; i < order.length; i++) {\n            b.append(order[i].label);\n            if (order[i].used) {\n                b.append(order[i].label);\n            }\n        }\n        System.out.println(b);\n        in.close();\n        out.close();\n    }\n\n    public static void dfs(node n, node c) {\n        if (n == null) {\n            return;\n        }\n        if (c != null) {\n            n.constraint = c;\n        }\n        dfs(n.left, c);\n        if (!n.good) {\n            c = n;\n        }\n        dfs(n.right, c);\n    }\n\n    public static void dfs(node n, int cost) {\n        if (n == null || n.used)\n            return;\n        dfs(n.left, cost + 1);\n        if (cost <= rem && n.good && !n.used) {\n            rem -= cost;\n            update(n);\n        }\n        if (n.used) {\n            dfs(n.right, 1);\n        }\n    }\n\n    public static void update(node n) {\n        // dfs(n, 0);\n        n.cost = 0;\n        n.used = true;\n        if (n.parent != null && !n.parent.used) {\n            update(n.parent);\n        }\n    }\n\n    public static int inorder(node[] order, int index, node n) {\n        if (n != null) {\n            index = inorder(order, index, n.left);\n            order[index++] = n;\n            index = inorder(order, index, n.right);\n        }\n        return index;\n    }\n\n    public static class node {\n        int id;\n        String label;\n        node left = null;\n        node right = null;\n        node parent = null;\n        node constraint = null;\n        int cost = 0;\n        boolean used = false;\n        boolean good = false;\n        int inorder = 0;\n\n        public node(int id, String label) {\n            this.id = id;\n            this.label = label;\n        }\n\n        public int cost() {\n            int val = 0;\n            node pointer = this;\n            while (pointer != null && !pointer.used) {\n                pointer = pointer.parent;\n                val++;\n            }\n            return cost = val;\n        }\n    }\n}', 'import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CFPractice {\n\t\n\t\n\t\n\tstatic long mod = 998244353;\n\tstatic PrintWriter out;\n\tstatic FastScanner sc;\n\tpublic static void main(String[] args) {\n\t\t\n\t\tsc = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tNode[] tree = new Node[n];\n\t\tString s = sc.nextToken();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttree[i] = new Node();\n\t\t\ttree[i].c = s.charAt(i);\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint l = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\tif(l != 0) {\n\t\t\t\ttree[i].lc = tree[l - 1];\n\t\t\t\ttree[l - 1].parent = tree[i];\n\t\t\t}\n\t\t\tif(r != 0) {\n\t\t\t\ttree[i].rc = tree[r - 1];\n\t\t\t\ttree[r - 1].parent = tree[i];\n\t\t\t}\n\t\t}\n\t\tNode[] sortedTree = new Node[n];\n\t\tsortTree(sortedTree, new int[] {0}, tree[0]);\n\t\tsortedTree[n-1].nextBigger = false;\n\t\t\n\t\tfor(int i = n -2; i >= 0; i--) {\n\t\t\tif(sortedTree[i].c < sortedTree[i + 1].c)\n\t\t\t\tsortedTree[i].nextBigger = true;\n\t\t\telse if(sortedTree[i].c == sortedTree[i + 1].c)\n\t\t\t\tsortedTree[i].nextBigger = sortedTree[i + 1].nextBigger;\n\t\t\telse\n\t\t\t\tsortedTree[i].nextBigger = false;\n\t\t}\n\t\t\n\t\tdfs(tree[0], new int[] {k});\n\t\tArrayList<Character> ou = new ArrayList<Character>();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tou.add(sortedTree[i].c);\n\t\t\tif(sortedTree[i].duplicate) {\n\t\t\t\tou.add(sortedTree[i].c);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < ou.size(); i++) {\n\t\t\tout.print(ou.get(i));\n\t\t}\n\t\tout.flush();\n\t\t\n\t}\n\tstatic boolean dfs(Node node, int[] k) {\n\t\tif(k[0] <= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif(node.nextBigger) {\n\t\t\tk[0]--;\n\t\t\tnode.duplicate = true;\n\t\t\tif(node.lc != null) {\n\t\t\t\tdfs(node.lc, k);\n\t\t\t}\n\t\t\tif(node.rc != null) {\n\t\t\t\tdfs(node.rc, k);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tk[0]--;\n\t\t\tif(node.lc != null && dfs(node.lc, k)) {\n\t\t\t\tnode.duplicate = true;\n\t\t\t\tif(node.rc != null) {\n\t\t\t\t\tdfs(node.rc, k);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tk[0]++;\n\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstatic void sortTree(Node tree[], int[] index, Node current) {\n\t\tif(current.lc != null) {\n\t\t\tsortTree(tree, index, current.lc);\n\t\t}\n\t\ttree[index[0]] = current;\n\t\tindex[0]++;\n\t\tif(current.rc != null) {\n\t\t\tsortTree(tree, index, current.rc);\n\t\t}\n\t}\n\t\n\t\n\t\n\tstatic int guess(int a, int b, int c) {\n\t\tSystem.out.println("?" + " " + a + " " + b + " " + c);\n\t\tSystem.out.flush();\n\t\tint o = sc.nextInt();\n\t\treturn o;\n\t}\n\t\n\t\n\t\n\tstatic int occursBefore(int i, int j) {\n\t\tif(i < j) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tstatic ArrayList<Long> lcm() {\n\t\tlong max = 10000_000_000_000_000l;\n\t\tArrayList<Long> output = new ArrayList<Long>();\n\t\tlong lcm = 1;\n\t\toutput.add(1l);\n\t\tint index = 2;\n\t\twhile(lcm <= max) {\n\t\t\tlong gcd = gcd(index, lcm);\n\t\t\tlcm = lcm * (index/gcd);\n\t\t\toutput.add(lcm);\n\t\t\tindex++;\n\t\t}\n\t\toutput.add(max + 1);\n\t\treturn output;\n\t}\n\t\n\t\n\tstatic long computeMod(int n) {\n\t\tlong prod = 1;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tprod *= 2;\n\t\t\tprod = prod % mod;\n\t\t}\n\t\treturn prod;\n\t}\n\t\n\t\n\tstatic long gcd(long n, long m) {\n\t\twhile(n >= 1 && m >= 1) {\n\t\t\tif(n > m) {\n\t\t\t\tn = n %m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tm = m % n;\n\t\t\t}\n\t\t}\n\t\treturn Math.max(m, n);\n\t}\n\t\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n \n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tString nextToken() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n \n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\tstatic class Node{\n\t\tNode lc;\n\t\tNode rc;\n\t\tNode parent;\n\t\tboolean duplicate;\n\t\tboolean nextBigger;\n\t\tchar c;\n\t}\n\t\n\t\n\n\n\t\n\t\t\t\n}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\t\n\t\t\n\t\t\n\t\n\t\n\t\n\t\n\t\n\n\t\n\n', '// package c1623;\n\nimport java.io.File;\nimport java.lang.invoke.MethodHandles;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n//\n// Codeforces Round #763 (Div. 2) 2021-12-28 05:35\n// E. Middle Duplication\n// https://codeforces.com/contest/1623/problem/E\n// time limit per test 1 second; memory limit per test 256 megabytes\n// public class Pseudo for \'Source should satisfy regex [^{}]*public\\s+(final)?\\s*class\\s+(\\w+).*\'\n//\n// A binary tree of n nodes is given. Nodes of the tree are numbered from 1 to n and the root is the\n// node 1. Each node can have no child, only one left child, only one right child, or both children.\n// For convenience, let\'s denote l_u and r_u as the left and the right child of the node u\n// respectively, l_u = 0 if u does not have the left child, and r_u = 0 if the node u does not have\n// the right child.\n//\n// Each node has a string label, initially is a single character c_u. Let\'s define the string\n// representation of the binary tree as the concatenation of the labels of the nodes in the .\n// Formally, let f(u) be the string representation of the tree rooted at the node u. f(u) is defined\n// as follows: <div class="MathJax_Display" style="text-align: center;"></div> f(u) = \\begin{cases}\n// \\texttt{<empty string>}, & \\text{if }u = 0; \\\\ f(l_u) + c_u + f(r_u) & \\text{otherwise},\n// \\end{cases} where + denotes the string concatenation operation.\n//\n// This way, the string representation of the tree is f(1).\n//\n// For each node, we can its label , that is, assign c_u with c_u + c_u, but only if u is the root\n// of the tree, or if its parent also has its label duplicated.\n//\n// You are given the tree and an integer k. What is the lexicographically smallest string\n// representation of the tree, if we can duplicate labels of at most k nodes?\n//\n// A string a is lexicographically smaller than a string b if and only if one of the following\n// holds:\n//  * a is a prefix of b, but a \\ne b;\n//  * in the first position where a and b differ, the string a has a letter that appears earlier in\n//    the alphabet than the corresponding letter in b. </div><div class="input-specification"><div\n// class="section-title">Input</div>\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Input\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Output\n//\n// Print a single line, containing the lexicographically smallest string representation of the tree\n// if at most k nodes have their labels duplicated.\n//\n// Example\n/*\ninput:\n4 3\nabab\n2 3\n0 0\n0 4\n0 0\n\noutput:\nbaaaab\n\ninput:\n8 2\nkadracyn\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndaarkkcyan\n\ninput:\n8 3\nkdaracyn\n2 5\n0 3\n0 4\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndarkcyan\n*/\n// Note\n//\n// The images below present the tree for the examples. The number in each node is the node number,\n// while the subscripted letter is its label. To the right is the string representation of the tree,\n// with each letter having the same color as the corresponding node.\n//\n// Here is the tree for the first example. Here we duplicated the labels of nodes 1 and 3. We should\n// not duplicate the label of node 2 because it would give us the string "", which is\n// lexicographically greater than "".\n// https://espresso.codeforces.com/30116fa124ec3edbd4c16ac29fa8eb45c19cc171.png\n//\n// In the second example, we can duplicate the labels of nodes 1 and 2. Note that only duplicating\n// the label of the root will produce a worse result than the initial string.\n// https://espresso.codeforces.com/e66a56b1c8dee019f4f4c138ee0333caf44b312c.png\n//\n// In the third example, we should not duplicate any character at all. Even though we would want to\n// duplicate the label of the node 3, by duplicating it we must also duplicate the label of the node\n// 2, which produces a worse result.\n// https://espresso.codeforces.com/19b0d4c5514801c166e9b3f0ef4c110939711a20.png\n//\n// There is no way to produce string "" from a tree with the initial string representation "" :(.\n//\npublic class C1623E {\n  static final int MOD = (int)1e9+7;\n  static final Random RAND = new Random();\n\n  static String solve(String s, int k, int[][] lr) {\n    // Note that both s and lr have length n + 1\n    int n = s.length() - 1;\n\n    // [parent, depth, subtree size, dfs-done, duplicate, in-order index]\n    //  0       1      2             3         4          5\n    int[][] nodes = dfsNodes(lr);\n\n    // ids in in-order\n    int[] ids = new int[n];\n\n    // id, offset\n    Queue<int[]> q = new LinkedList<>();\n    q.add(new int[] {1, 0});\n    while (!q.isEmpty()) {\n      int[] e = q.poll();\n      int v = e[0];\n      int offset = e[1];\n      int l = lr[v][0];\n      int r = lr[v][1];\n      int idx = offset;\n      if (l > 0) {\n        q.add(new int[] {l, idx});\n        idx += nodes[l][2];\n      }\n      nodes[v][5] = idx;\n      ids[idx++] = v;\n      if (r > 0) {\n        q.add(new int[] {r, idx});\n      }\n    }\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    // System.out.format("%s\\n", Utils.trace(ids));\n\n    // Note that ids[] is 0-indexed!\n    int b = 0;\n    int avail = k;\n    while (b < n) {\n      int v = ids[b];\n      // System.out.format("  b:%d v:%d depth:%d k:%d\\n", b, v, nodes[v][1], k);\n      if (nodes[v][1] > k) {\n        // don\'t bother if v is too deep\n        b++;\n        continue;\n      }\n      char c = s.charAt(v);\n      int e = b + 1;\n      while (e < n && s.charAt(ids[e]) == c) {\n        e++;\n      }\n      boolean duplicate = e < n && s.charAt(ids[e]) > c;\n      // System.out.format("  b:%d v:%d e:%d dup:%b\\n", b, v, e, duplicate);\n      if (!duplicate) {\n        b = e;\n        continue;\n      }\n\n      // We may duplicate some nodes between [b,e) as long as there is budget\n      for (int i = b; i < e; i++) {\n        int id = ids[i];\n        if (nodes[id][4] == 1) {\n          // skip ones already decided to duplicate earlier (part chain).\n          continue;\n        }\n\n        // Can we afford duplicate i?\n        // walk up parent chain until a duplicated node or root\n        int needed = 0;\n        // w is the node id\n        int w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          needed++;\n          int p = nodes[w][0];\n          if (p != 0 && nodes[p][4] == 0 && nodes[p][5] < nodes[w][5]) {\n            // do not trigger duplicate of an ancestor in front as it will make things worse\n            needed = Integer.MAX_VALUE;\n            break;\n          }\n          // if (p != 0 && nodes[p][4])\n          w = nodes[w][0];\n        }\n        // System.out.format("    i:%d id:%d needed:%d avail:%d\\n", i, id, needed, avail);\n        if (needed > avail) {\n          continue;\n        }\n        w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          nodes[w][4] = 1;\n          avail--;\n          w = nodes[w][0];\n        }\n        myAssert(avail >= 0);\n      }\n      b = e;\n    }\n    // System.out.format("%s\\n", Utils.trace(ids));\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    StringBuilder sb = new StringBuilder();\n    for (int v : ids) {\n      sb.append(s.charAt(v));\n      if (nodes[v][4] == 1) {\n        sb.append(s.charAt(v));\n      }\n    }\n    return sb.toString();\n  }\n\n  // [parent, depth, subtree size, done]\n  static int[][] dfsNodes(int[][] lr) {\n    int n = lr.length - 1;\n    int[][] nodes = new int[n + 1][6];\n    Stack<Integer> stack = new Stack<>();\n    stack.push(1);\n    nodes[1][1] = 1;\n    while (!stack.isEmpty()) {\n      int v = stack.peek();\n      // System.out.format("  v:%d %s\\n", v, Arrays.toString(nodes[v]));\n      int l = lr[v][0];\n      int r = lr[v][1];\n      if (l == 0 && r == 0) {\n        nodes[v][2] = 1;\n        nodes[v][3] = 1;\n        stack.pop();\n      } else if (l > 0 && r == 0) {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        } else {\n          nodes[v][2] = 1 + nodes[l][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else if (l == 0 && r > 0) {\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        } else {\n          nodes[v][2] = 1 + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        }\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        }\n        if (nodes[l][3] == 1 && nodes[r][3] == 1) {\n          nodes[v][2] = 1 + nodes[l][2] + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      }\n    }\n    return nodes;\n  }\n\n  static String trace(int[] a) {\n    StringBuilder sb = new StringBuilder();\n    for (int v : a) {\n     if (sb.length() > 0) {\n       sb.append(\' \');\n     }\n      sb.append(v);\n    }\n    return sb.toString();\n  }\n\n  static void myAssert(boolean cond) {\n    if (!cond) {\n      throw new RuntimeException("Unexpected");\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner in = getInputScanner();\n    int n = in.nextInt();\n    int k = in.nextInt();\n    String s = \' \' + in.next();\n    int[][] lr = new int[n + 1][2];\n    for (int i = 1; i <= n; i++) {\n      lr[i][0] = in.nextInt();\n      lr[i][1] = in.nextInt();\n    }\n    String ans = solve(s, k, lr);\n    System.out.println(ans);\n    in.close();\n  }\n\n  static Scanner getInputScanner() {\n    try {\n      final String USERDIR = System.getProperty("user.dir");\n      final String CNAME = MethodHandles.lookup().lookupClass().getSimpleName();\n      final File fin = new File(USERDIR + "/io/c" + CNAME.substring(1,5) + "/" + CNAME + ".in");\n      return fin.exists() ? new Scanner(fin) : new Scanner(System.in);\n    } catch (Exception e) {\n      return new Scanner(System.in);\n    }\n  }\n}\n', 'import java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Solution {\n    // VM options: -Xmx1024m -Xss1024m\n\n\n    private void solve() throws IOException {\n        n = nextInt();\n        k = nextInt();\n        s = nextToken().toCharArray();\n        nx = new int[n][2];\n        ints = new Int[n];\n        for (int i = 0; i < n; i++) {\n            nx[i][0] = nextInt() - 1;\n            nx[i][1] = nextInt() - 1;\n            ints[i] = new Int(i);\n        }\n        doubled = new boolean[n];\n        order = new int[n];\n        orderSize = 0;\n        go(0);\n        lastIdx = new int[n];\n        for (int last = n - 1, i = n - 1; i >= 0; i--) {\n            if (s[order[last]] != s[order[i]]) {\n                last = i;\n            }\n            lastIdx[order[i]] = last;\n        }\n        go2(0, new ArrayList<>(), true);\n        for (int i : order) {\n            out.print(s[i]);\n            if (doubled[i]) out.print(s[i]);\n        }\n        out.println();\n    }\n\n    private int[] lastIdx;\n    private int n;\n    private char[] s;\n    private Int[] ints;\n    private int[] order;\n    private int orderSize;\n    private int[][] nx;\n    private int k;\n    private boolean[] doubled;\n\n    private void go2(int v, ArrayList<Int> notMarked, boolean allow) {\n        notMarked.add(ints[v]);\n        if (allow && notMarked.size() <= k && (lastIdx[v] + 1 < n && s[v] < s[order[lastIdx[v] + 1]])) {\n            k -= notMarked.size();\n            for (Int i : notMarked) {\n                doubled[i.x] = true;\n            }\n            notMarked.clear();\n        }\n        if (nx[v][0] != -1) {\n            go2(nx[v][0], notMarked, allow);\n        }\n        if (!notMarked.isEmpty()) {\n            notMarked.remove(notMarked.size() - 1);\n        }\n        if (nx[v][1] != -1) {\n            go2(nx[v][1], new ArrayList<>(), allow && doubled[v]);\n        }\n    }\n\n    private void go(int v) {\n        if (v == -1) return;\n        go(nx[v][0]);\n        order[orderSize++] = v;\n        go(nx[v][1]);\n    }\n\n    private static class Int {\n        int x;\n\n        public Int(int x) {\n            this.x = x;\n        }\n    }\n\n    private static final String inputFilename = "input.txt";\n    private static final String outputFilename = "output.txt";\n    private BufferedReader in;\n    private StringTokenizer line;\n    private PrintWriter out;\n    private final boolean isDebug;\n\n    private Solution(boolean isDebug) {\n        this.isDebug = isDebug;\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Solution(Arrays.asList(args).contains("DEBUG_MODE")).run(args);\n    }\n\n    private void run(String[] args) throws IOException {\n        if (isDebug) {\n            in = new BufferedReader(new InputStreamReader(new FileInputStream(inputFilename)));\n//            in = new BufferedReader(new InputStreamReader(System.in));\n        } else {\n            in = new BufferedReader(new InputStreamReader(System.in));\n        }\n        out = new PrintWriter(System.out);\n//        out = new PrintWriter(outputFilename);\n\n\n        int t = isDebug ? nextInt() : 1;\n//        int t = 1;\n\n//        int t = nextInt();\n        for (int i = 0; i < t; i++) {\n//            out.print("Case #" + (i + 1) + ": ");\n            solve();\n            out.flush();\n        }\n\n        in.close();\n        out.flush();\n        out.close();\n    }\n\n    private void println(Object... objects) {\n        boolean isFirst = true;\n        for (Object o : objects) {\n            if (!isFirst) {\n                out.print(" ");\n            } else {\n                isFirst = false;\n            }\n            out.print(o.toString());\n        }\n        out.println();\n    }\n\n    private int[] nextIntArray(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextInt();\n        }\n        return res;\n    }\n\n    private long[] nextLongArray(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextLong();\n        }\n        return res;\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private String nextToken() throws IOException {\n        while (line == null || !line.hasMoreTokens()) {\n            line = new StringTokenizer(in.readLine());\n        }\n        return line.nextToken();\n    }\n\n    private static void assertPredicate(boolean p) {\n        if (!p) {\n            throw new RuntimeException();\n        }\n    }\n\n    private static void assertPredicate(boolean p, String message) {\n        if (!p) {\n            throw new RuntimeException(message);\n        }\n    }\n\n    private static void assertNotEqual(int unexpected, int actual) {\n        if (actual == unexpected) {\n            throw new RuntimeException("assertNotEqual: " + unexpected + " == " + actual);\n        }\n    }\n\n    private static void assertEqual(int expected, int actual) {\n        if (expected != actual) {\n            throw new RuntimeException("assertEqual: " + expected + " != " + actual);\n        }\n    }\n}\n', 'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class e {\n\tstatic final int LOG=30;\n\tstatic final int INF=Integer.MAX_VALUE/2-5;\n\tpublic static void main(String[] args) {\n\t\tFastScanner scan=new FastScanner();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\n\t\tint n=scan.nextInt();\n\t\tk=scan.nextInt();\n\t\tc=scan.next().toCharArray();\n\n\t\ta=new int[n][2];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i][0]=scan.nextInt()-1;\n\t\t\ta[i][1]=scan.nextInt()-1;\n\t\t}\n\t\tinorder=new ArrayList<>();\n\t\tdepth=new int[n];\n\t\tparent=new int[n];\n\t\tid=new int[n];\n\t\tinit(0,1,-1);\n\n\t\tint[] last=new int[26];\n\t\tArrays.fill(last,-1);\n\t\tlast[(int)(c[inorder.get(n-1)]-\'a\')]=n-1;\n\t\tgood=new boolean[n];\n\n\t\tfor(int i=n-2;i>=0;i--) {\n\t\t\tint p=inorder.get(i), q=inorder.get(i+1);\n\t\t\tint nxtdif=Integer.MAX_VALUE;\n\t\t\tchar nxtchar=\' \';\n\t\t\tfor(int j=0;j<26;j++) {\n\t\t\t\tif(j!=(int)(c[q]-\'a\')&&last[j]!=-1) {\n\t\t\t\t\tif(nxtdif>last[j]) {\n\t\t\t\t\t\tnxtdif=last[j];\n\t\t\t\t\t\tnxtchar=(char)(j+\'a\');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c[p]<c[q]) {\n\t\t\t\t//expanding here\n\t\t\t\tgood[p]=true;\n\t\t\t}\n\t\t\telse if(c[p]==c[q]&&nxtdif!=Integer.MAX_VALUE&&nxtchar>c[p]) {\n\t\t\t\t//expanding here\n\t\t\t\tgood[p]=true;\n\t\t\t}\n\t\t\tlast[(int)(c[inorder.get(i)]-\'a\')]=i;\n\t\t}\n\t\texpand=new boolean[n];\n\t\tdfs(0,depth);\n\t\t\n\t\tStringBuilder res=new StringBuilder();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint cur=inorder.get(i);\n\t\t\tres.append(c[cur]);\n\t\t\tif(expand[cur]) {\n\t\t\t\tres.append(c[cur]);\n\t\t\t}\n\t\t}\n\t\tout.println(res);\n\t\tout.close();\n\t}\n\tpublic static boolean dfs(int at, int[] cost) {\n//\t\tSystem.out.println(at+" "+cost[at]+" "+k);\n\t\tboolean exploreRight=false;\n\t\tint l=a[at][0], r=a[at][1];\n\t\t\n\t\tif(good[at]&&cost[at]<=k) {\n\t\t\texpand[at]=true;\n\t\t\tk-=cost[at];\n\t\t\texploreRight=true;\n\t\t\tif(l!=-1) cost[l]=1;\n\t\t\tif(r!=-1) cost[r]=1;\n\t\t}\n\t\telse {\n\t\t\tif(l!=-1) cost[l]=1+cost[at];\n\t\t\tif(r!=-1) cost[r]=1+cost[at];\n\t\t}\n\t\tif(l!=-1) {\n\t\t\tif(dfs(l,cost)) {\n\t\t\t\texploreRight=true;\n\t\t\t\texpand[at]=true;\n\t\t\t\tif(l!=-1) cost[l]=1;\n\t\t\t\tif(r!=-1) cost[r]=1;\n\t\t\t}\n\t\t}\n\t\tif(exploreRight&&r!=-1) {\n\t\t\tdfs(r,cost);\n\t\t}\n\t\treturn expand[at];\n\t}\n\tpublic static void init(int at, int d, int p) {\n\t\tdepth[at]=d;\n\t\tparent[at]=p;\n\t\tif(a[at][0]!=-1) init(a[at][0],d+1,at);\n\t\tinorder.add(at);\n\t\tid[at]=inorder.size()-1;\n\t\tif(a[at][1]!=-1) init(a[at][1],d+1,at);\n\t}\n\tstatic int k;\n\tstatic boolean[] expand,good;\n\tstatic ArrayList<Integer> inorder;\n\tstatic int[][] a;\n\tstatic int[] id;\n\tstatic int[] depth,parent;\n\tstatic char[] c;\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\ttry\t{\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e){e.printStackTrace();}\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (st.hasMoreTokens())\treturn st.nextToken();\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() {return Long.parseLong(next());}\n\n\t\tpublic double nextDouble() {return Double.parseDouble(next());}\n\n\t\tpublic String nextLine() {\n\t\t\tString line = "";\n\t\t\tif(st.hasMoreTokens()) line = st.nextToken();\n\t\t\telse try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n\t\t\twhile(st.hasMoreTokens()) line += " "+st.nextToken();\n\t\t\treturn line;\n\t\t}\n\t}\n}']}
----------------------------------------------------------------------------------------------------
incorrect_solutions
{'language': ['CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'PYTHON3', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'PYTHON3', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'JAVA', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'JAVA', 'CPP', 'CPP', 'CPP', 'JAVA', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'JAVA', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'JAVA', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'PYTHON3', 'CPP', 'CPP', 'JAVA', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'JAVA', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'JAVA', 'CPP', 'JAVA', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP', 'CPP'], 'solution': ['#include <bits/stdc++.h>\nusing namespace std;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \' \' << H;\n  debug_out(T...);\n}\nconst long long MOD = 1e9 + 7;\nconst int N = 2e5 + 1;\nint l[N], r[N], lm[N], p[N][20], nxt[N], dept[N];\nvector<bool> nxtpos(N + 1, 0);\nvector<char> s(N);\nint n, k;\nvoid lmq(int cur) {\n  lm[cur] = cur;\n  if (l[cur] > 0) {\n    dept[l[cur]] = dept[cur] + 1;\n    p[l[cur]][0] = cur;\n    lmq(l[cur]);\n    lm[cur] = lm[l[cur]];\n  }\n  if (r[cur] > 0) {\n    dept[r[cur]] = dept[cur] + 1;\n    p[r[cur]][0] = cur;\n    lmq(r[cur]);\n  }\n}\nvoid setnext(int cur, int rlp) {\n  if (r[cur] > 0) {\n    nxt[cur] = lm[r[cur]];\n    setnext(r[cur], rlp);\n  } else {\n    nxtpos[cur] = 1;\n    nxt[cur] = rlp;\n  }\n  if (l[cur] > 0) setnext(l[cur], cur);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dept[1] = 1;\n  lmq(1);\n  setnext(1, 0);\n  for (int i = 1; i < 20; i++) {\n    for (int j = 1; j <= n; j++) {\n      p[j][i] = p[p[j][i - 1]][i - 1];\n    }\n  }\n  vector<bool> dup(n + 1, 0), ndup(n + 1, 0);\n  int cur = lm[1];\n  while (cur != 0) {\n    if (dup[cur]) {\n      cur = nxt[cur];\n      continue;\n    }\n    if (s[cur] < s[nxt[cur]]) {\n      int len = 0, temp = cur, i = 19;\n      bool blocked = false;\n      while (!blocked && p[temp][0] > 0 && !dup[p[temp][0]]) {\n        for (; i >= 0; i--) {\n          if (p[temp][i] > 0 && ndup[p[temp][i]]) {\n            blocked = true;\n            break;\n          }\n          if (p[temp][i] > 0 && !dup[p[temp][i]]) {\n            len += (1 << i);\n            temp = p[temp][i];\n            break;\n          }\n        }\n      }\n      len++;\n      temp = cur;\n      if (!blocked && len <= k) {\n        k -= len;\n        while (len--) {\n          dup[temp] = 1;\n          temp = p[temp][0];\n        }\n      }\n    }\n    if (s[cur] > s[nxt[cur]] && !nxtpos[cur]) {\n      int temp = cur;\n      while (temp > 0 && !ndup[temp] && !dup[temp]) {\n        ndup[temp] = 1;\n        temp = p[temp][0];\n      }\n    }\n    cur = nxt[cur];\n  }\n  int start = lm[1];\n  while (start != 0) {\n    if (dup[start]) {\n      cout << s[start] << s[start];\n    } else {\n      cout << s[start];\n    }\n    start = nxt[start];\n  }\n  cout << "\\n";\n  return 0;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint l[200005], r[200005], good[200005];\nchar m[200005], nxt[200005];\nstring s, t;\nstring res;\nvector<int> v;\nvoid dfs1(int u) {\n  if (!u) return;\n  dfs1(l[u]);\n  t += s[u];\n  v.push_back(u);\n  dfs1(r[u]);\n}\nbool dfs(int u, int h, bool goodSub) {\n  if (!u) return false;\n  bool used = false;\n  if (dfs(l[u], h + 1, goodSub)) {\n    used = true;\n  }\n  if ((good[u] && h <= k) && !used) {\n    k -= h;\n    used = true;\n  }\n  if (used) {\n    res += s[u];\n    res += s[u];\n    used = true;\n  } else {\n    res += s[u];\n  }\n  if (good[u] && goodSub) {\n    dfs(r[u], 1, goodSub);\n  } else {\n    dfs(r[u], k + 1, false);\n  }\n  return used;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> n >> k;\n  cin >> s;\n  s = '#' + s;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs1(1);\n  char cur = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    m[v[i]] = cur;\n    cur = max(cur, t[i]);\n    if (i != n - 1) {\n      if (t[i] == t[i + 1])\n        nxt[v[i]] = nxt[v[i + 1]];\n      else\n        nxt[v[i]] = t[i + 1];\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    if (s[i] < nxt[i]) {\n      good[i] = 1;\n    }\n  }\n  dfs(1, 1, true);\n  cout << res << endl;\n  return 0;\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename A,typename B>\nstring to_string(pair<A,B>p){return"("+to_string(p.first)+", "+to_string(p.second)+")";}\ntemplate<typename A,typename B,typename C>\nstring to_string(tuple<A,B,C>p){return"("+to_string(get<0>(p))+", "+to_string(get<1>(p))+", "+to_string(get<2>(p))+")";}\ntemplate<typename A,typename B,typename C,typename D>\nstring to_string(tuple<A,B,C,D>p){return"("+to_string(get<0>(p))+", "+to_string(get<1>(p))+", "+to_string(get<2>(p))+", "+to_string(get<3>(p))+")";}\nstring to_string(const string &s){return\'"\'+s+\'"\';}\nstring to_string(const char *s){return to_string((string)s);}\nstring to_string(bool b){return(b?"true":"false");}\nstring to_string(vector<bool>v){int f=0;string r="{";for(bool i:v)r+=(f++?",":"")+to_string(i);r+="}";return r;}\ntemplate<size_t N>\nstring to_string(bitset<N>v){string res="";for(size_t i=0;i<N;res+=char(\'0\'+v[i++]));return res;}\ntemplate<typename A>\nstring to_string(A v){int f=0;string r="{";for(auto&i:v)r+=(f++?",":"")+to_string(i);r+="}";return r;}\nvoid debug_out(){cerr<<\']\'<<endl;}\ntemplate<typename Head,typename...Tail>\nvoid debug_out(Head H,Tail...T){cerr<<to_string(H);if(sizeof...(T))cerr<<", ";debug_out(T...);}\n#ifdef LOCAL\n#define debug(x...) cerr << "[" << (#x) << "] = [", debug_out(x)\n#else\n#define debug(x...) 33\n#endif\n#define int long long\nint N, K;\nchar S[200\'200];\nvector<int> g[200\'200];\nint par[200\'200];\nint dep[200\'200];\n\nvector<int> dfsOrder;\nint dfsN[200\'200];\nvoid dfs(int now)\n{\n\t\n\tfor (int i = 0; i < 2; ++i)\n\t{\n\t\tint it = g[now][i];\n\t\tif (it != -1) \n\t\t{\n\t\t\tdep[it] = dep[now] + 1;\n\t\t\tdfs(it);\n\t\t}\n\t\tif (!i)\n\t\t{\n            dfsN[now] = (int)dfsOrder.size();\n            dfsOrder.push_back(now);\n        }\n\t}\n\t// for (auto &it: g[now]) \n\t// {\n\t// \tif (it != -1) \n\t// \t{\n\t// \t\tdep[it] = dep[now] + 1;\n\t// \t\tdfs(it);\n\t// \t}\n\t// }\n}\nint nextNode[200\'200];\nbool go_dup[200\'200];\nint NodeNode[200\'200];\n\nbool real_iduc[200\'200];\nint for_who_dfsN[200\'200];\nint reachable_dfsN[200\'200];\nvoid dfs2(int now)\n{\n\tfor (auto &it: g[now]) \n\t{\n\t\tif (it != -1) dfs2(it);\n\t}\n\treal_iduc[now] = go_dup[now];\n\tif (go_dup[now])\n\t{\n\t\tfor_who_dfsN[now] = dfsN[now];\n\t\treachable_dfsN[now] = dfsN[now];\n\t}\n\tif (g[now][0] != -1)\n\t{\n\t\treal_iduc[now] |= real_iduc[g[now][0]];\n\n\t\tif (real_iduc[g[now][0]])\n\t\t{\n\t\t\tfor_who_dfsN[now] = for_who_dfsN[g[now][0]];\n\n\t\t\tif (reachable_dfsN[now] == -1)\n\t\t\t{\n\t\t\t\treachable_dfsN[now] = reachable_dfsN[g[now][0]];\n\t\t\t}\n\t\t}\n\n\t}\n}\nvoid dfs3(int now, int reallll)\n{\n\treal_iduc[now] = real_iduc[now] && reallll;\n\tfor (auto &it: g[now])\n\t{\n\t\tif (it != -1) dfs3(it, reallll && real_iduc[now]);\n\t}\n}\nint really_dup[200\'200];\n\nint find_cost(int now)\n{\n\tif (really_dup[now]) return 0;\n\tif (now == 0) return 1;\n\treturn find_cost(par[now]) + 1;\n}\nvoid fill_really_dup(int now)\n{\n\tif (really_dup[now]) return;\n\treally_dup[now] = true;\n\tif (now == 0) return;\n\tfill_really_dup(par[now]);\n}\nsigned main()\n{\n    cin.tie(0)->sync_with_stdio(false);\n\tmemset(reachable_dfsN, -1, sizeof reachable_dfsN);\n\tcin >> N >> K;\n\tcin >> S;\n\n\tpar[0] = -1;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tint u, v; cin >> u >> v; --u, --v;\n\n\t\tg[i].push_back(u);\n\t\tg[i].push_back(v);\n\t\t\n\t\tpar[u] = par[v] = i;\n\t}\n\tdfs(0);\n\t// debug(dfsOrder);\n\tmemset(nextNode, -1, sizeof nextNode);\n\tfor (int x = 0; x + 1 < (int)dfsOrder.size(); ++x)\n\t{\n\t\tnextNode[dfsOrder[x]] = dfsOrder[x + 1];\n\t}\n\n\tfor (int i = 0, j = 0; i < (int)dfsOrder.size(); ++i)\n\t{\n\t\twhile(j < (int)dfsOrder.size() && S[dfsOrder[i]] == S[dfsOrder[j]])\n\t\t\t++j;\n\n\t\tassert(i < j);\n\t\tif (j == (int)dfsOrder.size())\n\t\t{\n\t\t\tNodeNode[dfsOrder[i]] = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNodeNode[dfsOrder[i]] = dfsOrder[j];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (NodeNode[i] == -1) go_dup[i] =false;\n\t\telse\n\t\t{\n\t\t\tassert(S[i] != S[NodeNode[i]]);\n\n\t\t\tif (S[i] > S[NodeNode[i]]) go_dup[i] = false;\n\t\t\telse go_dup[i] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (dep[i] >= K)\n\t\t{\n\t\t\tgo_dup[i] = false;\n\t\t}\n\t}\n\tdfs2(0);\n\tdfs3(0, 1);\n\t\n\tvector<pair<int, int>> ps;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (real_iduc[i])\n\t\t{\n\t\t\tps.push_back(make_pair(dfsN[i], i));\n\t\t}\n\t}\n\tsort(ps.begin(), ps.end());\n\tfor (auto &[dN, node]: ps)\n\t{\n\t\tint cost = find_cost(node);\n\t\tif (cost <= K)\n\t\t{\n\t\t\tK -= cost;\n\t\t\tfill_really_dup(node);\n\t\t}\n\t}\n\n\t// vector<tuple<int, int, int>> omy;\n\t// for (int i = 0; i < N; ++i)\n\t// {\n\t// \tif (real_iduc[i])\n\t// \t{\n\t// \t\tomy.push_back({for_who_dfsN[i], -dep[i], i});\n\t// \t}\n\t// }\n\t// sort(omy.begin(), omy.end());\n\t// for (int i = 0; i < K && i < (int)omy.size(); ++i)\n\t// {\n\t// \treally_dup[get<2>(omy[i])] = true;\n\t// }\n\n\t// vector<pair<int, int>> pp;\n\t// for (int i = 1; i < N; ++i)\n\t// {\n\n\t// \tpp.push_back({dep[i], i});\n\t// }\n\t// sort(pp.begin(), pp.end());\n\t// for (auto &[dp, node]: pp)\n\t// {\n\t\t\n\t// \tif (really_dup[par[node]] == false)\n\t// \t{\n\t// \t\treally_dup[node] = false;\n\t// \t}\n\t// }\n\t// for (int i = 1; i < N; ++i)\n\t// {\n\t// \tif (really_dup[i]) assert(really_dup[par[i]]);\n\t// }\n\t\n\tfor (auto &it: dfsOrder)\n\t{\n\t\tcout << S[it];\n\n\t\tif (really_dup[it]) cout << S[it];\n\t}\n\tcout << \'\\n\';\n\n    return 0;\n}', '//#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//randoms\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\n#define ll long long\n#define trace(x) cout << #x << " = " << (x) << endl;\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define unique(x) x.erase(unique(all(x)), (x).end())\n#define ld long double\n#define sz(s) (int) size(s)\n#define pii pair<int, int>\n#define mp(x, y) make_pair(x, y)\n\n\nconst int N = 200001;\nconst ll infL = 1e18;\nconst int infI = 1e9 + 7;\nconst int LG = 20;\nint n, k, l[N], r[N], d[N], jump[LG][N];\nbool used[N];\nchar c[N];\n\nvoid init() {\n    for (int j = 1; j < LG; ++j) {\n        for (int i = 0; i < n; ++i)\n            jump[j][i] = jump[j - 1][jump[j - 1][i]];\n    }\n}\n\nint lca(int v, int u) {\n    if (d[u] < d[v]) swap(u, v);\n    for (int i = LG - 1; i > -1; --i)\n        if (d[jump[i][u]] >= d[v])\n            u = jump[i][u];\n    if (v == u) {\n        return v;\n    }\n    for (int i = LG - 1; i > -1; --i) {\n        if (jump[i][u] != jump[i][v]) {\n            u = jump[i][u];\n            v = jump[i][v];\n        }\n    }\n    return jump[0][u];\n}\n\nstring wow;\nint idx[N];\n\nvoid precalc(int v, int dep, int p) {\n    d[v] = dep;\n    jump[0][v] = p;\n    if (l[v] != -1) precalc(l[v], dep + 1, v);\n    idx[v] = sz(wow);\n    wow.push_back(c[v]);\n    if (r[v] != -1) precalc(r[v], dep + 1, v);\n}\n\n\nbool yay(int v, int len) {\n    if (len > k)\n        return false;\n    k -= len;\n    while (len--) {\n        used[v] = 1;\n        v = jump[0][v];\n    }\n    return true;\n}\n\n\nvoid dfs(int v, bool fuck, int len) {\n    if (l[v] != -1) dfs(l[v], fuck, len + 1);\n    if (l[v] != -1) len = 0;\n    if (!used[v]) {\n        bool now = fuck && (wow[idx[v]] > c[v]);\n        if (now) {\n            used[v] = yay(v, len);\n        }\n    }\n    if (used[v]) len = 0;\n    if (r[v] != -1) {\n        dfs(r[v], used[v], len + 1);\n    }\n}\n\nstring ans;\n\nvoid getAns(int v) {\n    if (l[v] != -1) {\n        getAns(l[v]);\n    }\n    ans.push_back(c[v]);\n    if (used[v]) ans.push_back(c[v]);\n    if (r[v] != -1) getAns(r[v]);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> k;\n    string str;\n    cin >> str;\n    for (int i = 0; i < n; ++i)\n        c[i] = str[i];\n    for (int i = 0; i < n; ++i) {\n        cin >> l[i] >> r[i];\n        --l[i], --r[i];\n    }\n    precalc(0, 0, 0);\n    wow.push_back(char(0));\n    string zz = wow;\n    for (int i = sz(wow) - 2; i > -1; --i) {\n        if (zz[i] == zz[i + 1])\n            wow[i] = wow[i + 1];\n        else\n            wow[i] = zz[i + 1];\n    }\n    init();\n    dfs(0, true, 1);\n    getAns(0);\n    cout << ans;\n    return 0;\n}', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(1e6));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 29; i >= 0; i--) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(1e6);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      long long operations = 0;\n      while (cur) {\n        if (n == 200000 and initial[i] == \'m\') cout << dist(taken, cur) << \'.\';\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \' \' << H;\n  debug_out(T...);\n}\nconst long long MOD = 1e9 + 7;\nconst int N = 2e5 + 1;\nint l[N], r[N], lm[N], p[N][20], nxt[N], dept[N];\nvector<bool> nxtpos(N + 1, 0);\nvector<char> s(N);\nint n, k;\nvoid lmq(int cur) {\n  lm[cur] = cur;\n  if (l[cur] > 0) {\n    dept[l[cur]] = dept[cur] + 1;\n    p[l[cur]][0] = cur;\n    lmq(l[cur]);\n    lm[cur] = lm[l[cur]];\n  }\n  if (r[cur] > 0) {\n    dept[r[cur]] = dept[cur] + 1;\n    p[r[cur]][0] = cur;\n    lmq(r[cur]);\n  }\n}\nvoid setnext(int cur, int rlp) {\n  if (r[cur] > 0) {\n    nxt[cur] = lm[r[cur]];\n    setnext(r[cur], rlp);\n  } else {\n    nxtpos[cur] = 1;\n    nxt[cur] = rlp;\n  }\n  if (l[cur] > 0) setnext(l[cur], cur);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dept[1] = 1;\n  lmq(1);\n  setnext(1, 0);\n  for (int i = 1; i < 20; i++) {\n    for (int j = 1; j <= n; j++) {\n      p[j][i] = p[p[j][i - 1]][i - 1];\n    }\n  }\n  vector<bool> dup(n + 1, 0), ndup(n + 1, 0);\n  int cur = lm[1];\n  while (cur != 0) {\n    if (dup[cur] || ndup[cur]) {\n      cur = nxt[cur];\n      continue;\n    }\n    if (s[cur] < s[nxt[cur]]) {\n      int len = 0, temp = cur, i = 19;\n      bool blocked = false;\n      while (!blocked && p[temp][0] > 0 && !dup[p[temp][0]]) {\n        for (; i >= 0; i--) {\n          if (p[temp][i] > 0 && ndup[p[temp][i]]) {\n            blocked = true;\n            break;\n          }\n          if (p[temp][i] > 0 && !dup[p[temp][i]]) {\n            len += (1 << i);\n            temp = p[temp][i];\n            break;\n          }\n        }\n      }\n      len++;\n      temp = cur;\n      if (!blocked && len <= k) {\n        k -= len;\n        while (len--) {\n          dup[temp] = 1;\n          temp = p[temp][0];\n        }\n      }\n    }\n    if (s[cur] > s[nxt[cur]] && !nxtpos[cur]) {\n      queue<int> q;\n      q.push(cur);\n      while (!q.empty()) {\n        int temp = q.front();\n        q.pop();\n        ndup[temp] = 1;\n        if (l[temp] > 0) {\n          q.push(l[temp]);\n        }\n        if (r[temp] > 0) {\n          q.push(r[temp]);\n        }\n      }\n    }\n    cur = nxt[cur];\n  }\n  int start = lm[1];\n  while (start != 0) {\n    if (dup[start]) {\n      cout << s[start] << s[start];\n    } else {\n      cout << s[start];\n    }\n    start = nxt[start];\n  }\n  cout << "\\n";\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nint SIZE(T(&t)) {\n  return t.size();\n}\ntemplate <typename T, size_t N>\nint SIZE(T (&t)[N]) {\n  return N;\n}\nstring to_string(char t) { return "\'" + string({t}) + "\'"; }\nstring to_string(bool t) { return t ? "true" : "false"; }\nstring to_string(const string& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)), _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += t[i];\n  }\n  return \'"\' + ret + \'"\';\n}\nstring to_string(const char* t) {\n  string ret(t);\n  return to_string(ret);\n}\ntemplate <size_t N>\nstring to_string(const bitset<N>& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)); i <= min(x2, SIZE(t) - 1); ++i) {\n    ret += t[i] + \'0\';\n  }\n  return to_string(ret);\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1 = 0, int x2 = 1e9, Coords... C);\ntemplate <typename T, typename S>\nstring to_string(const pair<T, S>& t) {\n  return "(" + to_string(t.first) + ", " + to_string(t.second) + ")";\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1, int x2, Coords... C) {\n  string ret = "[";\n  x1 = min(x1, SIZE(t));\n  auto e = begin(t);\n  advance(e, x1);\n  for (int i = x1, _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += to_string(*e, C...) + (i != _i ? ", " : "");\n    e = next(e);\n  }\n  return ret + "]";\n}\ntemplate <int Index, typename... Ts>\nstruct print_tuple {\n  string operator()(const tuple<Ts...>& t) {\n    string ret = print_tuple<Index - 1, Ts...>{}(t);\n    ret += (Index ? ", " : "");\n    return ret + to_string(get<Index>(t));\n  }\n};\ntemplate <typename... Ts>\nstruct print_tuple<0, Ts...> {\n  string operator()(const tuple<Ts...>& t) { return to_string(get<0>(t)); }\n};\ntemplate <typename... Ts>\nstring to_string(const tuple<Ts...>& t) {\n  const auto Size = tuple_size<tuple<Ts...>>::value;\n  return print_tuple<Size - 1, Ts...>{}(t);\n}\nvoid dbgr() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgr(Heads H, Tails... T) {\n  cout << to_string(H) << " | ";\n  dbgr(T...);\n}\nvoid dbgs() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgs(Heads H, Tails... T) {\n  cout << H << " ";\n  dbgs(T...);\n}\nconst int N = 2e5 + 5;\nconst long long INF = 1e18 + 7;\nconst int MAXA = 1e9;\nconst int B = sqrt(N) + 5;\nint l[N], r[N], pv[N];\nbool dou[N], ok[N];\nstring s;\ndeque<int> pos[N];\nint n, k;\nvoid dfs(int u) {\n  if (u == 0) return;\n  dfs(l[u]);\n  dfs(r[u]);\n  if (pos[l[u]].size() > pos[r[u]].size()) {\n    swap(pos[u], pos[l[u]]);\n    pos[u].push_back(u);\n    for (int i : pos[r[u]]) {\n      pos[u].push_back(i);\n    }\n    pos[r[u]].clear();\n  } else {\n    swap(pos[u], pos[r[u]]);\n    pos[u].push_front(u);\n    reverse(pos[l[u]].begin(), pos[l[u]].end());\n    for (int i : pos[l[u]]) {\n      pos[u].push_front(i);\n    }\n    pos[l[u]].clear();\n  }\n}\nbool dfs_opt(int u, int h) {\n  bool f = false;\n  if (ok[pv[u]] && k >= h) {\n    k -= h;\n    dou[u] = true;\n    if (l[u]) dfs_opt(l[u], 1);\n    if (r[u]) dfs_opt(r[u], 1);\n    return true;\n  } else {\n    if (l[u]) f |= dfs_opt(l[u], h + 1);\n    if (f) dou[u] = true;\n    if (dou[u] && r[u]) dfs_opt(r[u], h + 1);\n    return dou[u];\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  cin >> s;\n  s = " " + s;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  dfs(1);\n  string first = " ";\n  for (int i : pos[1]) first += s[i];\n  s = first;\n  for (int i = 0; i < n; ++i) pv[pos[1][i]] = i + 1;\n  int l = 1;\n  for (int i = 1; i < n; ++i) {\n    if (s[i] != s[i + 1]) {\n      if (s[i] < s[i + 1]) {\n        for (int j = l; j <= i; ++j) ok[j] = true;\n      }\n      l = i + 1;\n    }\n  }\n  dfs_opt(1, 1);\n  for (int i = 1; i <= n; ++i) {\n    cout << s[i];\n    if (dou[pos[1][i - 1]]) cout << s[i];\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n', '#include <bits/stdc++.h>\n\nconst int N = 1e6 + 50;\n\ninline lowbit(int x) {\n\treturn x & -x;\n}\n\nstruct fenwick_t {\n\tint t[N];\n\tfenwick_t() {\n\t\tmemset(t, 0, sizeof t);\n\t}\n\tinline void add(int p, int v) {\n\t\t++p;\n\t\tfor (; p < N; p += lowbit(p))\n\t\t\tt[p] += v;\n\t}\n\tinline void add(int l, int r, int v) {\n\t\tadd(l, v);\n\t\tadd(r + 1, -v);\n\t}\n\tinline int qry(int p) {\n\t\t++p;\n\t\tint r = 0;\n\t\tfor (; p; p -= lowbit(p))\n\t\t\tr += t[p];\n\t\treturn r;\n\t}\n} T1, T2;\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(nullptr);\n\tstd::cout.tie(nullptr);\n\tint n, k, tot = 0;\n\tstd::cin >> n >> k;\n\tstd::vector<int> l(n + 1), r(n + 1), t(n + 1), fa(n + 1), siz(n + 1), dfn(n + 1), dep(n + 1), a, ban(n + 1);\n\tstd::string s;\n\tstd::cin >> s;\n\ts = "#" + s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::cin >> l[i] >> r[i];\n\t}\n\tstd::function<void(int)> dfs = [&](int x) {\n\t\tsiz[x] = 1;\n\t\tdfn[x] = ++tot;\n\t\tif (l[x]) {\n\t\t\tdep[l[x]] = dep[x] + 1;\n\t\t\tdfs(l[x]);\n\t\t\tfa[l[x]] = x;\n\t\t\tsiz[x] += siz[l[x]];\n\t\t}\n\t\ta.push_back(x);\n\t\tif (r[x]) {\n\t\t\tdep[r[x]] = dep[x] + 1;\n\t\t\tdfs(r[x]);\n\t\t\tfa[r[x]] = x;\n\t\t\tsiz[x] += siz[r[x]];\n\t\t}\n\t};\n\tdep[1] = 1;\n\tdfs(1);\n\tassert(a.size() == n);\n\tstd::vector<int> b(n), lst(n), mp(50, n + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tb[i] = s[a[i]] - \'a\';\n\t}\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tmp[b[i]] = i;\n\t\tint minp = n + 1;\n\t\tfor (int c = 0; c < 26; ++c)\n\t\t\tif (b[i] != c) {\n\t\t\t\tminp = std::min(minp, mp[c]);\n\t\t\t}\n\t\tif (minp == n + 1) {\n\t\t\tlst[i] = -1;\n\t\t}\n\t\telse {\n\t\t\tlst[i] = b[minp];\n\t\t}\n\t}\n\tint rem = k;\n\tfor (int i = 0; i + 1 < n; ++i) {\n\t\tint x = i;\n\t\tif (ban[a[i]]) continue;\n\t\tif (b[i] < lst[i]) {\n\t\t\t// try to select!\n\t\t\tif (T2.qry(a[i]) == 0) {\n\t\t\t\tint xx = a[i];\n\t\t\t\tint cost = dep[xx] - T1.qry(xx);\n\t\t\t\tif (rem >= cost) {\n\t\t\t\t\trem -= cost;\n\t\t\t\t\tint y = xx, total = 0;\n\t\t\t\t\twhile (y && !ban[y]) {\n\t\t\t\t\t\tban[y] = true;\n\t\t\t\t\t\tT1.add(dfn[y], dfn[y] + siz[y] - 1, 1);\n\t\t\t\t\t\t++total;\n\t\t\t\t\t\ty = fa[y];\n\t\t\t\t\t}\n\t\t\t\t\tassert(total == cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ban[a[i]]){\n\t\t\tT2.add(dfn[a[i]], dfn[a[i]] + siz[a[i]] - 1, 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tputchar(\'a\' + b[i]);\n\t\tif (ban[a[i]]) {\n\t\t\tputchar(\'a\' + b[i]);\n\t\t}\n\t}\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200000;\nstruct node {\n  int left;\n  int right;\n};\nstruct node t[N + 5];\nint tot, id[N + 5];\nchar a[N + 5];\nbool col[N + 5];\nchar str[N + 5], dif[N + 5];\nvoid dfs(int place) {\n  if (!place) return;\n  dfs(t[place].left);\n  str[++tot] = a[place];\n  id[place] = tot;\n  dfs(t[place].right);\n}\nint addnum;\nvoid print(int place) {\n  if (!place) return;\n  bool dup = 0;\n  if (col[place] && addnum) {\n    dup = 1;\n    addnum--;\n  }\n  print(t[place].left);\n  printf("%c", a[place]);\n  if (col[place] && dup) printf("%c", a[place]);\n  print(t[place].right);\n}\nint k;\nbool add(int place) {\n  bool ans = 0;\n  if (t[place].left && k > 1) ans = add(t[place].left);\n  if (ans || a[place] < dif[id[place]]) ans = 1;\n  if (!ans) return 0;\n  k--;\n  col[place] = 1;\n  if (t[place].right && k > 1) add(t[place].right);\n  return 1;\n}\nint main() {\n  int n;\n  scanf("%d%d", &n, &k);\n  addnum = k;\n  scanf("%s", a + 1);\n  for (int i = 1; i <= n; i++) scanf("%d%d", &t[i].left, &t[i].right);\n  dfs(1);\n  dif[n] = str[n];\n  for (int i = n - 1; i >= 1; i--) {\n    if (str[i] == str[i + 1])\n      dif[i] = dif[i + 1];\n    else\n      dif[i] = str[i + 1];\n  }\n  add(1);\n  print(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nint n, K, L[200010], R[200010], P[200010][20];\nchar s[200010];\nchar ans[200010], nxt[200010];\nint clk1, cnt[200010], who[200010], idx[200010];\nint clk2, bgn[200010], fin[200010], tree[200010];\nvoid dfs(int sn, int fa) {\n  P[sn][0] = fa;\n  for (int i = 1; i < 20; i++) P[sn][i] = P[P[sn][i - 1]][i - 1];\n  bgn[sn] = ++clk2;\n  if (L[sn]) dfs(L[sn], sn);\n  who[++clk1] = sn;\n  idx[sn] = clk1;\n  ans[clk1] = s[sn];\n  cnt[clk1] = 1;\n  if (R[sn]) dfs(R[sn], sn);\n  fin[sn] = clk2;\n}\nvoid modify(int id, int l, int r, int ql, int qr) {\n  if (ql <= l && r <= qr)\n    tree[id] = true;\n  else {\n    int nxt = id << 1, mid = (l + r) >> 1;\n    if (ql <= mid) modify(nxt, l, mid, ql, qr);\n    if (qr > mid) modify(nxt | 1, mid + 1, r, ql, qr);\n  }\n}\nbool query(int id, int l, int r, int qv) {\n  if (l == r)\n    return tree[id];\n  else if (tree[id])\n    return tree[id];\n  else {\n    int nxt = id << 1, mid = (l + r) >> 1;\n    return qv <= mid ? query(nxt, l, mid, qv) : query(nxt | 1, mid + 1, r, qv);\n  }\n}\nint main() {\n  scanf("%d%d%s", &n, &K, s + 1);\n  for (int i = 1; i <= n; i++) scanf("%d%d", &L[i], &R[i]);\n  dfs(1, 0);\n  for (int i = n; i; i--)\n    nxt[i] = ans[i] == ans[i + 1] ? nxt[i + 1] : ans[i + 1];\n  for (int i = 1; i <= n; i++) {\n    if (cnt[i] == 2) continue;\n    if (ans[i] > nxt[i])\n      modify(1, 1, n, bgn[who[i]], fin[who[i]]);\n    else if (!query(1, 1, n, bgn[who[i]])) {\n      int sm = 0;\n      for (int j = who[i], k = 19; k >= 0; k--)\n        if (P[j][k] && cnt[idx[P[j][k]]] != 2) sm |= 1 << k;\n      if (sm + 1 > K) continue;\n      for (int j = i; j && cnt[j] != 2; j = idx[P[who[j]][0]]) cnt[j] = 2, K--;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= cnt[i]; j++) printf("%c", ans[i]);\n  printf("\\n");\n  return 0;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nlong long MAXN = 2e5 + 10;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  pos.push_back(cur);\n  return f(g[cur].first, g, s) + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(MAXN));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 29; i >= 0; i--) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(MAXN);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  long long operations = 0;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      while (cur and taken[cur] == 0) {\n        assert(operations++ < 1e6);\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define var(...) " [" << #__VA_ARGS__ ": " << (__VA_ARGS__) << "] "\n#define mem(x, n) memset(x, n, sizeof(x))\n#define all(x) x.begin(), x.end()\n#define sz(x) ((int)x.size())\n#define vec vector\n#define endl "\\n"\n\nstruct Node\n{\n\tint l, r, p;\n};\n\nint n, k;\n\nconst int N = 2e5 + 5;\n\nauto level = vec(N + 1, \'.\');\nauto tree = vec(N + 1, Node{});\nauto ids = vec(N + 1, 0);\nauto res = vec(N + 1, string(""));\n\nauto dupli = vec(N + 1, \'.\');\n\nint curr_id = 0;\n\nauto nearest_index = vec(26, deque<int>());\n\nvoid dfs(int s)\n{\n\tif (tree[s].l != 0)\n\t{\n\t\tdfs(tree[s].l);\n\t}\n\n\tcurr_id++;\n\n\tids[s] = curr_id;\n\tnearest_index[level[s] - \'a\'].push_back(curr_id);\n\n\tres[curr_id] = level[s];\n\n\tif (tree[s].r != 0)\n\t{\n\t\tdfs(tree[s].r);\n\t}\n}\n\nauto k_cnt = vec(N + 1, 0);\n\nvoid dfs1(int s, int req, bool can_level)\n{\n\tk_cnt[s] = req;\n\n\tif (tree[s].l != 0)\n\t{\n\t\tdfs1(tree[s].l, req + 1, can_level);\n\t}\n\n\tint id = ids[s];\n\n\tauto check = [&](int j) -> int\n\t{\n\t\tif (sz(nearest_index[j]))\n\t\t{\n\t\t\treturn nearest_index[j].front();\n\t\t}\n\t\treturn -1;\n\t};\n\n\tint greater_id = INT_MAX;\n\tint smaller_id = INT_MAX;\n\n\tfor (int j = 0; j < 26 && can_level; j++)\n\t{\n\t\tint curr = check(j);\n\n\t\tif (curr == -1 || j == level[s] - \'a\')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (j < level[s] - \'a\')\n\t\t{\n\t\t\tsmaller_id = min(smaller_id, curr);\n\t\t}\n\t\telse if (j > level[s] - \'a\')\n\t\t{\n\t\t\tgreater_id = min(greater_id, curr);\n\t\t}\n\t}\n\n\tif (greater_id != smaller_id)\n\t{\n\t\tif (greater_id < smaller_id && k_cnt[s] <= k)\n\t\t{\n\t\t\tint me = s;\n\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (me == 0 || k_cnt[me] == 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk_cnt[me] = 0;\n\t\t\t\tme = tree[me].p;\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tnearest_index[level[s]-\'a\'].pop_back();\n\n\tif (tree[s].r != 0)\n\t{\n\n\t\tdfs1(tree[s].r, k_cnt[s] + 1, k_cnt[s] == 0);\n\t}\n\n\n\tif (k_cnt[s] == 0)\n\t{\n\t\t//cout << var(id) << var(s) << var(greater_id) << var(smaller_id) << endl;\n\t\tres[id] += res[id];\n\t}\n}\n\nvoid run_case([[maybe_unused]] const int &TC)\n{\n\tcin >> n >> k;\n\n\tstring s;\n\tcin >> s;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tlevel[i] = s[i - 1];\n\t}\n\n\ttree[1].p = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> tree[i].l >> tree[i].r;\n\n\t\ttree[tree[i].l].p = i;\n\t\ttree[tree[i].r].p = i;\n\t}\n\n\tdfs(1);\n\n\tdfs1(1, 1, true);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcout << res[i];\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\n\tint t = 1;\n\t//cin >> t;\n\n\tfor (int tc = 1; tc <= t; tc++)\n\t\trun_case(tc);\n\n\treturn 0;\n}', '#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n#include <numeric>\n#include <bitset>\n#include <ext/algorithm>\n#include <ext/numeric>\n#define ffor(_a,_f,_t) for(int _a=(_f),__t=(_t);_a<__t;_a++)\n#define all(_v) (_v).begin() , (_v).end()\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define eb emplace_back\n#define SET(__set, val) memset(__set, val, sizeof(__set))\n#define FOR(__i, __n) ffor (__i, 0, __n)\ntypedef long long LL; using namespace std;\n\nint n, k;\n\nconst int MAXN = 1 << 18;\n\nint G[MAXN][2];\nstring S;\nvector<pair<char, int>> vals;\nint mapToV[MAXN];\nint p[MAXN];\n\nint dfsVals(int v, int idx) {\n\tif (v == -1)\n\t\treturn idx;\n\tint ret = dfsVals(G[v][0], idx);\n\tvals.pb({S[v], ret});\n\tmapToV[ret] = v;\n\tret++;\n\treturn dfsVals(G[v][1], ret);;\n}\n\nbool duplicate[MAXN];\nint valsIdx;\n\nvoid markParents(int v) {\n\tif (v < 0 || duplicate[v])\n\t\treturn;\n\tduplicate[v] = true;\n\tmarkParents(p[v]);\n}\n\nvoid dfsDuplicate(int v, int nonMarkedParents) {\n\tif (v == -1)\n\t\treturn;\n\tdfsDuplicate(G[v][0], nonMarkedParents + 1);\n\n\tint target;\n\twhile (valsIdx < SZ(vals) && duplicate[target = mapToV[vals[valsIdx].second]])\n\t\tvalsIdx++;\n\n\n\tif (valsIdx < SZ(vals) && target == v) {\n\t\tint need = nonMarkedParents + 1;\n\t\tif (need <= k) {\n\t\t\tk -= need;\n\t\t\tmarkParents(v);\n\t\t}\n\t}\n\tif (duplicate[v])\n\t\tdfsDuplicate(G[v][1], 0);\n}\n\nstring Sret;\n\nvoid createSolution(int v) {\n\tif (v < 0)\n\t\treturn;\n\tcreateSolution(G[v][0]);\n\tSret.pb(S[v]);\n\tif (duplicate[v])\n\t\tSret.pb(S[v]);\n\tcreateSolution(G[v][1]);\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(0);\n\t\n\tcin >> n >> k;\n\tcin >> S;\n\tint a, b;\n\tSET(p, 255);\n\tFOR (i, n) {\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tG[i][0] = a;\n\t\tG[i][1] = b;\n\t\tp[a] = p[b] = i;\n\t}\n\t\n\tvals.clear();\n\tdfsVals(0, 0);\n\tsort(all(vals));\n\tif (vals[0].first == vals[SZ(vals) - 1].first) {\n\t\tcout << S << endl;\n\t\treturn 0;\n\t}\n\t\n\tSET(duplicate, 0);\n\tvalsIdx = 0;\n\tdfsDuplicate(0, 0);\n\t\n\tSret = "";\n\tcreateSolution(0);\n\tcout << Sret << endl;\n\t\n\treturn 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, n, m, t, l[200500], r[200500], siz[200500], tp[200500], it,\n    id[200500], dep[200500], sb[200500], fa[200500];\nchar s[200500];\nint q[200500];\nstring res;\nvoid dfs0(int x, int d) {\n  if (!x) return;\n  dep[x] = d;\n  fa[l[x]] = fa[r[x]] = x;\n  dfs0(l[x], d + 1);\n  q[++it] = x;\n  dfs0(r[x], d + 1);\n  siz[x] = 1 + siz[l[x]] + siz[r[x]];\n}\nvoid dfs01(int x, int to) {\n  if (!x) return;\n  tp[x] = to;\n  id[x] = ++it;\n  if (siz[l[x]] >= siz[r[x]]) {\n    dfs01(l[x], to);\n    dfs01(r[x], r[x]);\n  } else {\n    dfs01(r[x], to);\n    dfs01(l[x], l[x]);\n  }\n}\nstruct SB {\n  int f[800500], t[805000];\n  void push(int id, int l, int r) {\n    t[(id << 1)] = t[((id << 1) + 1)] = t[id];\n    f[(id << 1)] = ((t[id] < 1) ? -1000000 : (((l + r) >> 1) - l + 1));\n    f[((id << 1) + 1)] = ((t[id] < 1) ? -1000000 : (r - ((l + r) >> 1)));\n    t[id] = 0;\n  }\n  void ass(int id, int l, int r, int x, int y, int w) {\n    if (x <= l && r <= y) {\n      t[id] = w;\n      f[id] = ((w < 1) ? -1000000 : (r - l + 1));\n      return;\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (x <= ((l + r) >> 1)) ass((id << 1), l, ((l + r) >> 1), x, y, w);\n    if (y > ((l + r) >> 1))\n      ass(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y, w);\n    f[id] = max(-1000000, f[(id << 1)] + f[((id << 1) + 1)]);\n  }\n  int get(int id, int l, int r, int x, int y) {\n    if (x <= l && r <= y) {\n      return f[id];\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (y <= ((l + r) >> 1)) return get((id << 1), l, ((l + r) >> 1), x, y);\n    if (x > ((l + r) >> 1))\n      return get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y);\n    return max(-1000000, get((id << 1), l, ((l + r) >> 1), x, y) +\n                             get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y));\n  }\n} SB;\nvoid hld_ass(int x, int w) {\n  while (x) {\n    SB.ass(1, 1, n, id[tp[x]], id[x], 1);\n    x = fa[tp[x]];\n  }\n}\nint hld_get(int x, int w = 0) {\n  while (x) {\n    w += SB.get(1, 1, n, id[tp[x]], id[x]);\n    w = max(w, -1000000);\n    x = fa[tp[x]];\n  }\n  return w;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> m >> s + 1;\n  for (i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs0(1, 1);\n  it = 0;\n  dfs01(1, 1);\n  for (i = n; i >= 1; i--) {\n    if (s[q[i]] == s[q[i + 1]]) {\n      sb[i] = sb[i + 1];\n    } else {\n      sb[i] = (s[q[i]] < s[q[i + 1]]);\n    }\n  }\n  for (i = 1; i <= n; i++) {\n    res += s[q[i]];\n    if (SB.get(1, 1, n, id[q[i]], id[q[i]])) {\n      res += s[q[i]];\n      continue;\n    }\n    if (sb[i]) {\n      k = hld_get(q[i]);\n      if (k + m >= dep[q[i]]) {\n        res += s[q[i]];\n        m -= (dep[q[i]] - k);\n        hld_ass(q[i], 1);\n      }\n    } else {\n      SB.ass(1, 1, n, id[q[i]], id[q[i]], -1000000);\n    }\n  }\n  res += s[q[n]];\n  cout << res;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int N, K;\n  string S;\n  cin >> N >> K >> S;\n  vector<int> L(N), R(N);\n  for (int i = 0; i < N; ++i) {\n    cin >> L[i] >> R[i];\n    --L[i], --R[i];\n  }\n  vector<int> r;\n  function<void(int)> Pre = [&](int v) {\n    if (v == -1) {\n      return;\n    }\n    Pre(L[v]);\n    r.push_back(v);\n    Pre(R[v]);\n  };\n  Pre(0);\n  string next(N, '*');\n  for (int i = N - 2; i >= 0; --i) {\n    next[r[i]] = (S[r[i + 1]] == S[r[i]] ? next : S)[i + 1];\n  }\n  void(37);\n  vector<int> need(N, 1);\n  vector<int> vis(N);\n  function<void(int)> Dfs = [&](int v) {\n    if (L[v] != -1) {\n      need[L[v]] = need[v] + 1;\n      Dfs(L[v]);\n      vis[v] |= vis[L[v]];\n    }\n    if (!vis[v] && need[v] <= K && next[v] > S[v]) {\n      vis[v] = true;\n      K -= need[v];\n    }\n    if (vis[v] && R[v] != -1) {\n      Dfs(R[v]);\n    }\n  };\n  Dfs(0);\n  string res;\n  for (auto v : r) {\n    res += string(1 + vis[v], S[v]);\n  }\n  cout << res << '\\n';\n}\n", '#include <bits/stdc++.h>\nlong getbit(long first, long second) { return ((first >> second) & 1); }\nusing namespace std;\nconst long N = 2e5 + 5;\nlong cnt, n, k, l[N], r[N], h[N];\nchar c[N];\nstring s;\nvector<long> so;\nbool dd[N], Next[N];\nvoid tao(long u, long pa) {\n  h[u] = h[pa] + 1;\n  if (l[u] != 0) tao(l[u], u);\n  s += c[u];\n  so.push_back(u);\n  if (r[u] != 0) tao(r[u], u);\n}\nvoid dfs(long u, long last) {\n  if (l[u] != 0) {\n    if (Next[l[u]] && cnt + h[l[u]] - h[last] <= k) {\n      dd[l[u]] = 1;\n      cnt += h[l[u]] - h[last];\n      last = u;\n      dfs(l[u], l[u]);\n    } else\n      dfs(l[u], last);\n  }\n  if ((last == u || Next[u]) && cnt + h[u] - h[last] <= k) {\n    dd[u] = 1;\n    cnt += h[u] - h[last];\n    if (r[u] != 0) dfs(r[u], u);\n  }\n}\nvoid dfs1(long u) {\n  if (l[u] != 0) {\n    dfs1(l[u]);\n    dd[u] |= dd[l[u]];\n  }\n  if (r[u] != 0) {\n    dfs1(r[u]);\n    dd[u] |= dd[r[u]];\n  }\n}\nvoid tao1(long u) {\n  if (l[u] != 0) tao1(l[u]);\n  if (dd[u])\n    s += c[u], s += c[u];\n  else\n    s += c[u];\n  if (r[u] != 0) tao1(r[u]);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long i = 1; i <= n; i++) cin >> c[i];\n  for (long i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  s = "";\n  tao(1, 0);\n  for (long i = (long)s.size() - 1; i >= 0; i--)\n    if (i == (long)s.size() - 1)\n      Next[so[i]] = 0;\n    else if (s[i] < s[i + 1])\n      Next[so[i]] = 1;\n    else if (s[i] == s[i + 1])\n      Next[so[i]] = Next[so[i + 1]];\n    else\n      Next[so[i]] = 0;\n  dfs(1, 0);\n  dfs1(1);\n  s = "";\n  tao1(1);\n  cout << s << \'\\n\';\n  return 0;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(1e6));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1 << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 0; i < int(30); ++i) {\n    if (jump[i][cur] != root) {\n      ans += 1 << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(1e6);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  for (int i = 0; i < int(3); ++i) {\n    cerr << "i: " << i << endl;\n    for (int a = 0; a < int(n); ++a) cerr << jump[i][a] << " ";\n    cerr << endl;\n  }\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  cerr << initial << endl;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (dist(taken, cur) <= k) {\n      cerr << "took " << initial[i] << " " << i << " " << dist(taken, cur)\n           << endl;\n      k -= dist(taken, cur);\n      while (cur) {\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    } else\n      cerr << "didin\'t take " << initial[i] << " " << i << " "\n           << dist(taken, cur) << " becuase k was " << k << endl;\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \' \' << H;\n  debug_out(T...);\n}\nconst long long MOD = 1e9 + 7;\nconst int N = 2e5 + 1;\nint l[N], r[N], lm[N], p[N][20], nxt[N], dept[N];\nvector<char> s(N);\nint n, k;\nvoid lmq(int cur) {\n  lm[cur] = cur;\n  if (l[cur] > 0) {\n    dept[l[cur]] = dept[cur] + 1;\n    p[l[cur]][0] = cur;\n    lmq(l[cur]);\n    lm[cur] = lm[l[cur]];\n  }\n  if (r[cur] > 0) {\n    dept[r[cur]] = dept[cur] + 1;\n    p[r[cur]][0] = cur;\n    lmq(r[cur]);\n  }\n}\nvoid setnext(int cur, int rlp) {\n  if (r[cur] > 0) {\n    nxt[cur] = lm[r[cur]];\n    setnext(r[cur], rlp);\n  } else {\n    nxt[cur] = rlp;\n  }\n  if (l[cur] > 0) setnext(l[cur], cur);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dept[1] = 1;\n  lmq(1);\n  setnext(1, 0);\n  for (int i = 1; i < 20; i++) {\n    for (int j = 1; j <= n; j++) {\n      p[j][i] = p[p[j][i - 1]][i - 1];\n    }\n  }\n  vector<bool> dup(n + 1, 0), ndup(n + 1, 0);\n  int cur = lm[1];\n  while (cur != 0) {\n    if (dup[cur]) {\n      cur = nxt[cur];\n      continue;\n    }\n    if (s[cur] < s[nxt[cur]]) {\n      int len = 0, temp = cur, i = 19;\n      bool blocked = false;\n      while (!blocked && p[temp][0] > 0 && !dup[p[temp][0]]) {\n        for (; i >= 0; i--) {\n          if (p[temp][i] > 0 && ndup[p[temp][i]]) {\n            blocked = true;\n            break;\n          }\n          if (p[temp][i] > 0 && !dup[p[temp][i]]) {\n            len += (1 << i);\n            temp = p[temp][i];\n            break;\n          }\n        }\n      }\n      len++;\n      temp = cur;\n      if (!blocked && len <= k) {\n        k -= len;\n        while (len--) {\n          dup[temp] = 1;\n          temp = p[temp][0];\n        }\n      }\n    } else {\n      int temp = cur;\n      while (temp > 0 && !ndup[temp] && !dup[temp]) {\n        ndup[temp] = 1;\n        temp = p[temp][0];\n      }\n    }\n    cur = nxt[cur];\n  }\n  int start = lm[1];\n  while (start != 0) {\n    if (dup[start]) {\n      cout << s[start] << s[start];\n    } else {\n      cout << s[start];\n    }\n    start = nxt[start];\n  }\n  cout << "\\n";\n  return 0;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(1e6));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1 << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 0; i < int(30); ++i) {\n    if (jump[i][cur] != root) {\n      ans += 1 << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(1e6);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      long long operations = 0;\n      while (cur) {\n        assert(++operations < 1e7);\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint l[200005], r[200005];\nchar m[200005], nxt[200005];\nstring s, t;\nstring res;\nvector<int> v;\nvoid dfs1(int u) {\n  if (!u) return;\n  dfs1(l[u]);\n  t += s[u];\n  v.push_back(u);\n  dfs1(r[u]);\n}\nvoid dfs(int u, int h) {\n  int k0 = k;\n  if (l[u]) {\n    dfs(l[u], h - 1);\n  }\n  bool smaller = false;\n  if (nxt[u] && (s[u] < nxt[u] || (s[u] == nxt[u] && s[u] < m[u]))) {\n    smaller = true;\n  }\n  if (h > 0 && (k != k0 || smaller)) {\n    k--;\n    res += s[u];\n    res += s[u];\n  } else {\n    res += s[u];\n  }\n  if (r[u]) {\n    if (h > 0 && (k != k0 || smaller))\n      dfs(r[u], k);\n    else\n      dfs(r[u], 0);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> n >> k;\n  cin >> s;\n  s = '#' + s;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs1(1);\n  char cur = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    m[v[i]] = cur;\n    cur = max(cur, t[i]);\n    if (i != n - 1) nxt[v[i]] = t[i + 1];\n  }\n  dfs(1, k);\n  cout << res << endl;\n  return 0;\n}\n", '\'\'\' E. Middle Duplication\nhttps://codeforces.com/contest/1623/problem/E\n\'\'\'\n\nimport io, os, sys\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n\nDEBUG = os.environ.get(\'debug\') is not None\n\nif DEBUG:\n    from inspect import currentframe, getframeinfo\n    from re import search\n\ndef debug(*args):\n    if not DEBUG: return\n    frame = currentframe().f_back\n    s = getframeinfo(frame).code_context[0]\n    r = search(r"\\((.*)\\)", s).group(1)\n    vnames = r.split(\', \')\n    var_and_vals = [f\'{var}={val}\' for var, val in zip(vnames, args)]\n    prefix = f\'{currentframe().f_back.f_lineno:02d}: \'\n    print(f\'{prefix}{", ".join(var_and_vals)}\')\n\n\nINF = float(\'inf\')\n\n# -----------------------------------------\n\ndef main():\n    N, K = list(map(int, input().split()))\n    S = input().decode().strip()\n\n    L, R = [-1]*N, [-1]*N\n    for p in range(N):\n        l, r = map(int, input().split())\n        L[p], R[p] = l-1, r-1\n\n    # inorder\n    inorder = []\n    def dfs1(u):\n        if L[u] > -1: dfs1(L[u])\n        inorder.append(u)\n        if R[u] > -1: dfs1(R[u])\n    dfs1(0)\n\n    # can duplicate if next different node exists and is greater\n    good = [False]*N\n    last = \'\'\n    for i in range(N-2, -1, -1):\n        u, v = inorder[i], inorder[i+1]\n        if S[u] != S[v]: last = S[v]\n        if S[u] < last: good[u] = True\n\n    # greedily duplicate following inorder \n    # cost = cost if duplicate u; equals distance from u to nearest dup ancestor\n    dup = [False]*N\n    def dfs2(u, cost=1):\n        nonlocal K\n        if u == -1: return\n        if cost > K: return\n\n        # dup leftmost possible descendant\n        dfs2(L[u], cost+1)\n\n        # left child dup; alr counted cost to dup u\n        if dup[L[u]]: \n            dup[u] = True\n\n        # left subtree undup, u dup; subtract cost to dup u and its undup ancestors\n        elif good[u]:\n            dup[u] = True\n            K -= cost\n        \n        # can only dup right subtree if u dup\n        if dup[u]: dfs2(R[u], 1)\n\n    dfs2(0)\n\n    # output\n    print(\'\'.join(S[u]*2 if dup[u] else S[u] for u in inorder))\n\n\nif __name__ == \'__main__\':\n    main()\n\n', '#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n#include <numeric>\n#include <bitset>\n#include <ext/algorithm>\n#include <ext/numeric>\n#define ffor(_a,_f,_t) for(int _a=(_f),__t=(_t);_a<__t;_a++)\n#define all(_v) (_v).begin() , (_v).end()\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define eb emplace_back\n#define SET(__set, val) memset(__set, val, sizeof(__set))\n#define FOR(__i, __n) ffor (__i, 0, __n)\ntypedef long long LL; using namespace std;\n\nint n, k;\n\nconst int MAXN = 1 << 18;\n\nint G[MAXN][2];\nstring S;\nvector<pair<char, int>> vals;\nint p[MAXN];\nbool attempt[MAXN];\n\nvoid dfsVals(int v) {\n\tif (v == -1)\n\t\treturn;\n\tdfsVals(G[v][0]);\n\tvals.pb({S[v], v});\n\tdfsVals(G[v][1]);;\n}\n\nbool duplicate[MAXN];\nint valsIdx;\n\nvoid markParents(int v) {\n\tif (v < 0 || duplicate[v])\n\t\treturn;\n\tduplicate[v] = true;\n\tmarkParents(p[v]);\n}\n\nvoid dfsDuplicate(int v, int nonMarkedParents) {\n\tif (v == -1)\n\t\treturn;\n\tdfsDuplicate(G[v][0], nonMarkedParents + 1);\n\n\tif (attempt[v]) {\n\t\tint need = nonMarkedParents + 1;\n\t\tif (need <= k) {\n\t\t\tk -= need;\n\t\t\tmarkParents(v);\n\t\t}\n\t}\n\tif (duplicate[v])\n\t\tdfsDuplicate(G[v][1], 0);\n}\n\nstring Sret;\n\nvoid createSolution(int v) {\n\tif (v < 0)\n\t\treturn;\n\tcreateSolution(G[v][0]);\n\tSret.pb(S[v]);\n\tif (duplicate[v])\n\t\tSret.pb(S[v]);\n\tcreateSolution(G[v][1]);\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(0);\n\t\n\tcin >> n >> k;\n\tcin >> S;\n\tint a, b;\n\tSET(p, 255);\n\tFOR (i, n) {\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tG[i][0] = a;\n\t\tG[i][1] = b;\n\t\tp[a] = p[b] = i;\n\t}\n\t\n\tvals.clear();\n\tdfsVals(0);\n\tSET(attempt, 0);\n\tfor (int i = n - 2; i > -1; i--)\n\t\tif (vals[i].first < vals[i + 1].first || (vals[i].first == vals[i + 1].first && attempt[vals[i + 1].second]))\n\t\t\tattempt[vals[i].second] = true;\n\n\tSET(duplicate, 0);\n\tdfsDuplicate(0, 0);\n\t\n\tSret = "";\n\tcreateSolution(0);\n\tcout << Sret << endl;\n\t\n\treturn 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint l[200005], r[200005];\nchar s[200005];\nchar ss[200005];\nint pos[200005];\nint ok[200005];\nint nn;\nvoid dfs(int i) {\n  if (i == 0) return;\n  dfs(l[i]);\n  pos[nn] = i;\n  ss[nn++] = s[i];\n  dfs(r[i]);\n}\nint k;\nint dfs2(int i, int now) {\n  if (i == 0) return 0;\n  if (dfs2(l[i], now + 1) == 1) {\n    ss[nn++] = s[i];\n    ss[nn++] = s[i];\n    dfs2(r[i], 1);\n    return 1;\n  } else if (ok[i] == 0) {\n    ss[nn++] = s[i];\n    dfs(r[i]);\n    return 0;\n  } else {\n    ss[nn++] = s[i];\n    if (now <= k) {\n      k -= now;\n      ss[nn++] = s[i];\n      dfs2(r[i], 1);\n      return 1;\n    } else {\n      dfs(r[i]);\n      return 0;\n    }\n  }\n}\nint main() {\n  int n;\n  cin >> n >> k;\n  cin >> (s + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", l + i, r + i);\n  }\n  dfs(1);\n  {\n    int i = n - 1;\n    char last = ss[n - 1];\n    while (ss[i] == ss[n - 1] && i >= 0) i--;\n    for (; i >= 0; i--) {\n      if (ss[i] == ss[i + 1]) {\n      } else {\n        last = ss[i + 1];\n      }\n      if (ss[i] < last) ok[pos[i]] = 1;\n    }\n  }\n  nn = 0;\n  dfs2(1, 1);\n  cout << ss << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define var(...) " [" << #__VA_ARGS__ ": " << (__VA_ARGS__) << "] "\n#define mem(x, n) memset(x, n, sizeof(x))\n#define all(x) x.begin(), x.end()\n#define sz(x) ((int)x.size())\n#define vec vector\n#define endl "\\n"\n\nstruct Node\n{\n\tint l, r, p;\n};\n\nint n, k;\n\nconst int N = 2e5 + 5;\n\nauto level = vec(N + 1, \'.\');\nauto tree = vec(N + 1, Node{});\nauto ids = vec(N + 1, 0);\nauto res = vec(N + 1, string(""));\n\nauto dupli = vec(N + 1, \'.\');\n\nint curr_id = 0;\n\nauto nearest_index = vec(26, deque<int>());\n\nvoid dfs(int s)\n{\n\tif (tree[s].l != 0)\n\t{\n\t\tdfs(tree[s].l);\n\t}\n\n\tcurr_id++;\n\n\tids[s] = curr_id;\n\tnearest_index[level[s] - \'a\'].push_back(curr_id);\n\n\tres[curr_id] = level[s];\n\n\tif (tree[s].r != 0)\n\t{\n\t\tdfs(tree[s].r);\n\t}\n}\n\nauto k_cnt = vec(N + 1, 0);\n\nvoid dfs1(int s, int req, bool can_level)\n{\n\tk_cnt[s] = req;\n\n\tif (tree[s].l != 0)\n\t{\n\t\tdfs1(tree[s].l, req + 1, can_level);\n\t}\n\n\tint id = ids[s];\n\n\tauto check = [&](int j) -> int\n\t{\n\t\tif (sz(nearest_index[j]))\n\t\t{\n\t\t\treturn nearest_index[j].front();\n\t\t}\n\t\treturn -1;\n\t};\n\n\tint greater_id = INT_MAX;\n\tint smaller_id = INT_MAX;\n\n\tfor (int j = 0; j < 26 && can_level; j++)\n\t{\n\t\tint curr = check(j);\n\n\t\tif (curr == -1 || j == level[s] - \'a\')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (j < level[s] - \'a\')\n\t\t{\n\t\t\tsmaller_id = min(smaller_id, curr);\n\t\t}\n\t\telse if (j > level[s] - \'a\')\n\t\t{\n\t\t\tgreater_id = min(greater_id, curr);\n\t\t}\n\t}\n\n\tif (greater_id != smaller_id)\n\t{\n\t\tif (greater_id < smaller_id && k_cnt[s] <= k)\n\t\t{\n\t\t\tint me = s;\n\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (me == 0 || k_cnt[me] == 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk_cnt[me] = 0;\n\t\t\t\tme = tree[me].p;\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tree[s].r != 0)\n\t{\n\n\t\tdfs1(tree[s].r, k_cnt[s] + 1, k_cnt[s] == 0);\n\t}\n\n\tnearest_index[level[s]-\'a\'].pop_back();\n\n\tif (k_cnt[s] == 0)\n\t{\n\t\t//cout << var(id) << var(s) << var(greater_id) << var(smaller_id) << endl;\n\t\tres[id] += res[id];\n\t}\n}\n\nvoid run_case([[maybe_unused]] const int &TC)\n{\n\tcin >> n >> k;\n\n\tstring s;\n\tcin >> s;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tlevel[i] = s[i - 1];\n\t}\n\n\ttree[1].p = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> tree[i].l >> tree[i].r;\n\n\t\ttree[tree[i].l].p = i;\n\t\ttree[tree[i].r].p = i;\n\t}\n\n\tdfs(1);\n\n\tdfs1(1, 1, true);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcout << res[i];\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\n\tint t = 1;\n\t//cin >> t;\n\n\tfor (int tc = 1; tc <= t; tc++)\n\t\trun_case(tc);\n\n\treturn 0;\n}', "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint l[200005], r[200005];\nchar m[200005];\nstring s;\nstring res;\nvoid dfs1(int u) {\n  m[u] = s[u];\n  if (l[u]) {\n    dfs1(l[u]);\n    m[u] = max(m[u], m[l[u]]);\n  }\n  if (r[u]) {\n    dfs1(r[u]);\n    m[u] = max(m[u], m[r[u]]);\n  }\n}\nvoid dfs(int u, int h) {\n  int k0 = k;\n  if (l[u]) {\n    dfs(l[u], h - 1);\n  }\n  bool smaller = false;\n  if (r[u] && (s[u] < s[r[u]] || (s[u] == s[r[u]] && s[u] < m[r[u]]))) {\n    smaller = true;\n  }\n  if (h > 0 && (k != k0 || smaller)) {\n    k--;\n    res += s[u];\n    res += s[u];\n  } else {\n    res += s[u];\n  }\n  if (r[u]) {\n    if (smaller)\n      dfs(r[u], k);\n    else\n      dfs(r[u], 0);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> n >> k;\n  cin >> s;\n  s = '#' + s;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs1(1);\n  dfs(1, k);\n  cout << res << endl;\n  return 0;\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nint l[200005], r[200005];\nint fa[200005][20];\nchar s[200005];\nchar ss[200005];\nint pos[200005];\nint ok[200005];\nint re[200005];\nint nn;\nvoid dfs(int i) {\n  if (i == 0) return;\n  dfs(l[i]);\n  pos[nn] = i;\n  ss[nn++] = s[i];\n  dfs(r[i]);\n}\nvoid dfs2(int i) {\n  if (i == 0) return;\n  dfs(l[i]);\n  if (re[i]) ss[nn++] = s[i];\n  ss[nn++] = s[i];\n  dfs(r[i]);\n}\nint main() {\n  int n, k;\n  cin >> n >> k;\n  cin >> (s + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", l + i, r + i);\n    if (l[i]) fa[l[i]][0] = i;\n    if (r[i]) fa[r[i]][0] = i;\n  }\n  for (int j = 1; j < 20; j++)\n    for (int i = 1; i <= n; i++) {\n      fa[i][j] = fa[fa[i][j - 1]][j - 1];\n    }\n  dfs(1);\n  {\n    int i = n - 1;\n    char last = ss[n - 1];\n    while (ss[i] == ss[n - 1] && i >= 0) i--;\n    for (; i >= 0; i--) {\n      if (ss[i] == ss[i + 1]) {\n      } else {\n        last = ss[i + 1];\n      }\n      if (ss[i] < last) ok[i] = 1;\n    }\n  }\n  for (int i = 0; i < n; i++)\n    if (ok[i]) {\n      int now = pos[i];\n      int num = 1;\n      for (int j = 19; j >= 0; j--) {\n        if (fa[now][j] != 0 && re[fa[now][j]] != 1) {\n          now = fa[now][j];\n          num += (1 << j);\n        }\n      }\n      if (num <= k) {\n        k -= num;\n        re[now] = 1;\n        cout << "ok" << endl;\n        for (int ii = pos[i]; ii != now; ii = fa[ii][0]) {\n          re[ii] = 1;\n        }\n      }\n    }\n  nn = 0;\n  dfs2(1);\n  cout << ss << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\n#if __cplusplus > 201703L\n#include <ranges>\nusing namespace numbers;\n#endif\n\ntemplate<class F>\nstruct y_combinator_result{\n\tF f;\n\ttemplate<class T> explicit y_combinator_result(T &&f): f(forward<T>(f)){ }\n\ttemplate<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }\n};\ntemplate<class F>\ndecltype(auto) y_combinator(F &&f){\n\treturn y_combinator_result<decay_t<F>>(forward<F>(f));\n}\n\n\n\nint main(){\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\tint n, th;\n\tstring init;\n\tcin >> n >> th >> init;\n\tvector<string> res(n);\n\tfor(auto u = 0; u < n; ++ u){\n\t\tres[u] = {init[u]};\n\t}\n\tvector<array<int, 2>> adj(n);\n\tfor(auto &[u, v]: adj){\n\t\tcin >> u >> v, -- u, -- v;\n\t}\n\tvector<int> order;\n\ty_combinator([&](auto self, int u)->void{\n\t\tif(!~u){\n\t\t\treturn;\n\t\t}\n\t\tself(adj[u][0]);\n\t\torder.push_back(u);\n\t\tself(adj[u][1]);\n\t})(0);\n\tvector<int> prefer(n);\n\tfor(auto l = 0; l < n; ){\n\t\tint r = l;\n\t\twhile(r < n && init[order[l]] == init[order[r]]){\n\t\t\t++ r;\n\t\t}\n\t\tif(r < n && init[order[l]] < init[order[r]]){\n\t\t\tfor(auto u: order | ranges::views::take(r) | ranges::views::drop(l)){\n\t\t\t\tprefer[u] = true;\n\t\t\t}\n\t\t}\n\t\tl = r;\n\t}\n\ty_combinator([&](auto self, int u)->void{\n\t\tif(!~u){\n\t\t\treturn;\n\t\t}\n\t\tvector<int> path;\n\t\twhile(~u && (int)size(path) < th){\n\t\t\tpath.push_back(u);\n\t\t\tu = adj[u][0];\n\t\t}\n\t\twhile(!empty(path) && !prefer[path.back()]){\n\t\t\tpath.pop_back();\n\t\t}\n\t\tth -= (int)size(path);\n\t\tfor(auto u: path){\n\t\t\tres[u] += res[u];\n\t\t\tself(adj[u][1]);\n\t\t}\n\t})(0);\n\tfor(auto u: order){\n\t\tcout << res[u];\n\t}\n\tcout << "\\n";\n\treturn 0;\n}\n\n/*\n\n*/\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n//                                   Coded by Aeren                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nint n, k, ls[N], rs[N], nxt[N], cost[N];\nstring cc, ss = "$", res = "";\nvector<int> order = {0};\nbool good[N], vis[N];\nvoid dfs1(int v) {\n  if (ls[v]) dfs1(ls[v]);\n  ss += string(1, cc[v]);\n  order.push_back(v);\n  if (rs[v]) dfs1(rs[v]);\n}\nvoid dfs2(int v) {\n  if (cost[v] > k) return;\n  if (ls[v]) cost[ls[v]] = cost[v] + 1, dfs2(ls[v]);\n  if ((ls[v] && vis[ls[v]]) || good[v]) vis[v] = 1, k -= cost[v];\n  if (rs[v] && vis[v]) cost[rs[v]] = 1, dfs2(rs[v]);\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n >> k;\n  cin >> cc;\n  cc = "$" + cc;\n  for (int i = 1; i <= n; ++i) cin >> ls[i] >> rs[i];\n  dfs1(1);\n  nxt[n] = n + 1;\n  for (int i = n - 1; i >= 1; --i) {\n    if (ss[i] != ss[i + 1])\n      nxt[i] = i + 1;\n    else\n      nxt[i] = nxt[i + 1];\n  }\n  for (int i = 1; i <= n; ++i)\n    good[order[i]] = (nxt[i] != n + 1 && ss[i] < ss[nxt[i]]);\n  cost[1] = 1;\n  dfs2(1);\n  for (int i = 1; i <= n; ++i) res += string(vis[order[i]] ? 2 : 1, ss[i]);\n  cout << res << \'\\n\';\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint32_t main() {\n  cin.tie(0)->sync_with_stdio(0);\n  long long n, k;\n  string s;\n  cin >> n >> k >> s;\n  vector<long long> l(n), r(n), val(n), d(n, 0), in;\n  for (long long i = 0; i < n; i++) {\n    cin >> l[i] >> r[i];\n    --l[i], --r[i];\n  }\n  function<void(long long)> dfs = [&](long long v) {\n    if (v == -1) return;\n    dfs(l[v]);\n    in.push_back(v);\n    dfs(r[v]);\n  };\n  dfs(0);\n  val[in.back()] = 0;\n  for (long long i = n - 2; i >= 0; i--) {\n    if (s[in[i]] == s[in[i + 1]])\n      val[in[i]] = val[in[i + 1]];\n    else if (s[in[i]] < s[in[i + 1]])\n      val[in[i]] = 1;\n    else\n      val[in[i]] = -1;\n  }\n  function<long long(long long, long long)> dfs2 = [&](long long v,\n                                                       long long t) {\n    if (v == -1 or t == 0) return 0ll;\n    long long x = dfs2(l[v], t - 1);\n    if (val[v] == 1 or x) x++;\n    if (x) d[v] = 1;\n    long long rem = t - x;\n    if (!d[v]) rem = 0;\n    dfs2(r[v], rem);\n    return x;\n  };\n  dfs2(0, k);\n  for (auto i : in) {\n    cout << s[i];\n    if (d[i]) cout << s[i];\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename A,typename B>\nstring to_string(pair<A,B>p){return"("+to_string(p.first)+", "+to_string(p.second)+")";}\ntemplate<typename A,typename B,typename C>\nstring to_string(tuple<A,B,C>p){return"("+to_string(get<0>(p))+", "+to_string(get<1>(p))+", "+to_string(get<2>(p))+")";}\ntemplate<typename A,typename B,typename C,typename D>\nstring to_string(tuple<A,B,C,D>p){return"("+to_string(get<0>(p))+", "+to_string(get<1>(p))+", "+to_string(get<2>(p))+", "+to_string(get<3>(p))+")";}\nstring to_string(const string &s){return\'"\'+s+\'"\';}\nstring to_string(const char *s){return to_string((string)s);}\nstring to_string(bool b){return(b?"true":"false");}\nstring to_string(vector<bool>v){int f=0;string r="{";for(bool i:v)r+=(f++?",":"")+to_string(i);r+="}";return r;}\ntemplate<size_t N>\nstring to_string(bitset<N>v){string res="";for(size_t i=0;i<N;res+=char(\'0\'+v[i++]));return res;}\ntemplate<typename A>\nstring to_string(A v){int f=0;string r="{";for(auto&i:v)r+=(f++?",":"")+to_string(i);r+="}";return r;}\nvoid debug_out(){cerr<<\']\'<<endl;}\ntemplate<typename Head,typename...Tail>\nvoid debug_out(Head H,Tail...T){cerr<<to_string(H);if(sizeof...(T))cerr<<", ";debug_out(T...);}\n#ifdef LOCAL\n#define debug(x...) cerr << "[" << (#x) << "] = [", debug_out(x)\n#else\n#define debug(x...) 33\n#endif\n#define int long long\nint N, K;\nchar S[200\'200];\nvector<int> g[200\'200];\nint par[200\'200];\nint dep[200\'200];\n\nvector<int> dfsOrder;\nint dfsN[200\'200];\nvoid dfs(int now)\n{\n\t\n\tfor (int i = 0; i < 2; ++i)\n\t{\n\t\tint it = g[now][i];\n\t\tif (it != -1) \n\t\t{\n\t\t\tdep[it] = dep[now] + 1;\n\t\t\tdfs(it);\n\t\t}\n\t\tif (!i)\n\t\t{\n            dfsN[now] = (int)dfsOrder.size();\n            dfsOrder.push_back(now);\n        }\n\t}\n\t// for (auto &it: g[now]) \n\t// {\n\t// \tif (it != -1) \n\t// \t{\n\t// \t\tdep[it] = dep[now] + 1;\n\t// \t\tdfs(it);\n\t// \t}\n\t// }\n}\nint nextNode[200\'200];\nbool go_dup[200\'200];\nint NodeNode[200\'200];\n\nbool real_iduc[200\'200];\nint for_who_dfsN[200\'200];\nvoid dfs2(int now)\n{\n\tfor (auto &it: g[now]) \n\t{\n\t\tif (it != -1) dfs2(it);\n\t}\n\treal_iduc[now] = go_dup[now];\n\tif (go_dup[now])\n\t{\n\t\tfor_who_dfsN[now] = dfsN[now];\n\t}\n\tif (g[now][0] != -1)\n\t{\n\t\treal_iduc[now] |= real_iduc[g[now][0]];\n\n\t\tif (real_iduc[g[now][0]])\n\t\t{\n\t\t\tfor_who_dfsN[now] = for_who_dfsN[g[now][0]];\n\t\t}\n\t}\n}\nvoid dfs3(int now, int reallll)\n{\n\treal_iduc[now] = real_iduc[now] && reallll;\n\tfor (auto &it: g[now])\n\t{\n\t\tif (it != -1) dfs3(it, reallll && real_iduc[now]);\n\t}\n}\nint really_dup[200\'200];\nsigned main()\n{\n    cin.tie(0)->sync_with_stdio(false);\n\tcin >> N >> K;\n\tcin >> S;\n\tpar[0] = -1;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tint u, v; cin >> u >> v; --u, --v;\n\n\t\tg[i].push_back(u);\n\t\tg[i].push_back(v);\n\t\t\n\t\tpar[u] = par[v] = i;\n\t}\n\tdfs(0);\n\t// debug(dfsOrder);\n\tmemset(nextNode, -1, sizeof nextNode);\n\tfor (int x = 0; x + 1 < (int)dfsOrder.size(); ++x)\n\t{\n\t\tnextNode[dfsOrder[x]] = dfsOrder[x + 1];\n\t}\n\n\tfor (int i = 0, j = 0; i < (int)dfsOrder.size(); ++i)\n\t{\n\t\twhile(j < (int)dfsOrder.size() && S[dfsOrder[i]] == S[dfsOrder[j]])\n\t\t\t++j;\n\t\tif (j == (int)dfsOrder.size())\n\t\t{\n\t\t\tNodeNode[dfsOrder[i]] = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNodeNode[dfsOrder[i]] = dfsOrder[j];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (NodeNode[i] == -1) go_dup[i] =false;\n\t\telse\n\t\t{\n\t\t\tassert(S[i] != S[NodeNode[i]]);\n\n\t\t\tif (S[i] > S[NodeNode[i]]) go_dup[i] = false;\n\t\t\telse go_dup[i] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (dep[i] >= K)\n\t\t{\n\t\t\tgo_dup[i] = false;\n\t\t}\n\t}\n\tdfs2(0);\n\tdfs3(0, 1);\n\tvector<pair<int, int>> omy;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (real_iduc[i])\n\t\t{\n\t\t\tomy.push_back({for_who_dfsN[i], i});\n\t\t}\n\t}\n\tsort(omy.begin(), omy.end());\n\tfor (int i = 0; i < K && i < (int)omy.size(); ++i)\n\t{\n\t\treally_dup[omy[i].second] = true;\n\t}\n\n\tfor (auto &it: dfsOrder)\n\t{\n\t\tcout << S[it];\n\n\t\tif (really_dup[it]) cout << S[it];\n\t}\n\tcout << \'\\n\';\n\n    return 0;\n}', '#include <bits/stdc++.h>\nusing namespace std;\nconst int w = 200010;\nint n, k;\nstring s;\nint l[w], r[w];\nbool good[w];\nbool cpy[w];\nvector<int> vec;\nvoid build(int u) {\n  if (l[u]) build(l[u]);\n  vec.push_back(u);\n  if (r[u]) build(r[u]);\n}\nvoid dfs(int u, int cnt) {\n  if (cnt > k) return;\n  if (l[u]) dfs(l[u], cnt + 1);\n  if (cpy[l[u]]) {\n    cpy[u] = true;\n  } else if (good[u]) {\n    cpy[u] = true;\n    k -= cnt;\n  }\n  if (cpy[u] && r[u]) dfs(r[u], 1);\n}\nint main() {\n  cin >> n >> k;\n  cin >> s;\n  s = \' \' + s;\n  for (int i = 1; i <= n; i++) {\n    int a, b;\n    scanf("%d%d", &a, &b);\n    l[i] = a, r[i] = b;\n  }\n  build(1);\n  char last = s[n - 1];\n  for (int i = n - 2; i >= 0; i--) {\n    int a = vec[i], b = vec[i + 1];\n    if (s[a] != s[b]) {\n      last = s[b];\n    }\n    if (s[a] < last) {\n      good[a] = true;\n    }\n  }\n  dfs(1, 1);\n  for (int i = 0; i < vec.size(); i++) {\n    int t = vec[i];\n    cout << s[t];\n    if (cpy[t]) cout << s[t];\n  }\n  cout << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  vector<pair<long long, long long>> parent(n);\n  parent[0] = make_pair(-1, -1);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  for (int i = n - 1; i >= 0; i--) {\n    suffix[i] = max(suffix[i + 1], (long long)initial[i]);\n  }\n  cerr << initial << endl;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1]) {\n      bool good = 0;\n      for (int j = i; j < int(n - 1); ++j) {\n        if (initial[j] != initial[j + 1]) {\n          good = 1;\n          break;\n        }\n      }\n      if (!good) continue;\n    }\n    long long sum = 0;\n    bool ok = 1;\n    long long cur = pos[i];\n    cerr << "testing " << i << " " << initial[i] << endl;\n    while (cur != -1) {\n      sum++;\n      cerr << cur << " " << parent[cur].first << " " << parent[cur].second\n           << endl;\n      if (cur == 0 || taken[parent[cur].first]) break;\n      if (parent[cur].second) {\n        ok = 0;\n        break;\n      }\n      cur = parent[cur].first;\n    }\n    if (ok and k >= sum) {\n      cerr << initial[i] << " was ok with sum of " << sum << " and k is " << k\n           << endl;\n      long long cur = pos[i];\n      while (cur != -1) {\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      k -= sum;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\nconst int M = 4e5 + 1;\nconst long long MOD = 1e9 + 7;\nconst long long MOD1 = 998244353;\nconst long long INF = 1e17;\nconst int inf = 1e9;\nlong long n, m, k;\nstring s;\nvector<int> l(n + 1), r(n + 1);\nvector<char> val(n + 1);\nvector<int> pos(n + 1);\nvector<bool> dup(n + 1), good(n + 1);\nstring dfs1(int node, int len) {\n  if (node == 0) return "";\n  string before = dfs1(l[node], len);\n  pos[before.length() + len] = node;\n  return before + val[node] + dfs1(r[node], len + before.size() + 1);\n}\nvoid dfs2(int node, int depth) {\n  if (depth > k || node == 0) return;\n  dfs2(l[node], depth + 1);\n  if (dup[l[node]])\n    dup[node] = true;\n  else if (good[node]) {\n    dup[node] = true;\n    k -= depth;\n  }\n  if (dup[node]) {\n    dfs2(r[node], 1);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  l.clear();\n  r.clear();\n  val.clear();\n  pos.clear();\n  dup.clear();\n  good.clear();\n  l.resize(n + 1);\n  r.resize(n + 1);\n  val.resize(n + 1);\n  pos.resize(n + 1);\n  dup.resize(n + 1);\n  good.resize(n + 1);\n  for (int i = 1; i <= n; i++) {\n    char c;\n    cin >> c;\n    val[i] = c;\n  }\n  for (int i = 1; i <= n; i++) {\n    int l1, r1;\n    cin >> l1 >> r1;\n    l[i] = l1;\n    r[i] = r1;\n  }\n  s = dfs1(1, 0);\n  bool flag = false;\n  for (int i = n - 2; i >= 0; i--) {\n    if (val[pos[i]] < val[pos[i + 1]]) {\n      good[pos[i]] = true;\n      flag = true;\n    } else if (val[pos[i]] == val[pos[i + 1]] && flag) {\n      good[pos[i]] = true;\n    }\n  }\n  dfs2(1, 1);\n  for (int i = 0; i < n; i++) {\n    cout << val[pos[i]];\n    if (dup[pos[i]]) {\n      cout << val[pos[i]];\n    }\n  }\n  cout << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int tc = 1;\n  for (int t = 1; t <= tc; t++) {\n    solve();\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 7;\nint n, k;\nstring s;\nvector<int> nodes, d(N);\nvector<pair<int, int>> g(N), p(N);\nstring solveInitial(int u, int l) {\n  d[u] = l;\n  string t;\n  if (~g[u].first) t += solveInitial(g[u].first, l + 1);\n  t += s[u];\n  nodes.push_back(u);\n  if (~g[u].second) t += solveInitial(g[u].second, l + 1);\n  return t;\n}\npair<string, bool> solve(int u, int l, char c) {\n  string t;\n  bool dupPar = 0;\n  pair<string, bool> ret = {"", 0};\n  if (~g[u].first) ret = solve(g[u].first, l, c);\n  t += ret.first;\n  t += s[u];\n  if (ret.second)\n    t += s[u], dupPar = 1, l = u, c = \'a\';\n  else {\n    if (c <= s[u] && ~p[u].second &&\n        p[u].second < (~p[u].first ? p[u].first : INT_MAX) &&\n        d[u] + 1 - (~l ? d[l] + 1 : 0) <= k) {\n      k -= d[u] + 1 - (~l ? d[l] + 1 : 0);\n      t += s[u], dupPar = 1, l = u, c = \'a\';\n    }\n  }\n  ret = {"", 0};\n  if (!dupPar) c = max(c, s[u]);\n  if (~g[u].second) ret = solve(g[u].second, l, c);\n  if (!dupPar && ret.second) t += s[u], dupPar = 1;\n  t += ret.first;\n  return {t, dupPar};\n}\nvoid testCase() {\n  cin >> n >> k >> s;\n  for (int i = 0; i < n; i++)\n    cin >> g[i].first >> g[i].second, g[i].first--, g[i].second--;\n  string t = solveInitial(0, 0);\n  vector<int> v(26, -1);\n  for (int i = t.size() - 1; i >= 0; i--) {\n    int x = INT_MAX, y = INT_MAX;\n    for (int j = t[i] - \'a\' + 1; j < 26; j++) {\n      if (~v[j]) y = min(y, v[j]);\n    }\n    for (int j = t[i] - \'a\' - 1; j >= 0; j--) {\n      if (~v[j]) x = min(x, v[j]);\n    }\n    x = (x == INT_MAX ? -1 : x);\n    y = (y == INT_MAX ? -1 : y);\n    if (!~v[t[i] - \'a\']) v[t[i] - \'a\'] = INT_MAX;\n    v[t[i] - \'a\'] = min(v[t[i] - \'a\'], i);\n    p[nodes[i]] = {x, y};\n  }\n  cout << solve(0, -1, \'a\').first;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int T = 1;\n  while (T--) testCase();\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200000;\nstruct node {\n  int left;\n  int right;\n};\nstruct node t[N + 5];\nint tot, id[N + 5];\nchar a[N + 5];\nbool col[N + 5];\nchar str[N + 5], dif[N + 5];\nvoid dfs(int place) {\n  if (!place) return;\n  dfs(t[place].left);\n  str[++tot] = a[place];\n  id[place] = tot;\n  dfs(t[place].right);\n}\nint addnum;\nvoid print(int place) {\n  if (!place) return;\n  bool dup = 0;\n  if (col[place] && addnum) {\n    dup = 1;\n    addnum--;\n  }\n  print(t[place].left);\n  printf("%c", a[place]);\n  if (col[place] && dup) printf("%c", a[place]);\n  print(t[place].right);\n}\nbool add(int place, int depth) {\n  bool ans = 0;\n  if (t[place].left && depth) ans = add(t[place].left, depth - 1);\n  if (ans || a[place] < dif[id[place]]) ans = 1;\n  if (!ans) return 0;\n  col[place] = 1;\n  if (t[place].right && depth) add(t[place].right, depth - 1);\n  return 1;\n}\nint main() {\n  int n, k;\n  scanf("%d%d", &n, &k);\n  addnum = k;\n  scanf("%s", a + 1);\n  for (int i = 1; i <= n; i++) scanf("%d%d", &t[i].left, &t[i].right);\n  dfs(1);\n  dif[n] = str[n];\n  for (int i = n - 1; i >= 1; i--) {\n    if (str[i] == str[i + 1])\n      dif[i] = dif[i + 1];\n    else\n      dif[i] = str[i + 1];\n  }\n  add(1, k - 1);\n  print(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint l[200005], r[200005];\nchar s[200005];\nchar ss[400005];\nint pos[200005];\nint ok[200005];\nint nn;\nvoid dfs(int i) {\n  if (i == 0) return;\n  dfs(l[i]);\n  pos[nn] = i;\n  ss[nn++] = s[i];\n  dfs(r[i]);\n}\nint k;\nint dfs2(int i, int now) {\n  if (i == 0) return 0;\n  if (dfs2(l[i], now + 1) == 1) {\n    ss[nn++] = s[i];\n    ss[nn++] = s[i];\n    dfs2(r[i], 1);\n    return 1;\n  } else if (ok[i] == 0) {\n    ss[nn++] = s[i];\n    dfs(r[i]);\n    return 0;\n  } else {\n    ss[nn++] = s[i];\n    if (now <= k) {\n      k -= now;\n      ss[nn++] = s[i];\n      dfs2(r[i], 1);\n      return 1;\n    } else {\n      dfs(r[i]);\n      return 0;\n    }\n  }\n}\nint main() {\n  int n;\n  cin >> n >> k;\n  cin >> (s + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", l + i, r + i);\n  }\n  dfs(1);\n  {\n    int i = n - 1;\n    char last = ss[n - 1];\n    while (ss[i] == ss[n - 1] && i >= 0) i--;\n    for (; i >= 0; i--) {\n      if (ss[i] == ss[i + 1]) {\n      } else {\n        last = ss[i + 1];\n      }\n      if (ss[i] < last) ok[pos[i]] = 1;\n    }\n  }\n  nn = 0;\n  dfs2(1, 1);\n  cout << ss << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200000;\nstruct node {\n  int left;\n  int right;\n};\nstruct node t[N + 5];\nint tot, id[N + 5], depth[N + 5];\nchar a[N + 5];\nbool col[N + 5];\nchar str[N + 5], dif[N + 5];\nvoid dfs(int place, int father) {\n  if (!place) return;\n  depth[place] = depth[father] + 1;\n  dfs(t[place].left, place);\n  str[++tot] = a[place];\n  id[place] = tot;\n  dfs(t[place].right, place);\n}\nvoid print(int place) {\n  if (!place) return;\n  print(t[place].left);\n  printf("%c", a[place]);\n  if (col[place]) printf("%c", a[place]);\n  print(t[place].right);\n}\nint k;\nbool add(int place, int top) {\n  bool ans = 0;\n  if (t[place].left && k > 1) ans = add(t[place].left, top);\n  if (ans)\n    col[place] = 1;\n  else if (a[place] < dif[id[place]] && k >= depth[place] - depth[top]) {\n    k -= depth[place] - depth[top];\n    ans = 1;\n    col[place] = 1;\n  }\n  if (!ans) return 0;\n  if (t[place].right && k > 1) add(t[place].right, place);\n  return 1;\n}\nint main() {\n  int n;\n  scanf("%d%d", &n, &k);\n  scanf("%s", a + 1);\n  for (int i = 1; i <= n; i++) scanf("%d%d", &t[i].left, &t[i].right);\n  dfs(1, 1);\n  dif[n] = str[n];\n  for (int i = n - 1; i >= 1; i--) {\n    if (str[i] == str[i + 1])\n      dif[i] = dif[i + 1];\n    else\n      dif[i] = str[i + 1];\n  }\n  add(1, 0);\n  print(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  vector<pair<long long, long long>> parent(n);\n  parent[0] = make_pair(-1, -1);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  char last = char(1);\n  for (int i = n - 1; i >= 0; i--) {\n    suffix[i] = last;\n    if (initial[i] != last) last = initial[i];\n  }\n  cerr << initial << endl;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long sum = 0;\n    bool ok = 1;\n    long long cur = pos[i];\n    cerr << "testing " << i << " " << initial[i] << endl;\n    while (cur != -1) {\n      if (taken[cur]) break;\n      sum++;\n      cerr << cur << " " << parent[cur].first << " " << parent[cur].second\n           << endl;\n      if (cur == 0 || taken[parent[cur].first]) break;\n      if (parent[cur].second) {\n        ok = 0;\n        break;\n      }\n      cur = parent[cur].first;\n    }\n    if (ok and k >= sum) {\n      cerr << initial[i] << " was ok with sum of " << sum << " and k is " << k\n           << endl;\n      long long cur = pos[i];\n      while (cur != -1) {\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      k -= sum;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '\'\'\' E. Middle Duplication\nhttps://codeforces.com/contest/1623/problem/E\n\'\'\'\n\nimport io, os, sys\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n\nDEBUG = os.environ.get(\'debug\') is not None\n\nif DEBUG:\n    from inspect import currentframe, getframeinfo\n    from re import search\n\ndef debug(*args):\n    if not DEBUG: return\n    frame = currentframe().f_back\n    s = getframeinfo(frame).code_context[0]\n    r = search(r"\\((.*)\\)", s).group(1)\n    vnames = r.split(\', \')\n    var_and_vals = [f\'{var}={val}\' for var, val in zip(vnames, args)]\n    prefix = f\'{currentframe().f_back.f_lineno:02d}: \'\n    print(f\'{prefix}{", ".join(var_and_vals)}\')\n\n\nINF = float(\'inf\')\n\n# -----------------------------------------\n\ndef main():\n    N, K = list(map(int, input().split()))\n    S = input().decode().strip()\n\n    L, R = [-1]*N, [-1]*N\n    for p in range(N):\n        l, r = map(int, input().split())\n        L[p], R[p] = l-1, r-1\n\n    # inorder\n    inorder = []\n    def dfs1(u):\n        if L[u] > -1: dfs1(L[u])\n        inorder.append(u)\n        if R[u] > -1: dfs1(R[u])\n    dfs1(0)\n\n    # can duplicate if next different node exists and is greater\n    good = [False]*N\n    last = \'\'\n    for i in range(N-2, -1, -1):\n        u, v = inorder[i], inorder[i+1]\n        if S[u] != S[v]: last = S[v]\n        if S[u] < last: good[u] = True\n\n    # greedily duplicate following inorder \n    # cost = cost if duplicate u; equals distance from u to nearest dup ancestor\n    dup = [False]*N\n    def dfs2(u, cost=1):\n        nonlocal K\n        if cost > K: return\n\n        # dup leftmost possible descendant\n        dfs2(L[u], cost+1)\n\n        # left child dup; alr counted cost to dup u\n        if dup[L[u]]: \n            dup[u] = True\n\n        # left subtree undup, u dup; subtract cost to dup u and its undup ancestors\n        elif good[u]:\n            dup[u] = True\n            K -= cost\n        \n        # can only dup right subtree if u dup\n        if dup[u]: dfs2(R[u], 1)\n\n    dfs2(0)\n\n    # output\n    print(\'\'.join(S[u]*2 if dup[u] else S[u] for u in inorder))\n\n\nif __name__ == \'__main__\':\n    main()\n\n', '#include <bits/stdc++.h>\nusing namespace std;\ninline long long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch > \'9\' || ch < \'0\') {\n    if (ch == \'-\') f = -1;\n    ch = getchar();\n  }\n  while (ch >= \'0\' && ch <= \'9\') {\n    x = x * 10 + ch - \'0\';\n    ch = getchar();\n  }\n  return x * f;\n}\nint t, n, k;\nint ls[200005], rs[200005];\nchar s[200005];\nvector<int> q;\nvoid dfs(int x) {\n  if (ls[x]) dfs(ls[x]);\n  q.push_back(x);\n  if (rs[x]) dfs(rs[x]);\n}\nint nxt[200005];\nbool ok[200005], db[200005];\nbool dfsls(int x, int k) {\n  if (!k) return 0;\n  if (ok[x]) return 1;\n  if (ls[x]) return dfsls(ls[x], k - 1);\n  return 0;\n}\nstring dfs2(int x, bool r) {\n  ok[x] |= dfsls(x, k);\n  ok[x] &= r;\n  if (ok[x] && k) k--, db[x] = 1;\n  string ans = "";\n  if (ls[x]) ans += dfs2(ls[x], db[x]);\n  ans += s[x];\n  if (db[x]) ans += s[x];\n  if (rs[x]) ans += dfs2(rs[x], db[x]);\n  return ans;\n}\nint main() {\n  n = read(), k = read();\n  scanf("%s", s + 1);\n  for (int i = 1; i <= n; i++) ls[i] = read(), rs[i] = read();\n  dfs(1);\n  q.push_back(0);\n  for (int i = q.size() - 2; i >= 0; i--) {\n    if (s[q[i]] == s[q[i + 1]])\n      nxt[i] = nxt[i + 1];\n    else\n      nxt[i] = i + 1;\n  }\n  for (int i = 0; i < q.size() - 1; i++) {\n    if (s[q[nxt[i]]] > s[q[i]]) ok[q[i]] = 1;\n  }\n  for (int i = 1; i <= n; i++) printf("%d ", i), puts(ok[i] ? "YES" : "NO");\n  cout << dfs2(1, 1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, n, m, t, l[200500], r[200500], siz[200500], tp[200500], it,\n    id[200500], dep[200500], sb[200500], fa[200500];\nchar s[200500];\nint q[200500];\nstring res;\nvoid dfs0(int x, int d) {\n  if (!x) return;\n  dep[x] = d;\n  fa[l[x]] = fa[r[x]] = x;\n  dfs0(l[x], d + 1);\n  q[++it] = x;\n  dfs0(r[x], d + 1);\n  siz[x] = 1 + siz[l[x]] + siz[r[x]];\n}\nvoid dfs01(int x, int to) {\n  if (!x) return;\n  tp[x] = to;\n  id[x] = ++it;\n  if (siz[l[x]] >= siz[r[x]]) {\n    dfs01(l[x], to);\n    dfs01(r[x], r[x]);\n  } else {\n    dfs01(r[x], to);\n    dfs01(l[x], l[x]);\n  }\n}\nstruct SB {\n  int f[800500], t[805000];\n  void push(int id, int l, int r) {\n    t[(id << 1)] = t[((id << 1) + 1)] = t[id];\n    f[(id << 1)] = ((t[id] < 1) ? -1000000 : (((l + r) >> 1) - l + 1));\n    f[((id << 1) + 1)] = ((t[id] < 1) ? -1000000 : (r - ((l + r) >> 1)));\n    t[id] = 0;\n  }\n  void ass(int id, int l, int r, int x, int y, int w) {\n    if (x <= l && r <= y) {\n      t[id] = w;\n      f[id] = ((w < 1) ? -1000000 : (r - l + 1));\n      return;\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (x <= ((l + r) >> 1)) ass((id << 1), l, ((l + r) >> 1), x, y, w);\n    if (y > ((l + r) >> 1))\n      ass(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y, w);\n    f[id] = max(-1000000, f[(id << 1)] + f[((id << 1) + 1)]);\n  }\n  int get(int id, int l, int r, int x, int y) {\n    if (x <= l && r <= y) {\n      return f[id];\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (y <= ((l + r) >> 1)) return get((id << 1), l, ((l + r) >> 1), x, y);\n    if (x > ((l + r) >> 1))\n      return get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y);\n    return max(-1000000, get((id << 1), l, ((l + r) >> 1), x, y) +\n                             get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y));\n  }\n} SB;\nvoid hld_ass(int x, int w) {\n  while (x) {\n    SB.ass(1, 1, n, id[tp[x]], id[x], 1);\n    x = fa[tp[x]];\n  }\n}\nint hld_get(int x, int w = 0) {\n  while (x) {\n    w += SB.get(1, 1, n, id[tp[x]], id[x]);\n    w = max(w, -1000000);\n    x = fa[tp[x]];\n  }\n  return w;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> m >> s + 1;\n  for (i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs0(1, 1);\n  it = 0;\n  dfs01(1, 1);\n  for (i = n; i >= 1; i--) {\n    if (s[q[i]] == s[q[i + 1]]) {\n      sb[i] = sb[i + 1];\n    } else {\n      sb[i] = (s[q[i]] < s[q[i + 1]]);\n    }\n  }\n  for (i = 1; i < n; i++) {\n    res += s[q[i]];\n    if (SB.get(1, 1, n, id[q[i]], id[q[i]])) {\n      res += s[q[i]];\n      continue;\n    }\n    if (sb[i]) {\n      k = hld_get(q[i]);\n      if (k + m >= dep[q[i]]) {\n        res += s[q[i]];\n        m -= (dep[q[i]] - k);\n        hld_ass(q[i], 1);\n      }\n    } else {\n      SB.ass(1, 1, n, id[q[i]], id[q[i]], -1000000);\n    }\n  }\n  cout << res;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(1e6));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 0; i < int(30); ++i) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(1e6);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      long long operations = 0;\n      while (cur) {\n        if (n == 200000 and k == 8) cout << cur << \'.\';\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, n, m, t, l[200500], r[200500], siz[200500], tp[200500], it,\n    id[200500], dep[200500], sb[200500], fa[200500];\nchar s[200500];\nint q[200500];\nstring res;\nvoid dfs0(int x, int d) {\n  if (!x) return;\n  dep[x] = d;\n  fa[l[x]] = fa[r[x]] = x;\n  dfs0(l[x], d + 1);\n  q[++it] = x;\n  dfs0(r[x], d + 1);\n  siz[x] = 1 + siz[l[x]] + siz[r[x]];\n}\nvoid dfs01(int x, int to) {\n  if (!x) return;\n  tp[x] = to;\n  id[x] = ++it;\n  if (siz[l[x]] >= siz[r[x]]) {\n    dfs01(l[x], to);\n    dfs01(r[x], r[x]);\n  } else {\n    dfs01(r[x], to);\n    dfs01(l[x], l[x]);\n  }\n}\nstruct SB {\n  int f[800500], t[805000];\n  void push(int id, int l, int r) {\n    t[(id << 1)] = t[((id << 1) + 1)] = t[id];\n    f[(id << 1)] = ((t[id] < 1) ? -1000000 : (((l + r) >> 1) - l + 1));\n    f[((id << 1) + 1)] = ((t[id] < 1) ? -1000000 : (r - ((l + r) >> 1)));\n    t[id] = 0;\n  }\n  void ass(int id, int l, int r, int x, int y, int w) {\n    if (x <= l && r <= y) {\n      t[id] = w;\n      f[id] = ((w < 1) ? -1000000 : (r - l + 1));\n      return;\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (x <= ((l + r) >> 1)) ass((id << 1), l, ((l + r) >> 1), x, y, w);\n    if (y > ((l + r) >> 1))\n      ass(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y, w);\n    f[id] = max(-1000000, f[(id << 1)] + f[((id << 1) + 1)]);\n  }\n  int get(int id, int l, int r, int x, int y) {\n    if (x <= l && r <= y) {\n      return f[id];\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (y <= ((l + r) >> 1)) return get((id << 1), l, ((l + r) >> 1), x, y);\n    if (x > ((l + r) >> 1))\n      return get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y);\n    return max(-1000000, get((id << 1), l, ((l + r) >> 1), x, y) +\n                             get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y));\n  }\n} SB;\nvoid hld_ass(int x, int w) {\n  while (x) {\n    SB.ass(1, 1, n, id[tp[x]], id[x], 1);\n    x = fa[tp[x]];\n  }\n}\nint hld_get(int x, int w = 0) {\n  while (x) {\n    w += SB.get(1, 1, n, id[tp[x]], id[x]);\n    w = max(w, -1000000);\n    x = fa[tp[x]];\n  }\n  return w;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> m >> s + 1;\n  for (i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs0(1, 1);\n  it = 0;\n  dfs01(1, 1);\n  sb[n] = 1;\n  for (i = n - 1; i >= 1; i--) {\n    if (s[q[i]] == s[q[i + 1]]) {\n      sb[i] = sb[i + 1];\n    } else {\n      sb[i] = (s[q[i]] < s[q[i + 1]]);\n    }\n  }\n  for (i = 1; i < n; i++) {\n    res += s[q[i]];\n    if (SB.get(1, 1, n, id[q[i]], id[q[i]])) {\n      res += s[q[i]];\n      continue;\n    }\n    if (sb[i]) {\n      k = hld_get(q[i]);\n      if (k + m >= dep[q[i]]) {\n        res += s[q[i]];\n        m -= (dep[q[i]] - k);\n        hld_ass(q[i], 1);\n      }\n    } else {\n      SB.ass(1, 1, n, id[q[i]], id[q[i]], -1000000);\n    }\n  }\n  res += s[q[n]];\n  cout << res;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(1e6));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 0; i < int(30); ++i) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(1e6);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      long long operations = 0;\n      while (cur) {\n        if (k == 8) cout << cur << \'.\';\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define var(...) " [" << #__VA_ARGS__ ": " << (__VA_ARGS__) << "] "\n#define mem(x, n) memset(x, n, sizeof(x))\n#define all(x) x.begin(), x.end()\n#define sz(x) ((int)x.size())\n#define vec vector\n#define endl "\\n"\n\nstruct Node\n{\n\tint l, r, p;\n};\n\nint n, k;\n\nconst int N = 2e5 + 5;\n\nauto level = vec(N + 1, \'.\');\nauto tree = vec(N + 1, Node{});\nauto ids = vec(N + 1, 0);\nauto res = vec(N + 1, string(""));\n\nauto dupli = vec(N + 1, \'.\');\n\nint curr_id = 0;\n\nauto nearest_index = vec(26, deque<int>());\n\nvoid dfs(int s)\n{\n\tif (tree[s].l != 0)\n\t{\n\t\tdfs(tree[s].l);\n\t}\n\n\tcurr_id++;\n\n\tids[s] = curr_id;\n\tnearest_index[level[s] - \'a\'].push_back(curr_id);\n\n\tres[curr_id] = level[s];\n\n\tif (tree[s].r != 0)\n\t{\n\t\tdfs(tree[s].r);\n\t}\n}\n\nauto k_cnt = vec(N + 1, 0);\n\nvoid dfs1(int s, int req, bool can_level)\n{\n\tk_cnt[s] = req;\n\n\tif (tree[s].l != 0)\n\t{\n\t\tdfs1(tree[s].l, req + 1, can_level);\n\t}\n\n\tint id = ids[s];\n\n\tint greater_id = INT_MAX;\n\tint smaller_id = INT_MAX;\n\n\tnearest_index[level[s] - \'a\'].pop_back();\n\n\tfor (int j = 0; j < 26 && can_level; j++)\n\t{\n\t\tif (j == level[s] - \'a\' || nearest_index[j].empty())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tint curr = nearest_index[j].front();\n\n\n\t\tif (j < level[s] - \'a\')\n\t\t{\n\t\t\tsmaller_id = min(smaller_id, curr);\n\t\t}\n\t\telse if (j > level[s] - \'a\')\n\t\t{\n\t\t\tgreater_id = min(greater_id, curr);\n\t\t}\n\t}\n\n\tif (greater_id < smaller_id && k_cnt[s] <= k)\n\t{\n\t\tint me = s;\n\n\t\twhile (true)\n\t\t{\n\t\t\tif (me == 0 || k_cnt[me] == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk_cnt[me] = 0;\n\t\t\tme = tree[me].p;\n\t\t\tk--;\n\t\t}\n\t}\n\n\n\tif (tree[s].r != 0)\n\t{\n\n\t\tdfs1(tree[s].r, k_cnt[s] + 1, k_cnt[s] == 0);\n\t}\n\n\tif (k_cnt[s] == 0)\n\t{\n\t\t//cout << var(id) << var(s) << var(greater_id) << var(smaller_id) << endl;\n\t\tres[id] += res[id];\n\t}\n}\n\nvoid run_case([[maybe_unused]] const int &TC)\n{\n\tcin >> n >> k;\n\n\tstring s;\n\tcin >> s;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tlevel[i] = s[i - 1];\n\t}\n\n\ttree[1].p = 0;\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> tree[i].l >> tree[i].r;\n\n\t\ttree[tree[i].l].p = i;\n\t\ttree[tree[i].r].p = i;\n\t}\n\n\tdfs(1);\n\n\tdfs1(1, 1, true);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcout << res[i];\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\n\tint t = 1;\n\t//cin >> t;\n\n\tfor (int tc = 1; tc <= t; tc++)\n\t\trun_case(tc);\n\n\treturn 0;\n}', '#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nint SIZE(T(&t)) {\n  return t.size();\n}\ntemplate <typename T, size_t N>\nint SIZE(T (&t)[N]) {\n  return N;\n}\nstring to_string(char t) { return "\'" + string({t}) + "\'"; }\nstring to_string(bool t) { return t ? "true" : "false"; }\nstring to_string(const string& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)), _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += t[i];\n  }\n  return \'"\' + ret + \'"\';\n}\nstring to_string(const char* t) {\n  string ret(t);\n  return to_string(ret);\n}\ntemplate <size_t N>\nstring to_string(const bitset<N>& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)); i <= min(x2, SIZE(t) - 1); ++i) {\n    ret += t[i] + \'0\';\n  }\n  return to_string(ret);\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1 = 0, int x2 = 1e9, Coords... C);\ntemplate <typename T, typename S>\nstring to_string(const pair<T, S>& t) {\n  return "(" + to_string(t.first) + ", " + to_string(t.second) + ")";\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1, int x2, Coords... C) {\n  string ret = "[";\n  x1 = min(x1, SIZE(t));\n  auto e = begin(t);\n  advance(e, x1);\n  for (int i = x1, _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += to_string(*e, C...) + (i != _i ? ", " : "");\n    e = next(e);\n  }\n  return ret + "]";\n}\ntemplate <int Index, typename... Ts>\nstruct print_tuple {\n  string operator()(const tuple<Ts...>& t) {\n    string ret = print_tuple<Index - 1, Ts...>{}(t);\n    ret += (Index ? ", " : "");\n    return ret + to_string(get<Index>(t));\n  }\n};\ntemplate <typename... Ts>\nstruct print_tuple<0, Ts...> {\n  string operator()(const tuple<Ts...>& t) { return to_string(get<0>(t)); }\n};\ntemplate <typename... Ts>\nstring to_string(const tuple<Ts...>& t) {\n  const auto Size = tuple_size<tuple<Ts...>>::value;\n  return print_tuple<Size - 1, Ts...>{}(t);\n}\nvoid dbgr() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgr(Heads H, Tails... T) {\n  cout << to_string(H) << " | ";\n  dbgr(T...);\n}\nvoid dbgs() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgs(Heads H, Tails... T) {\n  cout << H << " ";\n  dbgs(T...);\n}\nconst int N = 1e5 + 5;\nconst long long INF = 1e18 + 7;\nconst int MAXA = 1e9;\nconst int B = sqrt(N) + 5;\nint l[N], r[N], pv[N];\nbool dou[N], ok[N];\nstring s;\ndeque<char> ans[N];\ndeque<int> pos[N];\nint n, k;\nvoid dfs(int u) {\n  if (u == 0) return;\n  dfs(l[u]);\n  dfs(r[u]);\n  if (ans[l[u]].size() > ans[r[u]].size()) {\n    swap(ans[u], ans[l[u]]);\n    swap(pos[u], pos[l[u]]);\n    ans[u].push_back(s[u]);\n    pos[u].push_back(u);\n    for (char i : ans[r[u]]) {\n      ans[u].push_back(i);\n    }\n    for (int i : pos[r[u]]) {\n      pos[u].push_back(i);\n    }\n  } else {\n    swap(ans[u], ans[r[u]]);\n    swap(pos[u], pos[r[u]]);\n    ans[u].push_front(s[u]);\n    pos[u].push_front(u);\n    reverse(ans[l[u]].begin(), ans[l[u]].end());\n    reverse(pos[l[u]].begin(), pos[l[u]].end());\n    for (char i : ans[l[u]]) {\n      ans[u].push_front(i);\n    }\n    for (int i : pos[l[u]]) {\n      pos[u].push_front(i);\n    }\n  }\n}\nbool dfs_opt(int u, int h) {\n  bool f = false;\n  if (ok[pv[u]] && k >= h) {\n    k -= h;\n    dou[u] = true;\n    if (l[u]) dfs_opt(l[u], 1);\n    if (r[u]) dfs_opt(r[u], 1);\n    return true;\n  } else {\n    if (l[u]) f |= dfs_opt(l[u], h + 1);\n    if (f) dou[u] = true;\n    return false;\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  cin >> s;\n  s = " " + s;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  dfs(1);\n  s = " ";\n  for (char i : ans[1]) s += i;\n  for (int i = 0; i < n; ++i) pv[pos[1][i]] = i + 1;\n  int l = 1;\n  for (int i = 1; i < n; ++i) {\n    if (s[i] != s[i + 1]) {\n      if (s[i] < s[i + 1]) {\n        for (int j = l; j <= i; ++j) ok[j] = true;\n      }\n      l = i + 1;\n    }\n  }\n  dfs_opt(1, 1);\n  for (int i = 1; i <= n; ++i) {\n    cout << s[i];\n    if (dou[pos[1][i - 1]]) cout << s[i];\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nvoid foo() {\n  int n, k;\n  cin >> n >> k;\n  string c;\n  cin >> c;\n  vector<int> L(n), R(n), p(n, -1);\n  for (int i = 0; i < n; i++) {\n    cin >> L[i] >> R[i];\n    L[i]--;\n    R[i]--;\n    if (L[i] != -1) p[L[i]] = i;\n    if (R[i] != -1) p[R[i]] = i;\n  }\n  vector<int> preorder;\n  vector<int> order;\n  vector<int> pos(n);\n  function<void(int)> dfs = [&](int v) {\n    if (v == -1) return;\n    preorder.push_back(v);\n    dfs(L[v]);\n    pos[v] = order.size();\n    order.push_back(v);\n    dfs(R[v]);\n  };\n  dfs(0);\n  vector<bool> want(n);\n  for (int j = n - 2; j >= 0; j--) {\n    int v = order[j];\n    int nxt = order[j + 1];\n    if (c[v] == c[nxt]) {\n      want[v] = want[nxt];\n    } else {\n      want[v] = c[v] < c[nxt];\n    }\n  }\n  vector<bool> bad(n);\n  for (int v : preorder) {\n    if (!want[v]) {\n      if (R[v] != -1) {\n        want[R[v]] = false;\n        bad[R[v]] = true;\n      }\n      if (bad[v] && L[v] != -1) {\n        want[L[v]] = false;\n        bad[L[v]] = true;\n      }\n    }\n  }\n  vector<bool> d(n);\n  int cnt = 0;\n  vector<int> cnt_top(n, -1);\n  for (int j = 0; j < n; j++) {\n    int v = order[j];\n    if (!want[v] || d[v]) continue;\n    if (p[v] != -1 && R[p[v]] == v) {\n      assert(d[p[v]]);\n      cnt_top[v] = 1;\n    } else if (L[v] != -1 && cnt_top[L[v]] != -1) {\n      cnt_top[v] = cnt_top[L[v]] - 1;\n    } else {\n      cnt_top[v] = 0;\n      for (int x = v; x >= 0; x = p[x]) {\n        if (d[x]) break;\n        cnt_top[v]++;\n      }\n    }\n    if (cnt_top[v] + cnt > k) {\n      continue;\n    }\n    cnt += cnt_top[v];\n    for (int x = v; x >= 0 && !d[x]; x = p[x]) {\n      d[x] = true;\n      cnt_top[x] = 0;\n    }\n  }\n  string ans = "";\n  for (int v : order) {\n    ans += c[v];\n    if (d[v]) ans += c[v];\n  }\n  cout << ans << \'\\n\';\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  foo();\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200000;\nstruct node {\n  int left;\n  int right;\n};\nstruct node t[N + 5];\nint tot, id[N + 5];\nchar a[N + 5];\nbool col[N + 5];\nchar str[N + 5], dif[N + 5];\nvoid dfs(int place) {\n  if (!place) return;\n  dfs(t[place].left);\n  str[++tot] = a[place];\n  id[place] = tot;\n  dfs(t[place].right);\n}\nvoid print(int place) {\n  if (!place) return;\n  print(t[place].left);\n  printf("%c", a[place]);\n  if (col[place]) printf("%c", a[place]);\n  print(t[place].right);\n}\nint k;\nbool add(int place) {\n  bool ans = 0;\n  if (t[place].left && k > 1) ans = add(t[place].left);\n  if (ans || a[place] < dif[id[place]]) ans = 1;\n  if (!ans) return 0;\n  k--;\n  col[place] = 1;\n  if (t[place].right && k > 1) add(t[place].right);\n  return 1;\n}\nint main() {\n  int n;\n  scanf("%d%d", &n, &k);\n  scanf("%s", a + 1);\n  for (int i = 1; i <= n; i++) scanf("%d%d", &t[i].left, &t[i].right);\n  dfs(1);\n  dif[n] = str[n];\n  for (int i = n - 1; i >= 1; i--) {\n    if (str[i] == str[i + 1])\n      dif[i] = dif[i + 1];\n    else\n      dif[i] = str[i + 1];\n  }\n  add(1);\n  print(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \' \' << H;\n  debug_out(T...);\n}\nconst long long MOD = 1e9 + 7;\nconst int N = 2e5 + 1;\nint l[N], r[N], lm[N], p[N][20], nxt[N], dept[N];\nvector<bool> nxtpos(N + 1, 0);\nvector<char> s(N);\nint n, k;\nvoid lmq(int cur) {\n  lm[cur] = cur;\n  if (l[cur] > 0) {\n    dept[l[cur]] = dept[cur] + 1;\n    p[l[cur]][0] = cur;\n    lmq(l[cur]);\n    lm[cur] = lm[l[cur]];\n  }\n  if (r[cur] > 0) {\n    dept[r[cur]] = dept[cur] + 1;\n    p[r[cur]][0] = cur;\n    lmq(r[cur]);\n  }\n}\nvoid setnext(int cur, int rlp) {\n  if (r[cur] > 0) {\n    nxt[cur] = lm[r[cur]];\n    setnext(r[cur], rlp);\n  } else {\n    nxtpos[cur] = 1;\n    nxt[cur] = rlp;\n  }\n  if (l[cur] > 0) setnext(l[cur], cur);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dept[1] = 1;\n  lmq(1);\n  setnext(1, 0);\n  for (int i = 1; i <= n; i++) {\n    cout << nxt[i] << " ";\n  }\n  cout << "\\n";\n  for (int i = 1; i < 20; i++) {\n    for (int j = 1; j <= n; j++) {\n      p[j][i] = p[p[j][i - 1]][i - 1];\n    }\n  }\n  vector<bool> dup(n + 1, 0), ndup(n + 1, 0);\n  int cur = lm[1];\n  while (cur != 0) {\n    if (dup[cur] || ndup[cur]) {\n      cur = nxt[cur];\n      continue;\n    }\n    if (s[cur] < s[nxt[cur]]) {\n      int len = 0, temp = cur, i = 19;\n      bool blocked = false;\n      while (!blocked && p[temp][0] > 0 && !dup[p[temp][0]]) {\n        for (; i >= 0; i--) {\n          if (p[temp][i] > 0 && ndup[p[temp][i]]) {\n            blocked = true;\n            break;\n          }\n          if (p[temp][i] > 0 && !dup[p[temp][i]]) {\n            len += (1 << i);\n            temp = p[temp][i];\n            break;\n          }\n        }\n      }\n      len++;\n      temp = cur;\n      if (!blocked && len <= k) {\n        k -= len;\n        while (len--) {\n          dup[temp] = 1;\n          temp = p[temp][0];\n        }\n      }\n    }\n    if (s[cur] > s[nxt[cur]] && !nxtpos[cur]) {\n      queue<int> q;\n      q.push(cur);\n      while (!q.empty()) {\n        int temp = q.front();\n        q.pop();\n        ndup[temp] = 1;\n        if (l[temp] > 0) {\n          q.push(l[temp]);\n        }\n        if (r[temp] > 0) {\n          q.push(r[temp]);\n        }\n      }\n    }\n    cur = nxt[cur];\n  }\n  int start = lm[1];\n  while (start != 0) {\n    if (dup[start]) {\n      cout << s[start] << s[start];\n    } else {\n      cout << s[start];\n    }\n    start = nxt[start];\n  }\n  cout << "\\n";\n  return 0;\n}\n', '#include <bits/stdc++.h>\nlong getbit(long first, long second) { return ((first >> second) & 1); }\nusing namespace std;\nconst long N = 2e5 + 5;\nlong cnt, n, k, l[N], r[N], h[N];\nchar c[N];\nstring s;\nvector<long> so;\nbool dd[N], Next[N];\nvoid tao(long u, long pa) {\n  h[u] = h[pa] + 1;\n  if (l[u] != 0) tao(l[u], u);\n  s += c[u];\n  so.push_back(u);\n  if (r[u] != 0) tao(r[u], u);\n}\nvoid dfs(long u, long last) {\n  if (l[u] != 0) {\n    if (Next[l[u]] && cnt + h[l[u]] - h[last] <= k) {\n      dd[l[u]] = 1;\n      cnt += h[l[u]] - h[last];\n      last = u;\n      dfs(l[u], l[u]);\n    }\n  }\n  if (r[u] != 0) {\n    if ((last == u || Next[u]) && h[u] - h[last] <= k) {\n      dd[u] = 1;\n      cnt += h[u] - h[last];\n      dfs(r[u], u);\n    }\n  }\n}\nvoid dfs1(long u) {\n  if (l[u] != 0) {\n    dfs1(l[u]);\n    dd[u] |= dd[l[u]];\n  }\n  if (r[u] != 0) {\n    dfs1(r[u]);\n    dd[u] |= dd[r[u]];\n  }\n}\nvoid tao1(long u) {\n  if (l[u] != 0) tao1(l[u]);\n  if (dd[u])\n    s += c[u], s += c[u];\n  else\n    s += c[u];\n  if (r[u] != 0) tao1(r[u]);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long i = 1; i <= n; i++) cin >> c[i];\n  for (long i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  s = "";\n  tao(1, 0);\n  for (long i = (long)s.size() - 1; i >= 0; i--)\n    if (i == (long)s.size() - 1)\n      Next[so[i]] = 0;\n    else if (s[i] < s[i + 1])\n      Next[so[i]] = 1;\n    else if (s[i] == s[i + 1])\n      Next[so[i]] = Next[so[i + 1]];\n    else\n      Next[so[i]] = 0;\n  dfs(1, 0);\n  dfs1(1);\n  s = "";\n  tao1(1);\n  cout << s << \'\\n\';\n  return 0;\n}\n', 'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class e {\n\tstatic final int LOG=30;\n\tstatic final int INF=Integer.MAX_VALUE/2-5;\n\tpublic static void main(String[] args) {\n\t\tFastScanner scan=new FastScanner();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\n\t\tint n=scan.nextInt(), k=scan.nextInt();\n\t\tc=scan.next().toCharArray();\n\t\t\n\t\ta=new int[n][2];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i][0]=scan.nextInt()-1;\n\t\t\ta[i][1]=scan.nextInt()-1;\n\t\t}\n\t\tinorder=new ArrayList<>();\n\t\tdepth=new int[n];\n\t\tparent=new int[n];\n\t\tid=new int[n];\n\t\tinit(0,0,-1);\n\t\t\n\t\tint[][] smallestbad=new int[LOG][n];\n\t\tint[][] jump=new int[LOG][n];\n\t\t\n\t\tfor(int i=0;i<n;i++) jump[0][i]=parent[i];\n\t\t\n\t\tint[] last=new int[26];\n\t\tArrays.fill(last,-1);\n\t\tlast[(int)(c[inorder.get(n-1)]-\'a\')]=n-1;\n\t\tboolean[] bad=new boolean[n];\n\t\t\n\t\tfor(int i=n-2;i>=0;i--) {\n\t\t\tint p=inorder.get(i), q=inorder.get(i+1);\n\t\t\tint nxtdif=Integer.MAX_VALUE;\n\t\t\tchar nxtchar=\' \';\n\t\t\tfor(int j=0;j<26;j++) {\n\t\t\t\tif(j!=(int)(c[q]-\'a\')&&last[j]!=-1) {\n\t\t\t\t\tif(nxtdif>last[j]) {\n\t\t\t\t\t\tnxtdif=last[j];\n\t\t\t\t\t\tnxtchar=(char)(j+\'a\');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c[p]<c[q]) {\n\t\t\t\t//expanding here\n\t\t\t}\n\t\t\telse if(c[p]==c[q]&&nxtdif!=Integer.MAX_VALUE&&nxtchar>c[p]) {\n\t\t\t\t//expanding here\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbad[p]=true;\n\t\t\t}\n\t\t\tlast[(int)(c[inorder.get(i)]-\'a\')]=i;\n\t\t}\n\t\tbad[inorder.get(n-1)]=true;\n\t\tArrays.fill(smallestbad[0],INF);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(bad[i]) smallestbad[0][i]=Math.min(smallestbad[0][i],id[i]);\n\t\t\tif(parent[i]!=-1&&bad[parent[i]]) smallestbad[0][i]=Math.min(smallestbad[0][i],id[parent[i]]);\n\t\t}\n\t\t\n\t\tfor(int j=1;j<LOG;j++) {\n\t\t\tArrays.fill(smallestbad[j],INF);\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(jump[j-1][i]==-1) jump[j][i]=-1;\n\t\t\t\telse jump[j][i]=jump[j-1][jump[j-1][i]];\n\t\t\t\t\n\t\t\t\tif(smallestbad[j-1][i]!=INF) smallestbad[j][i]=Math.min(smallestbad[j][i],smallestbad[j-1][i]);\n\t\t\t\tif(jump[j-1][i]!=-1&&smallestbad[j-1][jump[j-1][i]]!=INF) smallestbad[j][i]=Math.min(smallestbad[j][i],smallestbad[j-1][jump[j-1][i]]);\n\t\t\t}\n\t\t}\n\t\tint[] expand=new int[n];\n\t\tArrays.fill(expand,-1);\n\t\tboolean[] select=new boolean[n];\n\t\tint ptr=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint cur=inorder.get(i);\n\t\t\tif(expand[cur]!=-1&&select[expand[cur]]) continue;\n\t\t\tif(smallestbad[LOG-1][cur]<=id[cur]) continue;\n\t\t\tint ct=0;\n\t\t\twhile(cur!=-1&&(expand[cur]==-1||!select[expand[cur]])) {\n\t\t\t\texpand[cur]=ptr;\n\t\t\t\tcur=parent[cur];\n\t\t\t\tct++;\n\t\t\t}\n\t\t\tif(k>=ct) {\n\t\t\t\tk-=ct;\n\t\t\t\tselect[ptr]=true;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t\tStringBuilder res=new StringBuilder();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint cur=inorder.get(i);\n\t\t\tres.append(c[cur]);\n\t\t\tif(expand[cur]!=-1&&select[expand[cur]]) {\n\t\t\t\tres.append(c[cur]);\n\t\t\t}\n\t\t}\n\t\tout.println(res);\n\t\tout.close();\n\t}\n\tpublic static void init(int at, int d, int p) {\n\t\tdepth[at]=d;\n\t\tparent[at]=p;\n\t\tif(a[at][0]!=-1) init(a[at][0],d+1,at);\n\t\tinorder.add(at);\n\t\tid[at]=inorder.size()-1;\n\t\tif(a[at][1]!=-1) init(a[at][1],d+1,at);\n\t}\n\tstatic ArrayList<Integer> inorder;\n\tstatic int[][] a;\n\tstatic int[] id;\n\tstatic int[] depth,parent;\n\tstatic char[] c;\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\ttry\t{\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e){e.printStackTrace();}\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (st.hasMoreTokens())\treturn st.nextToken();\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() {return Long.parseLong(next());}\n\n\t\tpublic double nextDouble() {return Double.parseDouble(next());}\n\n\t\tpublic String nextLine() {\n\t\t\tString line = "";\n\t\t\tif(st.hasMoreTokens()) line = st.nextToken();\n\t\t\telse try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n\t\t\twhile(st.hasMoreTokens()) line += " "+st.nextToken();\n\t\t\treturn line;\n\t\t}\n\t}\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nvoid main0();\nint main() {\n  clock_t start, end;\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  main0();\n  return 0;\n}\nconst int dx[8] = {0, 1, -1, 0, 1, 1, -1, -1};\nconst int dy[8] = {1, 0, 0, -1, 1, -1, -1, 1};\nconst int N = 2e5 + 5;\nconst int M = 1e5;\nconst int INF = 0x3f3f3f3f;\nconst long long INFF = 0x3f3f3f3f3f3f3f3f;\nconst int mod = 998244353;\nconst double eps = 1e-6;\nmt19937 rnd(\n    (unsigned int)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>\nbool chkmin(T &x, T y) {\n  return y < x ? x = y, 1 : 0;\n}\ntemplate <typename T>\nbool chkmax(T &x, T y) {\n  return y > x ? x = y, 1 : 0;\n}\nint n, k;\nstring s;\nint lc[N], rc[N];\nchar ord[N];\nint idx[N];\nint p = 0;\nint flag[N];\nvoid dfs1(int u) {\n  if (lc[u]) dfs1(lc[u]);\n  ord[++p] = u;\n  idx[u] = p;\n  if (rc[u]) dfs1(rc[u]);\n}\nint rep[N];\nint dfs2(int u, int k) {\n  if (k == 0) return 0;\n  int cost = 0;\n  if (lc[u]) cost += dfs2(lc[u], k - cost);\n  if (flag[u] || cost) {\n    rep[u] = 1, cost++;\n    if (rc[u]) cost += dfs2(rc[u], k - cost);\n  }\n  return cost;\n}\nvoid main0() {\n  cin >> n >> k >> s;\n  s = "$" + s;\n  for (int i = 1; i <= n; ++i) {\n    cin >> lc[i] >> rc[i];\n  }\n  dfs1(1);\n  flag[ord[n]] = 0;\n  for (int i = n - 1; i >= 1; --i) {\n    int cur = ord[i];\n    int nxt = ord[i + 1];\n    flag[cur] = (s[cur] == s[nxt] ? flag[nxt] : s[cur] < s[nxt]);\n  }\n  dfs2(1, k);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= rep[ord[i]] + 1; ++j) {\n      cout << s[ord[i]];\n    }\n  }\n  cout << endl;\n}\n', '// Problem: E. Middle Duplication\n// Contest: Codeforces - Codeforces Round #763 (Div. 2)\n// URL: https://codeforces.com/contest/1623/problem/E\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// Author: abhidot\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n#define ll long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);\n#define pb push_back\n#define mod 1000000007\n#define mod2 998244353\n#define lld long double\n#define pii pair<int, int>\n#define ff first\n#define ss second\n#define all(x) (x).begin(), (x).end()\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define rep(i,x,y) for(int i=x; i<y; i++)\n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define V vector\n#define setbits(x) __builtin_popcountll(x)\n#define w(x)  int x; cin>>x; while(x--)\nusing namespace std;\nusing namespace __gnu_pbds; \ntemplate <typename num_t> using ordered_set = tree<num_t, null_type, less<num_t>, rb_tree_tag, tree_order_statistics_node_update>;\nconst long long N=200005, INF=2000000000000000000, inf = 2e9+5;\n\nint power(int a, int b, int p){\n\tif(a==0)\n\treturn 0;\n\tint res=1;\n\ta%=p;\n\twhile(b>0)\n\t{\n\t\tif(b&1)\n\t\tres=(res*a)%p;\n\t\tb>>=1;\n\t\ta=(a*a)%p;\n\t}\n\treturn res;\n}\n\n\nvoid print(bool n){\n    if(n){\n        cout<<"YES\\n";\n    }else{\n        cout<<"NO\\n";\n    }\n}\n\nint n, k;\nstring s;\n\nint btree[N][2];\nint p[N][20];\nvector<vector<int>> g;\nint tin[N], tout[N];\n\nvector<int> inorder;\nint tim=0;\n\n\nvoid traversal(int u){\n\tif(u==0) return;\n\ttin[u] = ++tim;\n\ttraversal(btree[u][0]);\n\tinorder.push_back(u);\n\ttraversal(btree[u][1]);\n\ttout[u] = ++tim;\n}\n\nint32_t main()\n{\n    IOS;\n    cin>>n>>k>>s;\n    s = "$"+s;\n    vector<int> col(n+1, 0);\n    col[0]=1;\n    for(int i=1;i<=n;i++){\n    \tcin>>btree[i][0]>>btree[i][1];\n    \tif(btree[i][0]) p[btree[i][0]][0]=i;\n    \tif(btree[i][1]) p[btree[i][1]][0]=i;\n    }\n    \n    traversal(1);\n    \n    // Binary Lifting\n    for(int j=1;j<20;j++){\n    \tfor(int i=1;i<=n;i++){\n    \t\tp[i][j] = p[p[i][j-1]][j-1];\n    \t}\n    }\n    \n    int left=k;\n    int i;\n    \n    auto calc = [&](int on){\n    \tif(col[on]) return 0LL;\n    \tint ans=1;\n    \t// cout<<on<<": ";\n    \tfor(int j=19;j>=0;j--){\n    \t\tif(col[p[on][j]]==0){\n    \t\t\ton = p[on][j];\n    \t\t\t// cout<<on<<" ";\n    \t\t\tans+=(1<<j);\n    \t\t}\n    \t}\n    \t// cout<<": "<<ans<<"\\n";\n    \t// cout<<"\\n";\n    \t\n    \treturn ans;\n    };\n    \n    string d;\n    d+=s[inorder[0]];\n    int val[n+1]={0};\n    val[inorder[0]]=0;\n    for(int i=1;i<n;i++){\n    \tif(s[inorder[i]]!=d.back()){\n    \t\td+=s[inorder[i]];\n    \t}\n    \tval[inorder[i]] = d.size()-1;\n    }\n    \n    \n    int upto=0;\n    for(i=0;inorder[i]!=1;i++){\n    \tif(val[inorder[i]]==d.size()-1||d[val[inorder[i]]]>d[val[inorder[i]]+1]||tin[inorder[i+1]]<upto){\n    \t\tupto = max(upto, tout[inorder[i]]);\n    \t\tcontinue;\n    \t}\n    \tint req = calc(inorder[i]);\n    \tif(req>left) continue;\n    \tleft-=req;\n    \tint on=inorder[i];\n    \twhile(on&&col[on]==0){\n    \t\tcol[on]=1;\n    \t\ton = p[on][0];\n    \t}\n    }\n    \n    // cout<<inorder[i]<<" "<<inorder[i+1]<<" "<<val[inorder[i]]<<" "<<val[inorder[i]+1]<<"\\n";\n\tif(i<n-1&&val[inorder[i]]<d.size()-1&&d[val[inorder[i]]]<d[val[inorder[i]]+1]){\n\t\tint req = calc(inorder[i]);\n    \tif(req<=left){\n\t    \tleft-=req;\n\t    \tint on=inorder[i];\n\t    \twhile(col[on]==0){\n\t    \t\tcol[on]=1;\n\t    \t\ton = p[on][0];\n\t    \t}\n    \t}\t\n\t}\n    \n    if(col[1]==1){\n    \ti++;\n    \tfor(;i<n-1;i++){\n    \t\tif(val[inorder[i]]==d.size()-1||d[val[inorder[i]]]>d[val[inorder[i]]+1]||tin[inorder[i+1]]<upto){\n    \t\t\tupto = max(upto, tout[inorder[i]]);\n    \t\t}\n\t    \tint req = calc(inorder[i]);\n\t    \tif(req>left) continue;\n\t    \tleft-=req;\n\t    \tint on=inorder[i];\n\t    \twhile(col[on]==0){\n\t    \t\tcol[on]=1;\n\t    \t\ton = p[on][0];\n\t    \t}\n    \t}\n    }\n    \n    for(int i=0;i<n;i++){\n    \tcout<<s[inorder[i]];\n    \tif(col[inorder[i]]) cout<<s[inorder[i]];\n    }\n}', '#include <bits/stdc++.h>\n#pragma GCC optimize("O3")\n#pragma GCC target("sse4")\nusing namespace std;\ntemplate <class T>\nusing pq = priority_queue<T>;\ntemplate <class T>\nusing pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>\nbool ckmin(T& a, const T& b) {\n  return b < a ? a = b, 1 : 0;\n}\ntemplate <class T>\nbool ckmax(T& a, const T& b) {\n  return a < b ? a = b, 1 : 0;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nvoid __print(int x) { cerr << x; }\nvoid __print(long x) { cerr << x; }\nvoid __print(long long x) { cerr << x; }\nvoid __print(unsigned x) { cerr << x; }\nvoid __print(unsigned long x) { cerr << x; }\nvoid __print(unsigned long long x) { cerr << x; }\nvoid __print(float x) { cerr << x; }\nvoid __print(double x) { cerr << x; }\nvoid __print(long double x) { cerr << x; }\nvoid __print(char x) { cerr << \'\\\'\' << x << \'\\\'\'; }\nvoid __print(const char* x) { cerr << \'\\"\' << x << \'\\"\'; }\nvoid __print(const string& x) { cerr << \'\\"\' << x << \'\\"\'; }\nvoid __print(bool x) { cerr << (x ? "true" : "false"); }\ntemplate <typename T, typename V>\nvoid __print(const pair<T, V>& x) {\n  cerr << \'{\';\n  __print(x.first);\n  cerr << ", ";\n  __print(x.second);\n  cerr << \'}\';\n}\ntemplate <typename T>\nvoid __print(const T& x) {\n  int first = 0;\n  cerr << \'{\';\n  for (auto& i : x) cerr << (first++ ? ", " : ""), __print(i);\n  cerr << "}";\n}\nvoid _print() { cerr << "]\\n"; }\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {\n  __print(t);\n  if (sizeof...(v)) cerr << ", ";\n  _print(v...);\n}\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 200001;\nint N, K;\nstring S;\nstring nxt;\nint L[MX], R[MX];\nbool dup[MX];\nint P[MX];\nstring ans;\nvoid dfs(int v, int lstDup) {\n  if (v == 0) return;\n  P[L[v]] = v;\n  P[R[v]] = v;\n  dfs(L[v], lstDup + 1);\n  if (!dup[v] && nxt[v] > S[v] && lstDup <= K) {\n    int cv = v;\n    K -= lstDup;\n    while (lstDup) {\n      dup[cv] = true;\n      cv = P[cv];\n      lstDup--;\n    }\n  }\n  if (dup[v]) {\n    dfs(R[v], lstDup + 1);\n  }\n}\nvoid buildAns(int v) {\n  if (v == 0) return;\n  buildAns(L[v]);\n  ans += S[v];\n  if (dup[v]) ans += S[v];\n  buildAns(R[v]);\n}\nvoid solve() {\n  cin >> N >> K;\n  cin >> S;\n  S = " " + S;\n  for (int i = 1; i < (N); i++) cin >> L[i] >> R[i];\n  nxt[(int)(S).size() - 1] = \'a\' - 1;\n  for (int i = ((int)(S).size() - 1) - 1; i >= 0; i--) {\n    if (S[i] != S[i + 1]) {\n      nxt[i] = S[i + 1];\n    } else\n      nxt[i] = nxt[i + 1];\n  }\n  P[1] = -1;\n  dfs(1, 1);\n  buildAns(1);\n  cout << ans << nl;\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin.exceptions(cin.failbit);\n  int T = 1;\n  while (T--) {\n    solve();\n  }\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\nconst int M = 4e5 + 1;\nconst long long MOD = 1e9 + 7;\nconst long long MOD1 = 998244353;\nconst long long INF = 1e17;\nconst int inf = 1e9;\nlong long n, m, k;\nstring s;\nvector<int> l(n + 1), r(n + 1);\nvector<char> val(n + 1);\nvector<int> pos(n + 1);\nvector<bool> dup(n + 1), good(n + 1);\nstring dfs1(int node, int len) {\n  if (node == 0) return "";\n  string before = dfs1(l[node], len);\n  pos[before.length() + len] = node;\n  return before + val[node] + dfs1(r[node], len + before.size() + 1);\n}\nvoid dfs2(int node, int depth) {\n  if (depth > k || node == 0) return;\n  dfs2(l[node], depth + 1);\n  if (dup[l[node]])\n    dup[node] = true;\n  else if (good[node]) {\n    dup[node] = true;\n    k -= depth;\n  }\n  if (dup[node]) {\n    dfs2(r[node], 1);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  l.clear();\n  r.clear();\n  val.clear();\n  pos.clear();\n  dup.clear();\n  good.clear();\n  l.resize(n + 1);\n  r.resize(n + 1);\n  val.resize(n + 1);\n  pos.resize(n + 1);\n  dup.resize(n + 1);\n  good.resize(n + 1);\n  for (int i = 1; i <= n; i++) {\n    char c;\n    cin >> c;\n    val[i] = c;\n  }\n  for (int i = 1; i <= n; i++) {\n    int l1, r1;\n    cin >> l1 >> r1;\n    l[i] = l1;\n    r[i] = r1;\n  }\n  s = dfs1(1, 0);\n  for (int i = 1; i <= n; i++) {\n    if (val[pos[i]] <= val[pos[i] + 1]) {\n      good[pos[i]] = true;\n    }\n  }\n  dfs2(1, 1);\n  for (int i = 0; i < n; i++) {\n    cout << val[pos[i]];\n    if (dup[pos[i]]) {\n      cout << val[pos[i]];\n    }\n  }\n  cout << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int tc = 1;\n  for (int t = 1; t <= tc; t++) {\n    solve();\n  }\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  vector<pair<long long, long long>> parent(n);\n  parent[0] = make_pair(-1, -1);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  char last = char(1);\n  initial[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  cerr << initial << endl;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long sum = 0;\n    bool ok = 1;\n    long long cur = pos[i];\n    cerr << "testing " << i << " " << initial[i] << endl;\n    while (cur != -1) {\n      if (taken[cur]) break;\n      sum++;\n      cerr << cur << " " << parent[cur].first << " " << parent[cur].second\n           << endl;\n      if (cur == 0 || taken[parent[cur].first]) break;\n      if (parent[cur].second) {\n        ok = 0;\n        break;\n      }\n      cur = parent[cur].first;\n    }\n    if (ok and k >= sum) {\n      cerr << initial[i] << " was ok with sum of " << sum << " and k is " << k\n           << endl;\n      long long cur = pos[i];\n      while (cur != -1) {\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      k -= sum;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nconst int MAXN = 200005;\nlong long qpow(long long d, long long z) {\n  long long res = 1;\n  for (; z; z >>= 1) {\n    if (z & 1) res = res * d % MOD;\n    d = d * d % MOD;\n  }\n  return res;\n}\nint n, k;\nchar str[MAXN];\nint ch[MAXN][2], fa[MAXN];\nint p[MAXN], rk[MAXN], cur = 0;\nint dep[MAXN];\nvoid inord(int x) {\n  if (x == 0) return;\n  dep[x] = dep[fa[x]] + 1;\n  inord(ch[x][0]);\n  p[++cur] = x;\n  rk[x] = cur;\n  inord(ch[x][1]);\n}\nint diff[MAXN];\nbool rep[MAXN];\nint curdep;\nvoid solve(int x, int fas) {\n  if (x == 0) return;\n  solve(ch[x][0], fas);\n  int remcd = curdep;\n  if (fas == 0) {\n    int i = rk[x];\n    int z = diff[i];\n    if (str[x] < str[p[z]] && dep[x] - curdep <= k) {\n      int rc = dep[x] - curdep, xd = x;\n      for (int i = 1; i <= rc; i++) {\n        rep[xd] = 1;\n        xd = fa[xd];\n      }\n      k -= rc;\n      curdep = dep[x];\n    } else {\n      fas++;\n    }\n  }\n  solve(ch[x][1], fas);\n  curdep = remcd;\n}\nint main() {\n  scanf("%d%d", &n, &k);\n  scanf("%s", str + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", &ch[i][0], &ch[i][1]);\n    fa[ch[i][0]] = fa[ch[i][1]] = i;\n  }\n  fa[0] = 0;\n  dep[1] = 1;\n  str[n + 1] = 0;\n  inord(1);\n  for (int i = n; i >= 1; i--) {\n    if (str[p[i]] != str[p[i + 1]])\n      diff[i] = i + 1;\n    else\n      diff[i] = diff[i + 1];\n  }\n  curdep = 0;\n  solve(1, 0);\n  for (int i = 1; i <= n; i++) {\n    printf("%c", str[p[i]]);\n    if (rep[p[i]]) printf("%c", str[p[i]]);\n  }\n  printf("\\n");\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nchar s[N], ans[N];\nint box[26], node[N], flag[N], fa[N][25];\nint l[N], r[N], nex[N], cnt = 0;\nvoid dfs(int x) {\n  if (!x) return;\n  for (int i = 1; i <= 20; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];\n  dfs(l[x]);\n  ans[++cnt] = s[x];\n  node[cnt] = x;\n  dfs(r[x]);\n}\nvoid floodfill(int x) {\n  if (!x) return;\n  if (flag[x] != 0) return;\n  flag[x] = -1;\n  floodfill(l[x]);\n  floodfill(r[x]);\n}\nint getans(int x) {\n  if (flag[x] == 1 || x == 0) return 0;\n  return getans(fa[x][0]) + 1;\n}\nvoid DFS(int x) {\n  if (!x) return;\n  DFS(l[x]);\n  ans[++cnt] = s[x];\n  if (flag[x] == 1) ans[++cnt] = s[x];\n  node[cnt] = x;\n  DFS(r[x]);\n}\nint getfa(int x, int y) {\n  for (int i = 20; i >= 0; i--)\n    if (y >= (1 << i)) {\n      x = fa[x][i];\n      y -= (1 << i);\n    }\n  return x;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  scanf("%s", s + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d %d", &l[i], &r[i]);\n    fa[l[i]][0] = fa[r[i]][0] = i;\n  }\n  fa[0][0] = 0;\n  flag[0] = 1;\n  dfs(1);\n  memset(nex, 0x3f, sizeof(nex));\n  memset(box, 0x3f, sizeof(box));\n  for (int i = n; i >= 1; i--) {\n    box[ans[i] - \'a\'] = i;\n    for (int j = 0; j <= 25; j++) {\n      if (j != ans[i] - \'a\') nex[i] = min(nex[i], box[j]);\n    }\n  }\n  for (int i = 1; i <= cnt; i++) {\n    if (flag[node[i]] != 0) continue;\n    if (nex[i] == 0x3f3f3f3f || ans[nex[i]] < ans[i]) {\n      floodfill(node[i]);\n      continue;\n    }\n    int val = getfa(node[i], m);\n    if (flag[val]) {\n      for (int j = node[i]; flag[j] == 0; j = fa[j][0]) {\n        flag[j] = 1;\n        m--;\n      }\n    } else\n      floodfill(node[i]);\n  }\n  cnt = 0;\n  DFS(1);\n  for (int i = 1; i <= cnt; i++) printf("%c", ans[i]);\n}\n', 'import java.io.*;\nimport java.util.*;\n\npublic class e {\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int k = Integer.parseInt(tokenizer.nextToken());\n        String lab = in.readLine();\n        node[] list = new node[n];\n        for (int i = 0; i < n; i++) {\n            list[i] = new node(i, lab.substring(i, i + 1));\n        }\n        for (int i = 0; i < n; i++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            int left = Integer.parseInt(tokenizer.nextToken()) - 1;\n            int right = Integer.parseInt(tokenizer.nextToken()) - 1;\n            if (left != -1) {\n                list[i].left = list[left];\n                list[left].parent = list[i];\n            }\n            if (right != -1) {\n                list[i].right = list[right];\n                list[right].parent = list[i];\n            }\n            // System.out.println(list[i].left.id + " " + list[i].right.id);\n        }\n        node[] order = new node[n];\n        inorder(order, 0, list[0]);\n        for (int i = 0; i < n; i++) {\n            order[i].inorder = i;\n        }\n        int rem = k;\n        ArrayList<String> vals = new ArrayList<>();\n        for (int i = order.length - 1; i >= 0; i--) {\n            if (vals.size() == 0 || !order[i].label.equals(vals.get(vals.size() - 1))) {\n                vals.add(order[i].label);\n            }\n            if (vals.size() <= 1 || vals.get(vals.size() - 1).compareTo(vals.get(vals.size() - 2)) >= 0) {\n                order[i].good = false;\n            } else {\n                order[i].good = true;\n            }\n        }\n        dfs(list[0], null); // fix parent good values\n        dfs(list[0], 1);\n        for (int i = 0; i < order.length; i++) {\n            if (order[i].cost <= rem && (order[i].good && (order[i].constraint == null || order[i].constraint.used)) && !order[i].used) {\n                rem -= order[i].cost;\n                update(order[i]);\n            }\n        }\n        StringBuilder b = new StringBuilder();\n        for (int i = 0; i < order.length; i++) {\n            b.append(order[i].label);\n            if (order[i].used) {\n                b.append(order[i].label);\n            }\n        }\n        System.out.println(b);\n        in.close();\n        out.close();\n    }\n\n    public static void dfs(node n, node c) {\n        if (n == null) {\n            return;\n        }\n        if(c != null){\n            n.constraint = c;\n        }\n        dfs(n.left, c);\n        if(!n.good){\n            c = n;\n        }\n        dfs(n.right, c);\n    }\n\n\n    public static void dfs(node n, int val) {\n        if (n == null || n.used)\n            return;\n        n.cost = val;\n        dfs(n.left, val + 1);\n        dfs(n.right, val + 1);\n    }\n\n    public static void update(node n) {\n        n.used = true;\n        dfs(n, 0);\n        if (n.parent != null && !n.parent.used) {\n            update(n.parent);\n        }\n    }\n\n    public static int inorder(node[] order, Integer index, node n) {\n        if (n != null) {\n            index = inorder(order, index, n.left);\n            order[index++] = n;\n            index = inorder(order, index, n.right);\n        }\n        return index;\n    }\n\n    public static class node {\n        int id;\n        String label;\n        node left = null;\n        node right = null;\n        node parent = null;\n        node constraint = null;\n        int cost = 0;\n        boolean used = false;\n        boolean good = false;\n        int inorder = 0;\n\n        public node(int id, String label) {\n            this.id = id;\n            this.label = label;\n        }\n\n        public int cost() {\n            int val = 0;\n            node pointer = this;\n            while (pointer != null && !pointer.used) {\n                pointer = pointer.parent;\n                val++;\n            }\n            return cost = val;\n        }\n    }\n}', "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 202020;\nint n, k;\nstring c;\nint l[maxn], r[maxn];\nvector<int> in_order;\nvoid build_in_order(int u) {\n  if (u == 0) return;\n  build_in_order(l[u]);\n  in_order.push_back(u);\n  build_in_order(r[u]);\n}\nbool good[maxn];\nbool duplicated[maxn];\nvoid dfs(int u, int cost = 1) {\n  if (u == 0) return;\n  if (cost > k) return;\n  dfs(l[u], cost + 1);\n  if (duplicated[l[u]]) {\n    duplicated[u] = true;\n  } else if (good[u]) {\n    duplicated[u] = true;\n    k -= cost;\n  }\n  if (duplicated[u])\n    dfs(r[u], 1);\n  else\n    dfs(r[u], cost + 1);\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  cin >> n >> k;\n  cin >> c;\n  c = ' ' + c;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  build_in_order(1);\n  char last_diff = c[in_order.back()];\n  for (int i = n - 2; i >= 0; --i) {\n    int u = in_order[i];\n    int v = in_order[i + 1];\n    if (c[u] != c[v]) {\n      last_diff = c[v];\n    }\n    if (c[u] < last_diff) {\n      good[u] = true;\n    }\n  }\n  dfs(1);\n  for (auto u : in_order) {\n    cout << c[u];\n    if (duplicated[u]) cout << c[u];\n  }\n  return 0;\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nconst int MAXN = 200005;\nlong long qpow(long long d, long long z) {\n  long long res = 1;\n  for (; z; z >>= 1) {\n    if (z & 1) res = res * d % MOD;\n    d = d * d % MOD;\n  }\n  return res;\n}\nint n, k;\nchar str[MAXN];\nint ch[MAXN][2], fa[MAXN];\nint p[MAXN], rk[MAXN], cur = 0;\nint dep[MAXN];\nvoid inord(int x) {\n  if (x == 0) return;\n  dep[x] = dep[fa[x]] + 1;\n  inord(ch[x][0]);\n  p[++cur] = x;\n  rk[x] = cur;\n  inord(ch[x][1]);\n}\nint diff[MAXN];\nbool rep[MAXN];\nint curdep;\nvoid solve(int x, int fas) {\n  if (x == 0) return;\n  solve(ch[x][0], fas);\n  int remcd = curdep;\n  if (fas == 0) {\n    int i = rk[x];\n    int z = diff[i];\n    if (str[x] < str[p[z]] && dep[x] - curdep <= k) {\n      int rc = dep[x] - curdep, xd = x;\n      for (int i = 1; i <= rc; i++) {\n        rep[xd] = 1;\n        xd = fa[xd];\n      }\n      k -= rc;\n      curdep = x;\n    } else {\n      fas++;\n    }\n  }\n  solve(ch[x][1], fas);\n  curdep = remcd;\n}\nint main() {\n  scanf("%d%d", &n, &k);\n  scanf("%s", str + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", &ch[i][0], &ch[i][1]);\n    fa[ch[i][0]] = fa[ch[i][1]] = i;\n  }\n  fa[0] = 0;\n  dep[1] = 1;\n  str[n + 1] = 0;\n  inord(1);\n  for (int i = n; i >= 1; i--) {\n    if (str[p[i]] != str[p[i + 1]])\n      diff[i] = i + 1;\n    else\n      diff[i] = diff[i + 1];\n  }\n  curdep = 0;\n  solve(1, 0);\n  for (int i = 1; i <= n; i++) {\n    printf("%c", str[p[i]]);\n    if (rep[p[i]]) printf("%c", str[p[i]]);\n  }\n  printf("\\n");\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nint SIZE(T(&t)) {\n  return t.size();\n}\ntemplate <typename T, size_t N>\nint SIZE(T (&t)[N]) {\n  return N;\n}\nstring to_string(char t) { return "\'" + string({t}) + "\'"; }\nstring to_string(bool t) { return t ? "true" : "false"; }\nstring to_string(const string& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)), _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += t[i];\n  }\n  return \'"\' + ret + \'"\';\n}\nstring to_string(const char* t) {\n  string ret(t);\n  return to_string(ret);\n}\ntemplate <size_t N>\nstring to_string(const bitset<N>& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)); i <= min(x2, SIZE(t) - 1); ++i) {\n    ret += t[i] + \'0\';\n  }\n  return to_string(ret);\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1 = 0, int x2 = 1e9, Coords... C);\ntemplate <typename T, typename S>\nstring to_string(const pair<T, S>& t) {\n  return "(" + to_string(t.first) + ", " + to_string(t.second) + ")";\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1, int x2, Coords... C) {\n  string ret = "[";\n  x1 = min(x1, SIZE(t));\n  auto e = begin(t);\n  advance(e, x1);\n  for (int i = x1, _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += to_string(*e, C...) + (i != _i ? ", " : "");\n    e = next(e);\n  }\n  return ret + "]";\n}\ntemplate <int Index, typename... Ts>\nstruct print_tuple {\n  string operator()(const tuple<Ts...>& t) {\n    string ret = print_tuple<Index - 1, Ts...>{}(t);\n    ret += (Index ? ", " : "");\n    return ret + to_string(get<Index>(t));\n  }\n};\ntemplate <typename... Ts>\nstruct print_tuple<0, Ts...> {\n  string operator()(const tuple<Ts...>& t) { return to_string(get<0>(t)); }\n};\ntemplate <typename... Ts>\nstring to_string(const tuple<Ts...>& t) {\n  const auto Size = tuple_size<tuple<Ts...>>::value;\n  return print_tuple<Size - 1, Ts...>{}(t);\n}\nvoid dbgr() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgr(Heads H, Tails... T) {\n  cout << to_string(H) << " | ";\n  dbgr(T...);\n}\nvoid dbgs() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgs(Heads H, Tails... T) {\n  cout << H << " ";\n  dbgs(T...);\n}\nconst int N = 1e5 + 5;\nconst long long INF = 1e18 + 7;\nconst int MAXA = 1e9;\nconst int B = sqrt(N) + 5;\nint a[N], l[N], r[N], pv[N];\nbool dou[N];\nstring s;\ndeque<char> ans[N];\ndeque<int> pos[N];\nint v[N];\nint n, k;\nvoid dfs(int u) {\n  if (u == 0) return;\n  dfs(l[u]);\n  dfs(r[u]);\n  if (ans[l[u]].size() > ans[r[u]].size()) {\n    swap(ans[u], ans[l[u]]);\n    swap(pos[u], pos[l[u]]);\n    ans[u].push_back(s[u]);\n    pos[u].push_back(u);\n    for (char i : ans[r[u]]) {\n      ans[u].push_back(i);\n    }\n    for (int i : pos[r[u]]) {\n      pos[u].push_back(i);\n    }\n  } else {\n    swap(ans[u], ans[r[u]]);\n    swap(pos[u], pos[r[u]]);\n    ans[u].push_front(s[u]);\n    pos[u].push_front(u);\n    reverse(ans[l[u]].begin(), ans[l[u]].end());\n    reverse(pos[l[u]].begin(), pos[l[u]].end());\n    for (char i : ans[l[u]]) {\n      ans[u].push_front(i);\n    }\n    for (int i : pos[l[u]]) {\n      pos[u].push_front(i);\n    }\n  }\n}\nbool dfs_opt(int u, int h) {\n  bool f = false;\n  if (pv[u] < n && s[pv[u]] <= s[pv[u] + 1] && k >= h) {\n    k -= h;\n    dou[u] = true;\n    if (l[u]) dfs_opt(l[u], 1);\n    if (r[u]) dfs_opt(r[u], 1);\n    return true;\n  } else {\n    if (l[u]) f |= dfs_opt(l[u], h + 1);\n    if (f) dou[u] = true;\n    return false;\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  cin >> s;\n  s = " " + s;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  dfs(1);\n  s = " ";\n  for (char i : ans[1]) s += i;\n  for (int i = 0; i < n; ++i) v[i + 1] = pos[1][i], pv[v[i + 1]] = i + 1;\n  dfs_opt(1, 1);\n  for (int i = 1; i <= n; ++i) {\n    cout << s[i];\n    if (dou[v[i]]) cout << s[i];\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n', '// package c1623;\n\nimport java.io.File;\nimport java.lang.invoke.MethodHandles;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n//\n// Codeforces Round #763 (Div. 2) 2021-12-28 05:35\n// E. Middle Duplication\n// https://codeforces.com/contest/1623/problem/E\n// time limit per test 1 second; memory limit per test 256 megabytes\n// public class Pseudo for \'Source should satisfy regex [^{}]*public\\s+(final)?\\s*class\\s+(\\w+).*\'\n//\n// A binary tree of n nodes is given. Nodes of the tree are numbered from 1 to n and the root is the\n// node 1. Each node can have no child, only one left child, only one right child, or both children.\n// For convenience, let\'s denote l_u and r_u as the left and the right child of the node u\n// respectively, l_u = 0 if u does not have the left child, and r_u = 0 if the node u does not have\n// the right child.\n//\n// Each node has a string label, initially is a single character c_u. Let\'s define the string\n// representation of the binary tree as the concatenation of the labels of the nodes in the .\n// Formally, let f(u) be the string representation of the tree rooted at the node u. f(u) is defined\n// as follows: <div class="MathJax_Display" style="text-align: center;"></div> f(u) = \\begin{cases}\n// \\texttt{<empty string>}, & \\text{if }u = 0; \\\\ f(l_u) + c_u + f(r_u) & \\text{otherwise},\n// \\end{cases} where + denotes the string concatenation operation.\n//\n// This way, the string representation of the tree is f(1).\n//\n// For each node, we can its label , that is, assign c_u with c_u + c_u, but only if u is the root\n// of the tree, or if its parent also has its label duplicated.\n//\n// You are given the tree and an integer k. What is the lexicographically smallest string\n// representation of the tree, if we can duplicate labels of at most k nodes?\n//\n// A string a is lexicographically smaller than a string b if and only if one of the following\n// holds:\n//  * a is a prefix of b, but a \\ne b;\n//  * in the first position where a and b differ, the string a has a letter that appears earlier in\n//    the alphabet than the corresponding letter in b. </div><div class="input-specification"><div\n// class="section-title">Input</div>\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Input\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Output\n//\n// Print a single line, containing the lexicographically smallest string representation of the tree\n// if at most k nodes have their labels duplicated.\n//\n// Example\n/*\ninput:\n4 3\nabab\n2 3\n0 0\n0 4\n0 0\n\noutput:\nbaaaab\n\ninput:\n8 2\nkadracyn\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndaarkkcyan\n\ninput:\n8 3\nkdaracyn\n2 5\n0 3\n0 4\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndarkcyan\n*/\n// Note\n//\n// The images below present the tree for the examples. The number in each node is the node number,\n// while the subscripted letter is its label. To the right is the string representation of the tree,\n// with each letter having the same color as the corresponding node.\n//\n// Here is the tree for the first example. Here we duplicated the labels of nodes 1 and 3. We should\n// not duplicate the label of node 2 because it would give us the string "", which is\n// lexicographically greater than "".\n// https://espresso.codeforces.com/30116fa124ec3edbd4c16ac29fa8eb45c19cc171.png\n//\n// In the second example, we can duplicate the labels of nodes 1 and 2. Note that only duplicating\n// the label of the root will produce a worse result than the initial string.\n// https://espresso.codeforces.com/e66a56b1c8dee019f4f4c138ee0333caf44b312c.png\n//\n// In the third example, we should not duplicate any character at all. Even though we would want to\n// duplicate the label of the node 3, by duplicating it we must also duplicate the label of the node\n// 2, which produces a worse result.\n// https://espresso.codeforces.com/19b0d4c5514801c166e9b3f0ef4c110939711a20.png\n//\n// There is no way to produce string "" from a tree with the initial string representation "" :(.\n//\npublic class C1623E {\n  static final int MOD = (int)1e9+7;\n  static final Random RAND = new Random();\n\n  static String solve(String s, int k, int[][] lr) {\n    // Note that both s and lr have length n + 1\n    int n = s.length() - 1;\n\n    // [parent, depth, subtree size, dfs-done, duplicate, in-order index]\n    //  0       1      2             3         4          5\n    int[][] nodes = dfsNodes(lr);\n\n    bfsInOrder(lr, nodes);\n\n    int[] ids = new int[n];\n    for (int i = 1; i <= n; i++) {\n      ids[nodes[i][5]] = nodes[i][0];\n    }\n\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    // System.out.format("%s\\n", Utils.trace(ids));\n\n    // Note that ids[] is 0-indexed!\n    int b = 0;\n    int avail = k;\n    while (b < n) {\n      int v = ids[b];\n      // System.out.format("  b:%d v:%d depth:%d k:%d\\n", b, v, nodes[v][1], k);\n      if (nodes[v][1] > k) {\n        // don\'t bother if v is too deep\n        b++;\n        continue;\n      }\n      char c = s.charAt(v);\n      int e = b + 1;\n      while (e < n && s.charAt(ids[e]) == c) {\n        e++;\n      }\n      boolean duplicate = e < n && s.charAt(ids[e]) > c;\n      // System.out.format("  b:%d v:%d e:%d dup:%b\\n", b, v, e, duplicate);\n      if (!duplicate) {\n        b = e;\n        continue;\n      }\n\n      // We may duplicate some nodes between [b,e) as long as there is budget\n      for (int i = b; i < e; i++) {\n        int id = ids[i];\n        if (nodes[id][4] == 1) {\n          // skip ones already decided to duplicate earlier (part chain).\n          continue;\n        }\n\n        // Can we afford duplicate i?\n        // walk up parent chain until a duplicated node or root\n        int needed = 0;\n        // w is the node id\n        int w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          needed++;\n          int p = nodes[w][0];\n          if (p != 0 && nodes[p][4] == 0 && nodes[p][5] < nodes[w][5]) {\n            // do not trigger duplicate of an ancestor in front as it will make things worse\n            needed = Integer.MAX_VALUE;\n            break;\n          }\n          // if (p != 0 && nodes[p][4])\n          w = nodes[w][0];\n        }\n        // System.out.format("    i:%d id:%d needed:%d avail:%d\\n", i, id, needed, avail);\n        if (needed > avail) {\n          continue;\n        }\n\n        // Set duplicate flag up the chain until an ancestor already set or the parent of root.\n        w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          nodes[w][4] = 1;\n          avail--;\n          w = nodes[w][0];\n        }\n        myAssert(avail >= 0);\n      }\n      b = e;\n    }\n    // System.out.format("%s\\n", Utils.trace(ids));\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    StringBuilder sb = new StringBuilder();\n    for (int v : ids) {\n      sb.append(s.charAt(v));\n      if (nodes[v][4] == 1) {\n        sb.append(s.charAt(v));\n      }\n    }\n    return sb.toString();\n  }\n\n  // [parent, depth, subtree size, done]\n  static int[][] dfsNodes(int[][] lr) {\n    int n = lr.length - 1;\n    int[][] nodes = new int[n + 1][6];\n    Stack<Integer> stack = new Stack<>();\n    stack.push(1);\n    nodes[1][1] = 1;\n    while (!stack.isEmpty()) {\n      int v = stack.peek();\n      // System.out.format("  v:%d %s\\n", v, Arrays.toString(nodes[v]));\n      int l = lr[v][0];\n      int r = lr[v][1];\n      if (l == 0 && r == 0) {\n        nodes[v][2] = 1;\n        nodes[v][3] = 1;\n        stack.pop();\n      } else if (l > 0 && r == 0) {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        } else {\n          nodes[v][2] = 1 + nodes[l][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else if (l == 0 && r > 0) {\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        } else {\n          nodes[v][2] = 1 + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        }\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        }\n        if (nodes[l][3] == 1 && nodes[r][3] == 1) {\n          nodes[v][2] = 1 + nodes[l][2] + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      }\n    }\n    return nodes;\n  }\n\n  // Fill nodes[i][5] which is the 0-based index of in-order traverse of the node.\n  // Note that both lr and nodes are 1-based\n  static void bfsInOrder(int[][] lr, int[][] nodes) {\n    int n = lr.length - 1;\n    Queue<int[]> q = new LinkedList<>();\n    q.add(new int[] {1, 0});\n    while (!q.isEmpty()) {\n      int[] e = q.poll();\n      int v = e[0];\n      int offset = e[1];\n      int l = lr[v][0];\n      int r = lr[v][1];\n      int idx = offset;\n      if (l > 0) {\n        q.add(new int[] {l, idx});\n        idx += nodes[l][2];\n      }\n      nodes[v][5] = idx;\n      if (r > 0) {\n        q.add(new int[] {r, idx});\n      }\n    }\n  }\n\n  static String trace(int[] a) {\n    StringBuilder sb = new StringBuilder();\n    for (int v : a) {\n     if (sb.length() > 0) {\n       sb.append(\' \');\n     }\n      sb.append(v);\n    }\n    return sb.toString();\n  }\n\n  static void myAssert(boolean cond) {\n    if (!cond) {\n      throw new RuntimeException("Unexpected");\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner in = getInputScanner();\n    int n = in.nextInt();\n    int k = in.nextInt();\n    String s = \' \' + in.next();\n    int[][] lr = new int[n + 1][2];\n    for (int i = 1; i <= n; i++) {\n      lr[i][0] = in.nextInt();\n      lr[i][1] = in.nextInt();\n    }\n    String ans = solve(s, k, lr);\n    System.out.println(ans);\n    in.close();\n  }\n\n  static Scanner getInputScanner() {\n    try {\n      final String USERDIR = System.getProperty("user.dir");\n      final String CNAME = MethodHandles.lookup().lookupClass().getSimpleName();\n      final File fin = new File(USERDIR + "/io/c" + CNAME.substring(1,5) + "/" + CNAME + ".in");\n      return fin.exists() ? new Scanner(fin) : new Scanner(System.in);\n    } catch (Exception e) {\n      return new Scanner(System.in);\n    }\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint n, k, ls[200005], rs[200005];\nint d[200005], fa[200005];\nint cnt, rk[200005];\nint vis[200005];\nchar a[200005];\nvoid dfs(int u, int fa) {\n  if (u == 0) return;\n  d[u] = d[fa] + 1;\n  dfs(ls[u], u);\n  rk[++cnt] = u;\n  dfs(rs[u], u);\n}\nvoid to(int u) {\n  if (u == 0) return;\n  if (vis[u] == 0) {\n    vis[u] = -1;\n    to(ls[u]);\n    to(rs[u]);\n  }\n}\nvoid print(int u) {\n  if (u == 0) return;\n  print(ls[u]);\n  printf("%c", a[u]);\n  if (vis[u] == 1) printf("%c", a[u]);\n  print(rs[u]);\n}\nint main() {\n  scanf("%d%d\\n%s", &n, &k, a + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", &ls[i], &rs[i]);\n    fa[ls[i]] = fa[rs[i]] = i;\n  }\n  dfs(1, 0);\n  int nxt = 1;\n  a[cnt + 1] = \'a\' - 1;\n  for (int i = 1; i < cnt; i++) {\n    int x = rk[i];\n    while (a[x] == a[rk[nxt]]) nxt++;\n    if (a[rk[i]] < a[rk[nxt]] && d[x] <= k) {\n      k -= d[x];\n      while (vis[x] == 0) {\n        if (x == 0) break;\n        vis[x] = 1;\n        x = fa[x];\n      }\n    } else\n      to(x);\n  }\n  print(1);\n  return 0;\n}\n', '#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <fstream>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \n#define int long long\nusing namespace __gnu_pbds;\nusing namespace std;\n\nconst long long inf = 1e18;\nconst long long Nmax =2e5+5;\nconst long long MOD = 998244353;\n\ntypedef tree<long long,null_type,less<long long>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\nlong long ab(long long a)\n{\n    if(a<0)return -a;else return a;\n}\nint l[Nmax],r[Nmax],n,sz=1,id[Nmax],nxt[Nmax],dup[Nmax]={0},sdup[Nmax]={0},k;\nchar c[Nmax],str[Nmax];\nvoid dfs1(int u)\n{\n    if(l[u]!=0)dfs1(l[u]);\n    id[u]=sz;\n    str[sz++]=c[u];\n    if(r[u]!=0)dfs1(r[u]);\n}\nvoid dfs2(int u,int dep)\n{\n    if(dep>k)return;\n    if(l[u]!=0)dfs2(l[u],dep+1);\n    if(c[u]<nxt[id[u]]||dup[l[u]])\n    {\n        if(r[u]!=0)dfs2(r[u],dep+1);\n        dup[u]=1;\n        k--;\n    }\n}\nmain()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen("input","r",stdin);\n    long long t=1;\n    while(t--)\n    {\n        cin>>n>>k;\n        for(int i=1;i<=n;i++)cin>>c[i];\n        for(int i=1;i<=n;i++)cin>>l[i]>>r[i];\n        dfs1(1);\n        for(int i=1;i<=n;i++)cout<<str[i];cout<<endl;\n        nxt[n]=-1;\n        for(int i=n-1;i>=1;i--)\n        {\n            if(str[i]==str[i+1])nxt[i]=nxt[i+1];else nxt[i]=str[i+1];\n        }\n        dfs2(1,1);\n        for(int i=1;i<=n;i++)sdup[id[i]]=dup[i];\n        for(int i=1;i<=n;i++)\n        {\n            cout<<str[i];\n            if(sdup[i])cout<<str[i];\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, n, m, t, l[200500], r[200500], siz[200500], tp[200500], it,\n    id[200500], dep[200500], sb[200500], fa[200500];\nchar s[200500];\nint q[200500];\nstring res;\nvoid dfs0(int x, int d) {\n  if (!x) return;\n  dep[x] = d;\n  fa[l[x]] = fa[r[x]] = x;\n  dfs0(l[x], d + 1);\n  q[++it] = x;\n  dfs0(r[x], d + 1);\n  siz[x] = 1 + siz[l[x]] + siz[r[x]];\n}\nvoid dfs01(int x, int to) {\n  if (!x) return;\n  tp[x] = to;\n  id[x] = ++it;\n  if (siz[l[x]] >= siz[r[x]]) {\n    dfs01(l[x], to);\n    dfs01(r[x], r[x]);\n  } else {\n    dfs01(r[x], to);\n    dfs01(l[x], l[x]);\n  }\n}\nstruct SB {\n  int f[800500], t[805000];\n  void push(int id, int l, int r) {\n    t[(id << 1)] = t[(id << 1)] = t[id];\n    f[(id << 1)] = ((t[id] < 1) ? -1000000 : (((l + r) >> 1) - l + 1));\n    f[((id << 1) + 1)] = ((t[id] < 1) ? -1000000 : (r - ((l + r) >> 1)));\n    t[id] = 0;\n  }\n  void ass(int id, int l, int r, int x, int y, int w) {\n    if (x <= l && r <= y) {\n      t[id] = w;\n      f[id] = ((w < 1) ? -1000000 : (r - l + 1));\n      return;\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (x <= ((l + r) >> 1)) ass((id << 1), l, ((l + r) >> 1), x, y, w);\n    if (y > ((l + r) >> 1))\n      ass(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y, w);\n    f[id] = max(-1000000, f[(id << 1)] + f[((id << 1) + 1)]);\n  }\n  int get(int id, int l, int r, int x, int y) {\n    if (x <= l && r <= y) {\n      return f[id];\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (y <= ((l + r) >> 1)) return get((id << 1), l, ((l + r) >> 1), x, y);\n    if (x > ((l + r) >> 1))\n      return get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y);\n    return max(-1000000, get((id << 1), l, ((l + r) >> 1), x, y) +\n                             get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y));\n  }\n} SB;\nvoid hld_ass(int x, int w) {\n  while (x) {\n    SB.ass(1, 1, n, id[tp[x]], id[x], 1);\n    x = fa[tp[x]];\n  }\n}\nint hld_get(int x, int w = 0) {\n  while (x) {\n    w += SB.get(1, 1, n, id[tp[x]], id[x]);\n    w = max(w, -1000000);\n    x = fa[tp[x]];\n  }\n  return w;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> m >> s + 1;\n  for (i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs0(1, 1);\n  it = 0;\n  dfs01(1, 1);\n  for (i = n; i >= 1; i--) {\n    if (s[q[i]] == s[q[i + 1]]) {\n      sb[i] = sb[i + 1];\n    } else {\n      sb[i] = (s[q[i]] < s[q[i + 1]]);\n    }\n  }\n  for (i = 1; i < n; i++) {\n    res += s[q[i]];\n    if (SB.get(1, 1, n, id[q[i]], id[q[i]])) {\n      res += s[q[i]];\n      continue;\n    }\n    if (sb[i]) {\n      k = hld_get(q[i]);\n      if (k + m >= dep[q[i]]) {\n        res += s[q[i]];\n        m -= (dep[q[i]] - k);\n        hld_ass(q[i], 1);\n      }\n    } else {\n      SB.ass(1, 1, n, id[q[i]], id[q[i]], -1000000);\n    }\n  }\n  res += s[q[n]];\n  cout << res;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nusing cd = complex<double>;\nmt19937 rnd(chrono::system_clock::now().time_since_epoch().count());\nconst long long N = 2e5 + 5;\nstring a, s;\nset<long long> g;\nlong long c[N], n, k, num[N], tot, L[N], R[N], ok[N], tin[N], tout[N], tree[N],\n    vis[N], f[N], h[N];\nvoid add(long long x, long long v) {\n  while (x <= n + 1) {\n    tree[x] += v;\n    x += x & (-x);\n  }\n}\nlong long query(long long x) {\n  long long res = 0;\n  while (x) {\n    res += tree[x];\n    x -= x & (-x);\n  }\n  return res;\n}\nvoid work(long long u, long long dp) {\n  tin[u] = ++tot;\n  if (L[u]) work(L[u], dp + 1);\n  if (R[u]) work(R[u], dp + 1);\n  tout[u] = tot;\n  add(tin[u], 1);\n  add(tout[u] + 1, -1);\n}\nvoid dfs(long long u) {\n  if (L[u]) dfs(L[u]);\n  num[++tot] = u;\n  a += s[u];\n  h[u] = tot;\n  if (R[u]) dfs(R[u]);\n}\nvoid get(long long u, long long pre) {\n  g.insert(h[u]);\n  pre += c[h[u]];\n  vector<long long> out;\n  while (g.size()) {\n    long long w = *g.rbegin();\n    if (w > h[u])\n      g.erase(w), pre -= c[w], out.push_back(w);\n    else\n      break;\n  }\n  if (pre == g.size()) ok[u] = 1;\n  if (L[u]) get(L[u], pre);\n  if (R[u]) get(R[u], pre);\n  if (ok[u])\n    g.clear();\n  else {\n    for (auto i : out) g.insert(i), pre += c[i];\n    g.erase(h[u]);\n    pre -= c[h[u]];\n  }\n}\nvoid solve(long long u) {\n  if (L[u]) solve(L[u]);\n  if (ok[u] && !vis[u]) {\n    long long v = query(tin[u]);\n    if (v <= k) {\n      k -= v;\n      long long x = u;\n      while (x > 0 && !vis[x]) {\n        add(tin[x], -1);\n        add(tout[x] + 1, 1);\n        vis[x] = 1;\n        x = f[x];\n      }\n    }\n  }\n  if (R[u]) solve(R[u]);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k >> s;\n  s = " " + s;\n  for (long long i = 1; i <= n; i++) {\n    cin >> L[i] >> R[i];\n    if (L[i]) f[L[i]] = i;\n    if (R[i]) f[R[i]] = i;\n  }\n  dfs(1);\n  a = " " + a;\n  tot = 0;\n  work(1, 0);\n  for (long long i = 1; i <= n; i++) {\n    long long x = i;\n    while (x <= n && a[i] == a[x]) x++;\n    if (x > n) break;\n    if (a[x] > a[i]) {\n      for (long long j = i; j < x; j++) c[j] = 1;\n    }\n    i = x - 1;\n  }\n  get(1, 0);\n  solve(1);\n  for (long long i = 1; i <= n; i++) {\n    if (vis[num[i]]) cout << a[i];\n    cout << a[i];\n  }\n  cout << endl;\n}\n', '#include <bits/stdc++.h>\n\nconst int N = 1e6 + 50;\n\ninline lowbit(int x) {\n\treturn x & -x;\n}\n\nstruct fenwick_t {\n\tint t[N];\n\tfenwick_t() {\n\t\tmemset(t, 0, sizeof t);\n\t}\n\tinline void add(int p, int v) {\n\t\t++p;\n\t\tfor (; p < N; p += lowbit(p))\n\t\t\tt[p] += v;\n\t}\n\tinline void add(int l, int r, int v) {\n\t\tadd(l, v);\n\t\tadd(r + 1, -v);\n\t}\n\tinline int qry(int p) {\n\t\t++p;\n\t\tint r = 0;\n\t\tfor (; p; p -= lowbit(p))\n\t\t\tr += t[p];\n\t\treturn r;\n\t}\n} T1, T2;\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(nullptr);\n\tstd::cout.tie(nullptr);\n\tint n, k, tot = 0;\n\tstd::cin >> n >> k;\n\tstd::vector<int> l(n + 1), r(n + 1), t(n + 1), fa(n + 1), siz(n + 1), dfn(n + 1), dep(n + 1), a, ban(n + 1);\n\tstd::string s;\n\tstd::cin >> s;\n\ts = "#" + s;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::cin >> l[i] >> r[i];\n\t}\n\tstd::function<void(int)> dfs = [&](int x) {\n\t\tsiz[x] = 1;\n\t\tdfn[x] = ++tot;\n\t\tif (l[x]) {\n\t\t\tdep[l[x]] = dep[x] + 1;\n\t\t\tdfs(l[x]);\n\t\t\tfa[l[x]] = x;\n\t\t\tsiz[x] += siz[l[x]];\n\t\t}\n\t\ta.push_back(x);\n\t\tif (r[x]) {\n\t\t\tdep[r[x]] = dep[x] + 1;\n\t\t\tdfs(r[x]);\n\t\t\tfa[r[x]] = x;\n\t\t\tsiz[x] += siz[r[x]];\n\t\t}\n\t};\n\tdep[1] = 1;\n\tdfs(1);\n\tassert(a.size() == n);\n\tstd::vector<int> b(n), lst(n), mp(50, n + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tb[i] = s[a[i]] - \'a\';\n\t}\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tmp[b[i]] = i;\n\t\tint minp = n + 1;\n\t\tfor (int c = 0; c < 26; ++c)\n\t\t\tif (b[i] != c) {\n\t\t\t\tminp = std::min(minp, mp[c]);\n\t\t\t}\n\t\tif (minp == n + 1) {\n\t\t\tlst[i] = -1;\n\t\t}\n\t\telse {\n\t\t\tlst[i] = b[minp];\n\t\t}\n\t}\n\tint rem = k;\n\tfor (int i = 0; i + 1 < n; ++i) {\n\t\tint x = i;\n\t\tif (b[x] < lst[x]) {\n\t\t\t// try to select!\n\t\t\tif (T2.qry(a[i]) == 0) {\n\t\t\t\tint xx = a[i];\n\t\t\t\tint cost = dep[xx] - T1.qry(xx);\n\t\t\t\tif (rem >= cost) {\n\t\t\t\t\trem -= cost;\n\t\t\t\t\tint y = xx, total = 0;\n\t\t\t\t\twhile (y && !ban[y]) {\n\t\t\t\t\t\tban[y] = true;\n\t\t\t\t\t\tT1.add(dfn[y], dfn[y] + siz[y] - 1, 1);\n\t\t\t\t\t\t++total;\n\t\t\t\t\t\ty = fa[y];\n\t\t\t\t\t}\n\t\t\t\t\tassert(total == cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tT2.add(dfn[a[i]], dfn[a[i]] + siz[a[i]] - 1, 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tputchar(\'a\' + b[i]);\n\t\tif (ban[a[i]]) {\n\t\t\tputchar(\'a\' + b[i]);\n\t\t}\n\t}\n}\n', 'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class e {\n\tstatic final int LOG=30;\n\tstatic final int INF=Integer.MAX_VALUE/2-5;\n\tpublic static void main(String[] args) {\n\t\tFastScanner scan=new FastScanner();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\n\t\tint n=scan.nextInt();\n\t\tk=scan.nextInt();\n\t\tc=scan.next().toCharArray();\n\n\t\ta=new int[n][2];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i][0]=scan.nextInt()-1;\n\t\t\ta[i][1]=scan.nextInt()-1;\n\t\t}\n\t\tinorder=new ArrayList<>();\n\t\tdepth=new int[n];\n\t\tparent=new int[n];\n\t\tid=new int[n];\n\t\tinit(0,1,-1);\n\n\t\tint[] last=new int[26];\n\t\tArrays.fill(last,-1);\n\t\tlast[(int)(c[inorder.get(n-1)]-\'a\')]=n-1;\n\t\tgood=new boolean[n];\n\n\t\tfor(int i=n-2;i>=0;i--) {\n\t\t\tint p=inorder.get(i), q=inorder.get(i+1);\n\t\t\tint nxtdif=Integer.MAX_VALUE;\n\t\t\tchar nxtchar=\' \';\n\t\t\tfor(int j=0;j<26;j++) {\n\t\t\t\tif(j!=(int)(c[q]-\'a\')&&last[j]!=-1) {\n\t\t\t\t\tif(nxtdif>last[j]) {\n\t\t\t\t\t\tnxtdif=last[j];\n\t\t\t\t\t\tnxtchar=(char)(j+\'a\');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c[p]<c[q]) {\n\t\t\t\t//expanding here\n\t\t\t\tgood[p]=true;\n\t\t\t}\n\t\t\telse if(c[p]==c[q]&&nxtdif!=Integer.MAX_VALUE&&nxtchar>c[p]) {\n\t\t\t\t//expanding here\n\t\t\t\tgood[p]=true;\n\t\t\t}\n\t\t\tlast[(int)(c[inorder.get(i)]-\'a\')]=i;\n\t\t}\n\t\texpand=new boolean[n];\n\t\tdfs(0,depth);\n\t\t\n\t\tStringBuilder res=new StringBuilder();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint cur=inorder.get(i);\n\t\t\tres.append(c[cur]);\n\t\t\tif(expand[cur]) {\n\t\t\t\tres.append(c[cur]);\n\t\t\t}\n\t\t}\n\t\tout.println(res);\n\t\tout.close();\n\t}\n\tpublic static boolean dfs(int at, int[] cost) {\n\t\tboolean exploreRight=false;\n\t\tint l=a[at][0], r=a[at][1];\n\t\t\n\t\tif(good[at]&&cost[at]<=k) {\n\t\t\texpand[at]=true;\n\t\t\tk-=cost[at];\n\t\t\texploreRight=true;\n\t\t\tif(l!=-1) cost[l]=1;\n\t\t\tif(r!=-1) cost[r]=1;\n\t\t}\n\t\t\n\t\tif(l!=-1) {\n\t\t\tif(dfs(l,cost)) {\n\t\t\t\tk-=cost[l];\n\t\t\t\texploreRight=true;\n\t\t\t\texpand[at]=true;\n\t\t\t}\n\t\t}\n\t\tif(exploreRight&&r!=-1) {\n\t\t\tdfs(r,cost);\n\t\t}\n\t\treturn expand[at];\n\t}\n\tpublic static void init(int at, int d, int p) {\n\t\tdepth[at]=d;\n\t\tparent[at]=p;\n\t\tif(a[at][0]!=-1) init(a[at][0],d+1,at);\n\t\tinorder.add(at);\n\t\tid[at]=inorder.size()-1;\n\t\tif(a[at][1]!=-1) init(a[at][1],d+1,at);\n\t}\n\tstatic int k;\n\tstatic boolean[] expand,good;\n\tstatic ArrayList<Integer> inorder;\n\tstatic int[][] a;\n\tstatic int[] id;\n\tstatic int[] depth,parent;\n\tstatic char[] c;\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\ttry\t{\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e){e.printStackTrace();}\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (st.hasMoreTokens())\treturn st.nextToken();\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() {return Long.parseLong(next());}\n\n\t\tpublic double nextDouble() {return Double.parseDouble(next());}\n\n\t\tpublic String nextLine() {\n\t\t\tString line = "";\n\t\t\tif(st.hasMoreTokens()) line = st.nextToken();\n\t\t\telse try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n\t\t\twhile(st.hasMoreTokens()) line += " "+st.nextToken();\n\t\t\treturn line;\n\t\t}\n\t}\n}', "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 2e5 + 10;\nint n, k;\nchar arr[MAX];\nint L[MAX], R[MAX];\nvector<int> order;\nchar nxt[MAX];\nint mark[MAX], dep[MAX];\nvoid dfs(int node) {\n  if (L[node]) {\n    dep[L[node]] = dep[node] + 1;\n    dfs(L[node]);\n  }\n  order.push_back(node);\n  if (R[node]) {\n    dep[R[node]] = dep[node] + 1;\n    dfs(R[node]);\n  }\n}\nvoid dfs2(int node, int last) {\n  if (L[node]) {\n    dfs2(L[node], last);\n    if (mark[L[node]]) mark[node] = 1;\n  }\n  cout << arr[node];\n  if (mark[node] || (k >= dep[node] - last && arr[node] < nxt[node])) {\n    mark[node] = 1;\n    cout << arr[node];\n    k -= (dep[node] - last);\n    last = dep[node];\n  } else\n    last = -1e9;\n  if (R[node]) {\n    dfs2(R[node], last);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) cin >> arr[i];\n  for (int i = 1; i <= n; ++i) cin >> L[i] >> R[i];\n  dep[1] = 1;\n  dfs(1);\n  nxt[order[n - 1]] = 'a';\n  for (int i = n - 2; i >= 0; --i) {\n    if (arr[order[i]] == arr[order[i + 1]])\n      nxt[order[i]] = nxt[order[i + 1]];\n    else\n      nxt[order[i]] = arr[order[i + 1]];\n  }\n  dfs2(1, 0);\n  return 0;\n}\n", '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(1e6));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 0; i < int(30); ++i) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(1e6);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      long long operations = 0;\n      while (cur) {\n        if (n == 200000 and initial[i] == \'m\') cout << dist(taken, cur) << \'.\';\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '// Problem: E. Middle Duplication\n// Contest: Codeforces - Codeforces Round #763 (Div. 2)\n// URL: https://codeforces.com/contest/1623/problem/E\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// Author: abhidot\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n#define ll long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);\n#define pb push_back\n#define mod 1000000007\n#define mod2 998244353\n#define lld long double\n#define pii pair<int, int>\n#define ff first\n#define ss second\n#define all(x) (x).begin(), (x).end()\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define rep(i,x,y) for(int i=x; i<y; i++)\n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define V vector\n#define setbits(x) __builtin_popcountll(x)\n#define w(x)  int x; cin>>x; while(x--)\nusing namespace std;\nusing namespace __gnu_pbds; \ntemplate <typename num_t> using ordered_set = tree<num_t, null_type, less<num_t>, rb_tree_tag, tree_order_statistics_node_update>;\nconst long long N=200005, INF=2000000000000000000, inf = 2e9+5;\n\nint power(int a, int b, int p){\n\tif(a==0)\n\treturn 0;\n\tint res=1;\n\ta%=p;\n\twhile(b>0)\n\t{\n\t\tif(b&1)\n\t\tres=(res*a)%p;\n\t\tb>>=1;\n\t\ta=(a*a)%p;\n\t}\n\treturn res;\n}\n\n\nvoid print(bool n){\n    if(n){\n        cout<<"YES\\n";\n    }else{\n        cout<<"NO\\n";\n    }\n}\n\nint n, k;\nstring s;\n\nint btree[N][2];\nint p[N][20];\nvector<vector<int>> g;\nint tin[N], tout[N], lim[N];\n\nvector<int> inorder;\nint tim=0;\n\n\nvoid traversal(int u, int cnt=1){\n\tif(u==0) return;\n\ttin[u] = ++tim;\n\tlim[u]=cnt;\n\ttraversal(btree[u][0], cnt+1);\n\tinorder.push_back(u);\n\ttraversal(btree[u][1], 1);\n\ttout[u] = ++tim;\n}\n\nint32_t main()\n{\n    IOS;\n    cin>>n>>k>>s;\n    s = "$"+s;\n    vector<int> col(n+1, 0);\n    col[0]=1;\n    for(int i=1;i<=n;i++){\n    \tcin>>btree[i][0]>>btree[i][1];\n    \tif(btree[i][0]) p[btree[i][0]][0]=i;\n    \tif(btree[i][1]) p[btree[i][1]][0]=i;\n    }\n    \n    traversal(1);\n    \n    // Binary Lifting\n    for(int j=1;j<20;j++){\n    \tfor(int i=1;i<=n;i++){\n    \t\tp[i][j] = p[p[i][j-1]][j-1];\n    \t}\n    }\n    \n    int left=k;\n    int i;\n    \n    auto calc = [&](int on){\n    \tif(col[on]) return 0LL;\n    \tint ans=1;\n    \t// cout<<on<<": ";\n    \tfor(int j=19;j>=0;j--){\n    \t\tif(col[p[on][j]]==0){\n    \t\t\ton = p[on][j];\n    \t\t\t// cout<<on<<" ";\n    \t\t\tans+=(1<<j);\n    \t\t}\n    \t}\n    \t// cout<<": "<<ans<<"\\n";\n    \t// cout<<"\\n";\n    \t\n    \treturn ans;\n    };\n    \n    string d;\n    d+=s[inorder[0]];\n    int val[n+1]={0};\n    val[inorder[0]]=0;\n    for(int i=1;i<n;i++){\n    \tif(s[inorder[i]]!=d.back()){\n    \t\td+=s[inorder[i]];\n    \t}\n    \tval[inorder[i]] = d.size()-1;\n    }\n    \n    \n    int upto=0;\n    for(i=0;inorder[i]!=1;i++){\n    \tif(val[inorder[i]]==d.size()-1||d[val[inorder[i]]]>d[val[inorder[i]]+1]||tin[inorder[i+1]]<upto){\n    \t\t// upto = max(upto, tout[inorder[i]]);\n    \t\tcontinue;\n    \t}\n    \tint req = calc(inorder[i]);\n    \tif(req>left||req>lim[inorder[i]]) continue;\n    \tleft-=req;\n    \tint on=inorder[i];\n    \twhile(on&&col[on]==0){\n    \t\tcol[on]=1;\n    \t\ton = p[on][0];\n    \t}\n    }\n    \n    // cout<<inorder[i]<<" "<<inorder[i+1]<<" "<<val[inorder[i]]<<" "<<val[inorder[i]+1]<<"\\n";\n\tif(i<n-1&&val[inorder[i]]<d.size()-1&&d[val[inorder[i]]]<d[val[inorder[i]]+1]){\n\t\tint req = calc(inorder[i]);\n    \tif(req<=left){\n\t    \tleft-=req;\n\t    \tint on=inorder[i];\n\t    \twhile(col[on]==0){\n\t    \t\tcol[on]=1;\n\t    \t\ton = p[on][0];\n\t    \t}\n    \t}\t\n\t}\n    \n    if(col[1]==1){\n    \ti++;\n    \tfor(;i<n-1;i++){\n    \t\tif(left==0) continue;\n    \t\tif(val[inorder[i]]==d.size()-1||d[val[inorder[i]]]>d[val[inorder[i]]+1]){\n    \t\t\tupto = max(upto, tout[inorder[i]]);\n    \t\t}\n\t    \tint req = calc(inorder[i]);\n\t    \tif(req>left||req>lim[inorder[i]]) continue;\n\t    \tleft-=req;\n\t    \tint on=inorder[i];\n\t    \twhile(col[on]==0){\n\t    \t\tcol[on]=1;\n\t    \t\ton = p[on][0];\n\t    \t}\n    \t}\n    }\n    \n    for(int i=0;i<n;i++){\n    \tcout<<s[inorder[i]];\n    \tif(col[inorder[i]]) cout<<s[inorder[i]];\n    }\n}', '//Common Header Simple over C++11\n#pragma GCC optimize("Ofast","-funroll-loops")\n#pragma GCC target("sse4.1","sse4.2","ssse3","sse3","sse2","sse","avx2","avx","popcnt")\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef tree<pair<ll,int>,null_type,less<pair<ll,int>>,rb_tree_tag,tree_order_statistics_node_update> pset;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define make_unique(a) {sort(all(a));a.resize(unique(all(a))-a.begin());}\n#define sz(x) ((int)(x).size())\n#define count2(x) __builtin_popcount(x)\n#define count2l(x) __builtin_popcountll(x)\n#define countlz(x) __builtin_clz(x)\n#define rint(x) int x;cin>>x;\n#define rll(x) ll x;cin>>x;\n#define rs(x) string x;cin>>x;\n#define rvi(v,n) vector<int>v(n);for(auto &i:v)cin>>i;\n#define rvl(v,n) vector<ll>v(n);for(auto &i:v)cin>>i;\n#define dd(x) cerr << #x << " = " << x << \' \';\n#define de(x) cerr << #x << " = " << x << endl;\n#define df cerr << "Passing ["<<__FUNCTION__<<"] in LINE "<<__LINE__<< endl;\n#define rep(i, a, b) for(int i=(a); i<(b); i++)\n#define per(i, a, b) for(int i=int(b)-1; i>=(a); i--)\n#define pw(x) (1ll<<(x))\n//#define endl \'\\n\'\n//#define getchar getchar_unlocked\n//inline char nc() {\n//  static char buf[1000000], *p = buf, *q = buf;\n//  return p == q && (q = (p = buf) + fread(buf, 1, 1000000, stdin), p == q)\n//             ? EOF\n//             : *p++;\n//}\nconst double PI=acos(-1.0);\ninline double calcs(int start){return (1.0*clock()-start)/CLOCKS_PER_SEC;}\ninline ll rd(){//LLONG_MIN LMAX=9,223,372,036,854,775,807\n\tll s=0,w=1;char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\')s=s*10+(ch&15),ch=getchar();\n\treturn s*w;\n}\ninline int fpow(int a,int b,int p){//a^b mod p; assert(p!=0);\n\tint ans=1%p,base=a%p;\n\tfor(;b;b/=2){\n\t\tif(b&1)ans=(ll)ans*base%p;\n\t\tbase=(ll)base*base%p;\n\t}\n\treturn ans;\n}\n constexpr int mod = 1e9 + 7; // 1000000007\n// constexpr int mod = 1e9 + 9; // 1000000009\nconst int N=200001;\nchar p[N];\nstruct node{\n\tint lson,rson;\n}E[N];\nstring a;\nint id[N];// 中序遍历序转节点id \nvoid dfs(int pos){\n\tif(pos==0) return ;\n\tdfs(E[pos].lson);\n\tid[a.size()]=pos;\n\ta+=p[pos];\n\tdfs(E[pos].rson);\n}\nbool tag[N],dup[N];\n// gao(x, r) -> int 表示，\n// 这颗子树还剩余 r 个可用结点，然后返回的是这颗子树最后用了多少结点\nint gao(int pos,int r){\n\tif(pos==0) return 0;\n\tif(r<=0) return 0;\n\t// 留一个给根节点用 \n\tbool use=gao(E[pos].lson,r-1);\n\tif(use){\n\t\tdup[pos]=1;\n\t\tr-=use+1;\n\t\treturn gao(E[pos].rson,r)+use+1;\n\t}\n\telse{\n\t\tif(tag[pos]){// 如果当前节点扩展能使字典序变小 \n\t\t\tdup[pos]=1;\n\t\t\treturn gao(E[pos].rson,r-1)+1;\n\t\t}\n\t\telse{\n\t\t\tdup[pos]=0;\n\t\t\treturn 0;\n\t\t}\n\t} \n} \nvoid dfs2(int pos){\n\tif(pos==0) return ;\n\tdfs2(E[pos].lson);\n\tcout<<p[pos];\n\tif(dup[pos])cout<<p[pos];\n\tdfs2(E[pos].rson);\n}\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0);cin.exceptions(ios::badbit | ios::failbit);\n\trint(n)rint(k)// 最多加倍k次后字典序最短 \n\trs(s)\n\tfor(int i=1;i<=n;++i)\tp[i]=s[i-1];\n\tfor(int i=1;i<=n;++i)\tcin>>E[i].lson>>E[i].rson;\n\tdfs(1);\n\ta.push_back(0);\n\tvector<int>nxt(a.size());\n\tfor(int i=a.size()-1-1;i>=0;i--){\n    \t// nxt[i] 中序遍历出来的字符串下一个和它不一样的点的值 \n\t\tif(a[i]!=a[i+1]){\n\t\t\tnxt[i]=a[i+1];\n\t\t}else{\n\t\t\tnxt[i]=nxt[i+1];\n\t\t}\n\t\tassert(nxt[i]!=a[i]);\n\t\tif(nxt[i]>a[i]){\n\t\t\ttag[id[i]]=1;\n\t\t}\n\t\telse{\n\t\t\ttag[id[i]]=0;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) dup[i]=0;\n\tgao(1,k);\n\tdfs2(1);\n\treturn 0;\n}\n\n', '#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize("O3,unroll-loops")\n#pragma target optimize("avx2,bmi,bmi2,lzcnt,popcnt")\nvoid _col(int i) {\n  static string _[3] = {"\\e[0m", "\\e[1;33m", "\\e[1;32m"};\n  cerr << _[i];\n}\nvoid dbg() { cerr << \'\\n\'; }\ntemplate <class T, class... U>\nvoid dbg(T a, U... b) {\n  cerr << a << \' \', dbg(b...);\n}\ntemplate <class T>\nvoid org(T l, T r) {\n  while (l != r) cerr << *l << " \\n"[++l == r];\n}\ntemplate <class T>\nbool chmin(T &a, T b) {\n  return b < a and (a = b, true);\n}\ntemplate <class T>\nbool chmax(T &a, T b) {\n  return b > a and (a = b, true);\n}\nconst int maxn = 2e5 + 5;\nint ch[maxn][2];\nint tag[maxn];\nchar bb[maxn][2];\nstring str;\nvoid dfs(int u) {\n  bb[u][0] = bb[u][1] = str[u];\n  if (int c = ch[u][0]; c) {\n    dfs(c);\n    bb[u][0] = bb[c][0];\n    if (tag[c])\n      tag[u] = tag[c];\n    else if (bb[c][1] < str[u])\n      tag[u] = 1;\n    else if (bb[c][1] > str[u])\n      tag[u] = -1;\n  }\n  if (int c = ch[u][1]; c) {\n    dfs(c);\n    bb[u][1] = bb[c][1];\n    if (!tag[u]) {\n      if (str[u] < bb[c][0])\n        tag[u] = 1;\n      else if (str[u] > bb[c][0])\n        tag[u] = -1;\n      else if (tag[c])\n        tag[u] = tag[c];\n    }\n  }\n}\nstring ans;\nint n, m;\nvoid dfs2(int u) {\n  if (!u) return;\n  bool add = false;\n  if (m) {\n    if (int rs = ch[u][1]; !rs or str[u] < bb[rs][0])\n      add = true;\n    else if (str[u] == bb[rs][0] and tag[rs] == 1)\n      add = true;\n    if (add) m--;\n  }\n  dfs2(ch[u][0]);\n  ans.push_back(str[u]);\n  if (add) ans.push_back(str[u]);\n  dfs2(ch[u][1]);\n}\nvoid solve() {\n  cin >> n >> m;\n  cin >> str;\n  for (int i = 1; i <= n; i++) cin >> ch[i][0] >> ch[i][1];\n  dfs(1);\n  dfs2(1);\n  cout << ans << \'\\n\';\n}\nsigned main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  int T = 1;\n  cin >> T;\n  while (T--) solve();\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)2e5 + 50, LOGN = 17;\nconst int INF = (int)1e9;\nint n, k;\nint ord[N], in[N], tim = 0;\nchar las[N];\nint lc[N], rc[N];\nint res[N];\nstring str;\nvoid dfs(int v) {\n  if (lc[v] != -1) dfs(lc[v]);\n  ord[tim] = v;\n  in[v] = tim++;\n  if (rc[v] != -1) dfs(rc[v]);\n}\nvoid solve(int v, int& rem) {\n  int la = -1;\n  int cur = v;\n  for (int i = 0; i < (rem); ++i) {\n    if (cur == -1) break;\n    if (las[cur] != \' \' && las[cur] > str[cur]) {\n      la = i;\n    }\n    cur = lc[v];\n  }\n  cur = v;\n  vector<int> vs;\n  for (int i = 0; i < (la + 1); ++i) {\n    res[cur] = 1;\n    rem--;\n    vs.push_back(cur);\n    cur = lc[cur];\n  }\n  cout << v + 1 << " " << (int)(vs).size() << endl;\n  while (!vs.empty()) {\n    if (rc[vs.back()] != -1) solve(rc[vs.back()], rem);\n    vs.pop_back();\n  }\n}\nvoid print_ans(int v) {\n  if (lc[v] != -1) print_ans(lc[v]);\n  cout << str[v];\n  if (res[v]) cout << str[v];\n  if (rc[v] != -1) print_ans(rc[v]);\n}\nint pos[256];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  cin >> str;\n  for (int i = 0; i < (n); ++i) {\n    cin >> lc[i] >> rc[i];\n    lc[i]--, rc[i]--;\n  }\n  dfs(0);\n  fill(pos, pos + 256, INF);\n  for (int i = n - 1; i >= 0; i--) {\n    pos[str[ord[i]]] = i;\n    char f = \' \';\n    for (char c = \'a\'; c <= \'z\'; c++) {\n      if (c != str[ord[i]] && pos[f] > pos[c]) f = c;\n    }\n    las[ord[i]] = f;\n    cout << ord[i] + 1 << " " << f << endl;\n  }\n  solve(0, k);\n  assert(k >= 0);\n  print_ans(0);\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint l[200100], r[200100];\nint p[200100];\nbool db[200100];\nbool du[200100];\nstring x;\nstring f = "";\nvector<int> v;\nvoid go(int cr) {\n  if (l[cr] != 0) go(l[cr]);\n  f += x[cr];\n  v.push_back(cr);\n  if (r[cr] != 0) go(r[cr]);\n}\nint ch(int cr, int first) {\n  if (first > k) return k + 10;\n  if (cr == 0 || db[cr] == 1) return 0;\n  if (du[cr])\n    return k + 1;\n  else\n    return ch(p[cr], first + 1) + 1;\n}\nvoid go2(int cr) {\n  if (cr == 0 || db[cr] == 1) return;\n  db[cr] = 1;\n  k--;\n  go2(p[cr]);\n}\nint main() {\n  cin >> n >> k >> x;\n  x = \'0\' + x;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n    p[l[i]] = i;\n    p[r[i]] = i;\n  }\n  go(1);\n  int s[200100];\n  int nxt = 0;\n  for (int i = f.size() - 1; i >= 0; i--) {\n    s[i] = nxt;\n    if (i > 0) {\n      if (f[i] == f[i - 1]) continue;\n      nxt = f[i] - \'a\';\n    }\n  }\n  for (int i = 0; i < f.size(); i++) {\n    if (s[i] > f[i] - \'a\') {\n      int gg = ch(v[i], 1);\n      if (gg <= k) {\n        go2(v[i]);\n      }\n    }\n    du[v[i]] = 1;\n  }\n  for (int i = 0; i < f.size(); i++) {\n    cout << f[i];\n    if (db[v[i]] == 1) cout << f[i];\n  }\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint lc[200005], rc[200005];\nchar c[200005];\nbool use[200005];\nint dfn[200005], dfr[200005];\nint cnt, len, fa[200005];\nint node[200005];\nint dep[200005];\nvoid dfs(int x) {\n  dfn[x] = ++cnt;\n  if (lc[x]) dep[lc[x]] = dep[x] + 1, fa[lc[x]] = x, dfs(lc[x]);\n  node[++len] = x;\n  if (rc[x]) dep[rc[x]] = dep[x] + 1, fa[rc[x]] = x, dfs(rc[x]);\n  dfr[x] = cnt;\n}\nbool f[200005];\nstruct bit {\n  int sum[200005];\n  void update(int x, int y) {\n    while (x <= n) {\n      sum[x] += y;\n      x += x & -x;\n    }\n  }\n  int get(int x) {\n    int re = 0;\n    while (x) {\n      re += sum[x];\n      x -= x & -x;\n    }\n    return re;\n  }\n} T1, T2;\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) cin >> c[i];\n  for (int i = 1; i <= n; i++) {\n    cin >> lc[i] >> rc[i];\n  }\n  dep[1] = 1;\n  dfs(1);\n  for (int i = n - 1; i >= 1; i--) {\n    if (c[node[i + 1]] > c[node[i]])\n      f[node[i]] = 1;\n    else if (c[node[i + 1]] == c[node[i]])\n      f[node[i]] = f[node[i + 1]];\n  }\n  for (int i = 1; i <= n; i++) {\n    int x = node[i];\n    bool ff = 0;\n    if (f[x]) {\n      if (T1.get(dfn[x]) == 0 && dep[x] - T2.get(dfn[x]) <= k) {\n        ff = 1;\n      }\n    }\n    if (ff) {\n      while (x && !use[x]) {\n        T2.update(dfn[x], 1);\n        T2.update(dfr[x] + 1, -1);\n        use[x] = 1;\n        x = fa[x];\n        k--;\n      }\n    } else {\n      T1.update(dfn[x], 1);\n      T1.update(dfr[x] + 1, -1);\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (use[node[i]]) {\n      cout << c[node[i]] << c[node[i]];\n    } else\n      cout << c[node[i]];\n  return 0;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint l[200005], r[200005];\nchar m[200005], nxt[200005];\nstring s, t;\nstring res;\nvector<int> v;\nvoid dfs1(int u) {\n  if (!u) return;\n  dfs1(l[u]);\n  t += s[u];\n  v.push_back(u);\n  dfs1(r[u]);\n}\nvoid dfs(int u, int h) {\n  int k0 = k;\n  if (l[u]) {\n    dfs(l[u], h - 1);\n  }\n  bool smaller = false;\n  if (nxt[u] && (s[u] < nxt[u] || (s[u] == nxt[u] && s[u] < m[u]))) {\n    smaller = true;\n  }\n  if (h > 0 && (k != k0 || smaller)) {\n    k--;\n    res += s[u];\n    res += s[u];\n  } else {\n    res += s[u];\n  }\n  if (r[u]) {\n    if (smaller)\n      dfs(r[u], k);\n    else\n      dfs(r[u], 0);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> n >> k;\n  cin >> s;\n  s = '#' + s;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs1(1);\n  char cur = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    m[v[i]] = cur;\n    cur = max(cur, t[i]);\n    if (i != n - 1) nxt[v[i]] = t[i + 1];\n  }\n  dfs(1, k);\n  cout << res << endl;\n  return 0;\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nint SIZE(T(&t)) {\n  return t.size();\n}\ntemplate <typename T, size_t N>\nint SIZE(T (&t)[N]) {\n  return N;\n}\nstring to_string(char t) { return "\'" + string({t}) + "\'"; }\nstring to_string(bool t) { return t ? "true" : "false"; }\nstring to_string(const string& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)), _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += t[i];\n  }\n  return \'"\' + ret + \'"\';\n}\nstring to_string(const char* t) {\n  string ret(t);\n  return to_string(ret);\n}\ntemplate <size_t N>\nstring to_string(const bitset<N>& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)); i <= min(x2, SIZE(t) - 1); ++i) {\n    ret += t[i] + \'0\';\n  }\n  return to_string(ret);\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1 = 0, int x2 = 1e9, Coords... C);\ntemplate <typename T, typename S>\nstring to_string(const pair<T, S>& t) {\n  return "(" + to_string(t.first) + ", " + to_string(t.second) + ")";\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1, int x2, Coords... C) {\n  string ret = "[";\n  x1 = min(x1, SIZE(t));\n  auto e = begin(t);\n  advance(e, x1);\n  for (int i = x1, _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += to_string(*e, C...) + (i != _i ? ", " : "");\n    e = next(e);\n  }\n  return ret + "]";\n}\ntemplate <int Index, typename... Ts>\nstruct print_tuple {\n  string operator()(const tuple<Ts...>& t) {\n    string ret = print_tuple<Index - 1, Ts...>{}(t);\n    ret += (Index ? ", " : "");\n    return ret + to_string(get<Index>(t));\n  }\n};\ntemplate <typename... Ts>\nstruct print_tuple<0, Ts...> {\n  string operator()(const tuple<Ts...>& t) { return to_string(get<0>(t)); }\n};\ntemplate <typename... Ts>\nstring to_string(const tuple<Ts...>& t) {\n  const auto Size = tuple_size<tuple<Ts...>>::value;\n  return print_tuple<Size - 1, Ts...>{}(t);\n}\nvoid dbgr() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgr(Heads H, Tails... T) {\n  cout << to_string(H) << " | ";\n  dbgr(T...);\n}\nvoid dbgs() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgs(Heads H, Tails... T) {\n  cout << H << " ";\n  dbgs(T...);\n}\nconst int N = 1e5 + 5;\nconst long long INF = 1e18 + 7;\nconst int MAXA = 1e9;\nconst int B = sqrt(N) + 5;\nint l[N], r[N], pv[N];\nbool dou[N], ok[N];\nstring s;\ndeque<char> ans[N];\ndeque<int> pos[N];\nint n, k;\nvoid dfs(int u) {\n  if (u == 0) return;\n  dfs(l[u]);\n  dfs(r[u]);\n  if (ans[l[u]].size() > ans[r[u]].size()) {\n    swap(ans[u], ans[l[u]]);\n    swap(pos[u], pos[l[u]]);\n    ans[u].push_back(s[u]);\n    pos[u].push_back(u);\n    for (char i : ans[r[u]]) {\n      ans[u].push_back(i);\n    }\n    for (int i : pos[r[u]]) {\n      pos[u].push_back(i);\n    }\n  } else {\n    swap(ans[u], ans[r[u]]);\n    swap(pos[u], pos[r[u]]);\n    ans[u].push_front(s[u]);\n    pos[u].push_front(u);\n    reverse(ans[l[u]].begin(), ans[l[u]].end());\n    reverse(pos[l[u]].begin(), pos[l[u]].end());\n    for (char i : ans[l[u]]) {\n      ans[u].push_front(i);\n    }\n    for (int i : pos[l[u]]) {\n      pos[u].push_front(i);\n    }\n  }\n}\nbool dfs_opt(int u, int h) {\n  bool f = false;\n  if (ok[pv[u]] && k >= h) {\n    k -= h;\n    dou[u] = true;\n    if (l[u]) dfs_opt(l[u], 1);\n    if (r[u]) dfs_opt(r[u], 1);\n    return true;\n  } else {\n    if (l[u]) f |= dfs_opt(l[u], h + 1);\n    if (f) dou[u] = true;\n    if (dou[u]) dfs_opt(r[u], h + 1);\n    return dou[u];\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  cin >> s;\n  s = " " + s;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  dfs(1);\n  s = " ";\n  for (char i : ans[1]) s += i;\n  for (int i = 0; i < n; ++i) pv[pos[1][i]] = i + 1;\n  int l = 1;\n  for (int i = 1; i < n; ++i) {\n    if (s[i] != s[i + 1]) {\n      if (s[i] < s[i + 1]) {\n        for (int j = l; j <= i; ++j) ok[j] = true;\n      }\n      l = i + 1;\n    }\n  }\n  dfs_opt(1, 1);\n  for (int i = 1; i <= n; ++i) {\n    cout << s[i];\n    if (dou[pos[1][i - 1]]) cout << s[i];\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n', '// package c1623;\n\nimport java.io.File;\nimport java.lang.invoke.MethodHandles;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n//\n// Codeforces Round #763 (Div. 2) 2021-12-28 05:35\n// E. Middle Duplication\n// https://codeforces.com/contest/1623/problem/E\n// time limit per test 1 second; memory limit per test 256 megabytes\n// public class Pseudo for \'Source should satisfy regex [^{}]*public\\s+(final)?\\s*class\\s+(\\w+).*\'\n//\n// A binary tree of n nodes is given. Nodes of the tree are numbered from 1 to n and the root is the\n// node 1. Each node can have no child, only one left child, only one right child, or both children.\n// For convenience, let\'s denote l_u and r_u as the left and the right child of the node u\n// respectively, l_u = 0 if u does not have the left child, and r_u = 0 if the node u does not have\n// the right child.\n//\n// Each node has a string label, initially is a single character c_u. Let\'s define the string\n// representation of the binary tree as the concatenation of the labels of the nodes in the .\n// Formally, let f(u) be the string representation of the tree rooted at the node u. f(u) is defined\n// as follows: <div class="MathJax_Display" style="text-align: center;"></div> f(u) = \\begin{cases}\n// \\texttt{<empty string>}, & \\text{if }u = 0; \\\\ f(l_u) + c_u + f(r_u) & \\text{otherwise},\n// \\end{cases} where + denotes the string concatenation operation.\n//\n// This way, the string representation of the tree is f(1).\n//\n// For each node, we can its label , that is, assign c_u with c_u + c_u, but only if u is the root\n// of the tree, or if its parent also has its label duplicated.\n//\n// You are given the tree and an integer k. What is the lexicographically smallest string\n// representation of the tree, if we can duplicate labels of at most k nodes?\n//\n// A string a is lexicographically smaller than a string b if and only if one of the following\n// holds:\n//  * a is a prefix of b, but a \\ne b;\n//  * in the first position where a and b differ, the string a has a letter that appears earlier in\n//    the alphabet than the corresponding letter in b. </div><div class="input-specification"><div\n// class="section-title">Input</div>\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Input\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Output\n//\n// Print a single line, containing the lexicographically smallest string representation of the tree\n// if at most k nodes have their labels duplicated.\n//\n// Example\n/*\ninput:\n4 3\nabab\n2 3\n0 0\n0 4\n0 0\n\noutput:\nbaaaab\n\ninput:\n8 2\nkadracyn\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndaarkkcyan\n\ninput:\n8 3\nkdaracyn\n2 5\n0 3\n0 4\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndarkcyan\n*/\n// Note\n//\n// The images below present the tree for the examples. The number in each node is the node number,\n// while the subscripted letter is its label. To the right is the string representation of the tree,\n// with each letter having the same color as the corresponding node.\n//\n// Here is the tree for the first example. Here we duplicated the labels of nodes 1 and 3. We should\n// not duplicate the label of node 2 because it would give us the string "", which is\n// lexicographically greater than "".\n// https://espresso.codeforces.com/30116fa124ec3edbd4c16ac29fa8eb45c19cc171.png\n//\n// In the second example, we can duplicate the labels of nodes 1 and 2. Note that only duplicating\n// the label of the root will produce a worse result than the initial string.\n// https://espresso.codeforces.com/e66a56b1c8dee019f4f4c138ee0333caf44b312c.png\n//\n// In the third example, we should not duplicate any character at all. Even though we would want to\n// duplicate the label of the node 3, by duplicating it we must also duplicate the label of the node\n// 2, which produces a worse result.\n// https://espresso.codeforces.com/19b0d4c5514801c166e9b3f0ef4c110939711a20.png\n//\n// There is no way to produce string "" from a tree with the initial string representation "" :(.\n//\npublic class C1623E {\n  static final int MOD = (int)1e9+7;\n  static final Random RAND = new Random();\n\n  static String solve(String s, int k, int[][] lr) {\n    // Note that both s and lr have length n + 1\n    int n = s.length() - 1;\n\n    // [parent, depth, subtree size, dfs-done, duplicate, in-order index]\n    //  0       1      2             3         4          5\n    int[][] nodes = dfsNodes(lr);\n\n    // ids in in-order\n    int[] ids = new int[n];\n\n    // id, offset\n    Queue<int[]> q = new LinkedList<>();\n    q.add(new int[] {1, 0});\n    while (!q.isEmpty()) {\n      int[] e = q.poll();\n      int v = e[0];\n      int offset = e[1];\n      int l = lr[v][0];\n      int r = lr[v][1];\n      int idx = offset;\n      if (l > 0) {\n        q.add(new int[] {l, idx});\n        idx += nodes[l][2];\n      }\n      nodes[v][5] = idx;\n      ids[idx++] = v;\n      if (r > 0) {\n        q.add(new int[] {r, idx});\n      }\n    }\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    // System.out.format("%s\\n", Utils.trace(ids));\n\n    // fill arr[i][1] which indicate whether to duplicate arr[i][0]\n    int b = 1;\n    int avail = k;\n    while (b < n) {\n      int v = ids[b];\n      // System.out.format("  b:%d v:%d depth:%d k:%d\\n", b, v, nodes[v][1], k);\n      if (nodes[v][1] > k) {\n        // don\'t bother if v is too deep\n        b++;\n        continue;\n      }\n      char c = s.charAt(v);\n      int e = b + 1;\n      while (e < n && s.charAt(ids[e]) == c) {\n        e++;\n      }\n      boolean duplicate = e < n && s.charAt(ids[e]) > c;\n      // System.out.format("  b:%d v:%d e:%d dup:%b\\n", b, v, e, duplicate);\n      if (!duplicate) {\n        b = e;\n        continue;\n      }\n\n      // We may duplicate some nodes between [b,e) as long as there is budget\n      for (int i = b; i < e; i++) {\n        int id = ids[i];\n        if (nodes[id][4] == 1) {\n          // skip ones already decided to duplicate earlier (part chain).\n          continue;\n        }\n\n        // Can we afford duplicate i?\n        // walk up parent chain until a duplicated node or root\n        int needed = 0;\n        // w is the node id\n        int w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          needed++;\n          int p = nodes[w][0];\n          if (p != 0 && nodes[p][4] == 0 && nodes[p][5] < nodes[w][5]) {\n            // do not trigger duplicate of an ancestor in front as it will make things worse\n            needed = Integer.MAX_VALUE;\n            break;\n          }\n          // if (p != 0 && nodes[p][4])\n          w = nodes[w][0];\n        }\n        // System.out.format("    i:%d id:%d needed:%d avail:%d\\n", i, id, needed, avail);\n        if (needed > avail) {\n          continue;\n        }\n        w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          nodes[w][4] = 1;\n          avail--;\n          w = nodes[w][0];\n        }\n        myAssert(avail >= 0);\n      }\n      b = e;\n    }\n    // System.out.format("%s\\n", Utils.trace(ids));\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    StringBuilder sb = new StringBuilder();\n    for (int v : ids) {\n      sb.append(s.charAt(v));\n      if (nodes[v][4] == 1) {\n        sb.append(s.charAt(v));\n      }\n    }\n    return sb.toString();\n  }\n\n  // [parent, depth, subtree size, done]\n  static int[][] dfsNodes(int[][] lr) {\n    int n = lr.length - 1;\n    int[][] nodes = new int[n + 1][6];\n    Stack<Integer> stack = new Stack<>();\n    stack.push(1);\n    nodes[1][1] = 1;\n    while (!stack.isEmpty()) {\n      int v = stack.peek();\n      // System.out.format("  v:%d %s\\n", v, Arrays.toString(nodes[v]));\n      int l = lr[v][0];\n      int r = lr[v][1];\n      if (l == 0 && r == 0) {\n        nodes[v][2] = 1;\n        nodes[v][3] = 1;\n        stack.pop();\n      } else if (l > 0 && r == 0) {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        } else {\n          nodes[v][2] = 1 + nodes[l][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else if (l == 0 && r > 0) {\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        } else {\n          nodes[v][2] = 1 + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        }\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        }\n        if (nodes[l][3] == 1 && nodes[r][3] == 1) {\n          nodes[v][2] = 1 + nodes[l][2] + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      }\n    }\n    return nodes;\n  }\n\n  static String trace(int[] a) {\n    StringBuilder sb = new StringBuilder();\n    for (int v : a) {\n     if (sb.length() > 0) {\n       sb.append(\' \');\n     }\n      sb.append(v);\n    }\n    return sb.toString();\n  }\n\n  static void myAssert(boolean cond) {\n    if (!cond) {\n      throw new RuntimeException("Unexpected");\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner in = getInputScanner();\n    int n = in.nextInt();\n    int k = in.nextInt();\n    String s = \' \' + in.next();\n    int[][] lr = new int[n + 1][2];\n    for (int i = 1; i <= n; i++) {\n      lr[i][0] = in.nextInt();\n      lr[i][1] = in.nextInt();\n    }\n    String ans = solve(s, k, lr);\n    System.out.println(ans);\n    in.close();\n  }\n\n  static Scanner getInputScanner() {\n    try {\n      final String USERDIR = System.getProperty("user.dir");\n      final String CNAME = MethodHandles.lookup().lookupClass().getSimpleName();\n      final File fin = new File(USERDIR + "/io/c" + CNAME.substring(1,5) + "/" + CNAME + ".in");\n      return fin.exists() ? new Scanner(fin) : new Scanner(System.in);\n    } catch (Exception e) {\n      return new Scanner(System.in);\n    }\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \' \' << H;\n  debug_out(T...);\n}\nconst long long MOD = 1e9 + 7;\nconst int N = 2e5 + 1;\nint l[N], r[N], lm[N], p[N][20], nxt[N], dept[N];\nvector<bool> nxtpos(N + 1, 0);\nvector<char> s(N);\nint n, k;\nvoid lmq(int cur) {\n  lm[cur] = cur;\n  if (l[cur] > 0) {\n    dept[l[cur]] = dept[cur] + 1;\n    p[l[cur]][0] = cur;\n    lmq(l[cur]);\n    lm[cur] = lm[l[cur]];\n  }\n  if (r[cur] > 0) {\n    dept[r[cur]] = dept[cur] + 1;\n    p[r[cur]][0] = cur;\n    lmq(r[cur]);\n  }\n}\nvoid setnext(int cur, int rlp) {\n  if (r[cur] > 0) {\n    nxt[cur] = lm[r[cur]];\n    setnext(r[cur], rlp);\n  } else {\n    nxtpos[cur] = 1;\n    nxt[cur] = rlp;\n  }\n  if (l[cur] > 0) setnext(l[cur], cur);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dept[1] = 1;\n  lmq(1);\n  setnext(1, 0);\n  for (int i = 1; i < 20; i++) {\n    for (int j = 1; j <= n; j++) {\n      p[j][i] = p[p[j][i - 1]][i - 1];\n    }\n  }\n  vector<bool> dup(n + 1, 0), ndup(n + 1, 0);\n  vector<int> checkdup(n + 1, 0);\n  int cur = lm[1];\n  while (cur != 0) {\n    if (dup[cur] || ndup[cur]) {\n      cur = nxt[cur];\n      continue;\n    }\n    if (checkdup[cur] == 0) {\n      int tt = nxt[cur];\n      while (tt != 0 && s[cur] == s[tt]) tt = nxt[tt];\n      if (tt == 0) break;\n      int temp = cur;\n      while (s[cur] == s[temp]) {\n        if (s[cur] < s[tt])\n          checkdup[cur] = 1;\n        else\n          checkdup[cur] = -1;\n        temp = nxt[temp];\n      }\n    }\n    if (checkdup[cur] == 1) {\n      int len = 0, temp = cur, i = 19;\n      while (p[temp][0] > 0 && !dup[p[temp][0]]) {\n        for (; i >= 0; i--) {\n          if (p[temp][i] > 0 && !dup[p[temp][i]]) {\n            len += (1 << i);\n            temp = p[temp][i];\n            break;\n          }\n        }\n      }\n      len++;\n      temp = cur;\n      if (len <= k) {\n        k -= len;\n        while (len--) {\n          dup[temp] = 1;\n          temp = p[temp][0];\n        }\n      }\n    }\n    if (s[cur] > s[nxt[cur]]) {\n      queue<int> q;\n      q.push(cur);\n      while (!q.empty()) {\n        int temp = q.front();\n        q.pop();\n        ndup[temp] = 1;\n        if (l[temp] > 0) {\n          q.push(l[temp]);\n        }\n        if (r[temp] > 0) {\n          q.push(r[temp]);\n        }\n      }\n    }\n    cur = nxt[cur];\n  }\n  int start = lm[1];\n  while (start != 0) {\n    if (dup[start]) {\n      cout << s[start] << s[start];\n    } else {\n      cout << s[start];\n    }\n    start = nxt[start];\n  }\n  cout << "\\n";\n  return 0;\n}\n', '#include <bits/stdc++.h>\n\n#define fr(i, a, b) for(int i = (a); i <= (b); i++)\n#define rf(i, a, b) for(int i = (a); i >= (b); i--)\n#define fe(x, y) for(auto& x : y)\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n#define pw(x) (1LL << (x))\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\n\nmt19937_64 rng(chrono::system_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define fbo find_by_order\n#define ook order_of_key\n\ntemplate<typename T>\nbool umn(T& a, T b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T>\nbool umx(T& a, T b) { return a < b ? a = b, 1 : 0; }\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T>\nusing ve = vector<T>;\n\nconst int N = 2e5 + 5;\n\nint n, k;\nchar c[N];\nint l[N], r[N];\nstring s;\nve<int> st;\nbool good[N];\nbool ans[N];\n\nint cost[N];\n\nvoid DFS(int v = 1) {\n    if(l[v]) {\n        cost[l[v]] = cost[v] + 1;\n        DFS(l[v]);\n    }\n    ans[v] |= ans[l[v]];\n\n    // cout << v << " " << cost[v] << " " << k << " " << good[v] << "\\n";\n\n    if(!ans[v] && good[v] && cost[v] <= k) {\n        k -= cost[v];\n        ans[v] = 1;\n    }\n\n    if(r[v] && good[v]) {\n        if(ans[v]) cost[r[v]] = 1;\n        else cost[r[v]] = cost[v] + 1;\n\n        DFS(r[v]);\n        ans[v] |= ans[r[v]];\n    }\n}\n\nvoid dfs(int v = 1) {\n    if(l[v]) dfs(l[v]);\n    st.pb(v);\n    if(r[v]) dfs(r[v]);\n}\n\nint main() {\n#ifndef LOCAL\n    // freopen("input.txt", "r", stdin);\n    // freopen("output.txt", "w", stdout);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n#else\n    // freopen("input.txt", "r", stdin);\n    // freopen("output.txt", "w", stdout);\n#endif\n\n    cin >> n >> k;\n\n    fr(i, 1, n) {\n        cin >> c[i];\n    }\n\n    fr(i, 1, n) {\n        cin >> l[i] >> r[i];\n    }\n\n    dfs();\n\n    // fr(i, 0, sz(st) - 1) cout << c[st[i]];\n    // cout << "\\n";\n\n    rf(i, sz(st) - 2, 0) {\n        if(c[st[i]] < c[st[i + 1]] || (c[st[i]] == c[st[i + 1]] && good[st[i + 1]])) {\n            good[st[i]] = 1;\n        }\n    }\n\n    cost[1] = 1;\n    DFS();\n\n    // fe(x, st) cout << x << " ";\n    // cout << "\\n";\n\n    // fe(x, st) cout << c[x];\n    // cout << "\\n";\n\n    fe(x, st) {\n        cout << c[x];\n        if(ans[x]) cout << c[x];\n    }\n    cout << "\\n";\n\n\n    return 0;\n}', '#include <bits/stdc++.h>\nusing namespace std;\nconst int w = 200010;\nint n, k;\nstring s;\nint l[w], r[w];\nbool good[w];\nbool cpy[w];\nvector<int> vec;\nvoid build(int u) {\n  if (l[u]) build(l[u]);\n  vec.push_back(u);\n  if (r[u]) build(r[u]);\n}\nvoid dfs(int u, int cnt) {\n  if (cnt > k) return;\n  if (l[u]) dfs(l[u], cnt + 1);\n  if (cpy[l[u]]) {\n    cpy[u] = true;\n  } else if (good[u]) {\n    cpy[u] = true;\n    k -= cnt;\n  }\n  if (cpy[u] && r[u]) dfs(r[u], 1);\n}\nint main() {\n  cin >> n >> k;\n  cin >> s;\n  s = \' \' + s;\n  for (int i = 1; i <= n; i++) {\n    int a, b;\n    scanf("%d%d", &a, &b);\n    l[i] = a, r[i] = b;\n  }\n  build(1);\n  for (int i = n - 2; i >= 0; i--) {\n    int a = vec[i], b = vec[i + 1];\n    if (s[a] < s[b]) good[a] = true;\n  }\n  dfs(1, 1);\n  for (int i = 0; i < vec.size(); i++) {\n    int t = vec[i];\n    cout << s[t];\n    if (cpy[t]) cout << s[t];\n  }\n  cout << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\npair<int, int> ch[200005];\nint parent[20][200005], depth[200005];\nint isDuped[200005];\nstring second, s1 = "";\nint n, k, c = 0;\nvoid nextChar(int u) {\n  if (ch[u].first != -1) {\n    nextChar(ch[u].first);\n  }\n  s1 += second[u];\n  if (ch[u].second != -1) {\n    nextChar(ch[u].second);\n  }\n}\nvoid dfs(int u, bool canDupe) {\n  if (ch[u].first != -1) {\n    depth[ch[u].first] = depth[u] + 1;\n    dfs(ch[u].first, canDupe);\n  }\n  if (isDuped[u] == -1 && canDupe) {\n    int target = 0;\n    if (s1[c] < s1[c + 1]) target = 1;\n    if (s1[c] == s1[c + 1]) target = -1;\n    int v = u;\n    for (int i = 19; i >= 0; i--) {\n      if (isDuped[parent[i][v]] == -1) {\n        v = parent[i][v];\n      }\n    }\n    if (depth[u] - depth[v] + 1 <= k && target == 1 &&\n        isDuped[parent[0][v]] != 0) {\n      v = u;\n      while (isDuped[v] == -1) {\n        isDuped[v] = 1;\n        k--;\n        v = parent[0][v];\n      }\n    }\n    if (target == 0) {\n      canDupe = 0;\n    }\n  }\n  c++;\n  if (ch[u].second != -1) {\n    depth[ch[u].second] = depth[u] + 1;\n    dfs(ch[u].second, canDupe);\n  }\n}\nvoid print(int u) {\n  if (ch[u].first != -1) {\n    print(ch[u].first);\n  }\n  cout << second[u];\n  if (isDuped[u] == 1) cout << second[u];\n  if (ch[u].second != -1) {\n    print(ch[u].second);\n  }\n}\nint main() {\n  cin >> n >> k >> second;\n  for (int i = 0; i < n; i++) {\n    isDuped[i] = -1;\n    int a, b;\n    cin >> a >> b;\n    if (a != 0) parent[0][a - 1] = i;\n    if (b != 0) parent[0][b - 1] = i;\n    ch[i] = {a - 1, b - 1};\n  }\n  for (int i = 1; i < 20; i++) {\n    for (int j = 0; j < n; j++) {\n      parent[i][j] = parent[i - 1][parent[i - 1][j]];\n    }\n  }\n  nextChar(0);\n  s1 += \'A\';\n  dfs(0, 1);\n  print(0);\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nchar c[200010];\nint l[200010];\nint r[200010];\nchar d[200010];\nint ind[200010];\nint nxt[200010];\nbool needa[200010];\nconst int LOG = 20;\nint bu[LOG][200010];\nbool chosen[200010];\nint minbad[200010];\nint pos[200010];\nint x = 1;\nvoid dfs(int u) {\n  if (!u) return;\n  dfs(l[u]);\n  pos[u] = x;\n  d[x] = c[u];\n  ind[x] = u;\n  ++x;\n  dfs(r[u]);\n}\nvoid dfs2(int u) {\n  if (!u) return;\n  if (l[u]) {\n    bu[0][l[u]] = u;\n    minbad[l[u]] = minbad[u];\n    if (!needa[pos[u]]) {\n      minbad[l[u]] = min(minbad[l[u]], pos[u]);\n    }\n    dfs2(l[u]);\n  }\n  if (r[u]) {\n    bu[0][r[u]] = u;\n    minbad[r[u]] = minbad[u];\n    if (!needa[pos[u]]) {\n      minbad[r[u]] = min(minbad[r[u]], pos[u]);\n    }\n    dfs2(r[u]);\n  }\n}\nvector<int> wanna;\nint notcol(int u) {\n  int ans = 1;\n  for (int i = LOG - 1; i >= 0; --i) {\n    if (bu[i][u] && !chosen[bu[i][u]]) {\n      ans += 1 << i;\n      u = bu[i][u];\n    }\n  }\n  return ans;\n}\nvoid print(int u) {\n  if (!u) return;\n  print(l[u]);\n  cout << (chosen[u] ? string(2, c[u]) : string(1, c[u]));\n  print(r[u]);\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n >> k;\n  for (int i = 1; i <= n; ++i) {\n    cin >> c[i];\n  }\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  minbad[1] = 1e9;\n  dfs(1);\n  for (int i = n; i >= 1; --i) {\n    if (d[i] != d[i + 1])\n      nxt[i] = i + 1;\n    else\n      nxt[i] = nxt[i + 1];\n    needa[i] = d[nxt[i]] > d[i];\n    if (needa[i]) wanna.push_back(ind[i]);\n  }\n  dfs2(1);\n  reverse(wanna.begin(), wanna.end());\n  for (int i = 1; i < LOG; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      bu[i][j] = bu[i - 1][bu[i - 1][j]];\n    }\n  }\n  for (auto i : wanna) {\n    int position = pos[i];\n    int pre = minbad[i];\n    if (pre < position) continue;\n    int needk = notcol(i);\n    if (needk > k) continue;\n    k -= needk;\n    int j = i;\n    while (true) {\n      chosen[j] = true;\n      if (j == 1) break;\n      if (chosen[bu[0][j]]) break;\n      j = bu[0][j];\n    }\n  }\n  print(1);\n  return 0;\n}\n', '//#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//randoms\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\n#define ll long long\n#define trace(x) cout << #x << " = " << (x) << endl;\n#define all(x) x.begin(), (x).end()\n#define rall(x) x.rbegin(), (x).rend()\n#define unique(x) x.erase(unique(all(x)), (x).end())\n#define ld long double\n#define sz(s) (int) size(s)\n#define pii pair<int, int>\n#define mp(x, y) make_pair(x, y)\n\n\nconst int N = 200001;\nconst ll infL = 1e18;\nconst int infI = 1e9 + 7;\nconst int LG = 19;\nint n, k, l[N], r[N], d[N], jump[LG][N];\nbool used[N];\nchar c[N];\n\nvoid init() {\n    for (int j = 1; j < LG; ++j) {\n        for (int i = 0; i < n; ++i)\n            jump[j][i] = jump[j - 1][jump[j - 1][i]];\n    }\n}\n\nint lca(int v, int u) {\n    if (d[u] < d[v]) swap(u, v);\n    for (int i = LG - 1; i > -1; --i)\n        if (d[jump[i][u]] >= d[v])\n            u = jump[i][u];\n    if (v == u) {\n        return v;\n    }\n    for (int i = LG - 1; i > -1; --i) {\n        if (jump[i][u] != jump[i][v]) {\n            u = jump[i][u];\n            v = jump[i][v];\n        }\n    }\n    return jump[0][u];\n}\n\nstring wow;\nint idx[N];\n\nvoid precalc(int v, int dep, int p) {\n    d[v] = dep;\n    jump[0][v] = p;\n    if (l[v] != -1) precalc(l[v], dep + 1, v);\n    idx[v] = sz(wow);\n    wow.push_back(c[v]);\n    if (r[v] != -1) precalc(r[v], dep + 1, v);\n}\n\nvector<int> colored;\n\nbool yay(int v) {\n    if (colored.empty() && d[v] + 1 <= k) {\n        colored.push_back(v);\n        k -= d[v] + 1;\n        return true;\n    } else if (colored.empty()) return false;\n    int u = colored.back();\n    int cc = lca(u, v);\n    int len = d[cc] - d[u];\n    if (len <= k) {\n        k -= len;\n        colored.push_back(v);\n        return true;\n    }\n    return false;\n}\n\n\nvoid dfs(int v, bool fuck) {\n    if (l[v] != -1) dfs(l[v], fuck);\n    bool now = fuck && (wow[idx[v]] > c[v]);\n    if (now) used[v] = yay(v);\n    if (r[v] != -1) {\n        dfs(r[v], now);\n    }\n}\nstring ans;\nvoid getAns(int v){\n    if (l[v] != -1) {used[v] |= used[l[v]];getAns(l[v]);}\n    if (r[v] != -1) used[v] |= used[r[v]];\n    ans.push_back(c[v]);\n    if (used[v]) ans.push_back(c[v]);\n    if (r[v] != -1) getAns(r[v]);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> k ;\n    string str;\n    cin >> str;\n    for (int i = 0; i < n; ++i)\n        c[i] = str[i];\n    for (int i = 0; i < n; ++i) {\n        cin >> l[i] >> r[i];\n        --l[i], --r[i];\n    }\n    precalc(0, 0, 0);\n    wow.push_back(char(0));\n    string zz = wow;\n    for (int i = sz(wow) - 2; i > -1; --i) {\n        if (zz[i] == zz[i + 1])\n            wow[i] = wow[i + 1];\n        else\n            wow[i] = zz[i + 1];\n    }\n    init();\n    dfs(0, true);\n    getAns(0);\n    cout << ans;\n    return 0;\n}', 'import sys\nfrom sys import stdin\nimport math\n\n\ntt = 1\n\nANS = []\n\nfor _ in range(tt):\n\n    n,k = map(int,stdin.readline().split())\n    c = stdin.readline()[:-1]\n\n    lr = []\n    for i in range(n):\n        l,r = map(int,stdin.readline().split())\n        lr.append( (l-1,r-1) )\n\n    stk = []\n    p = []\n\n    stk.append( [0,0] )\n    while stk:\n        #print (stk)\n        v = stk[-1][0]\n        state = stk[-1][1]\n        \n        if state == 0:\n            stk[-1][1] += 1\n            if lr[v][0] >= 0:\n                stk.append( [lr[v][0],0] )\n        elif state == 1:\n            p.append( v )\n            stk[-1][1] += 1\n            if lr[v][1] >= 0:\n                stk.append( [lr[v][1],0] )\n        else:\n            del stk[-1]\n\n    flags = []\n    cstk = []\n    for i in range(n-1,-1,-1):\n        nv = p[i]\n        nc = c[nv]\n\n        nf = False\n        if len(cstk) >= 1 and cstk[-1] > nc:\n            nf = True\n        elif len(cstk) >= 2 and cstk[-1] == nc and cstk[-2] > nc:\n            nf = True\n\n        if len(cstk) == 0 or cstk[-1] != nc:\n            cstk.append(nc)\n\n        flags.append(nf)\n\n    flags.reverse()\n\n    #print (p)\n    #print (flags)\n\n    ans = []\n    for i in range(n):\n        v = p[i]\n        if flags[i] and k > 0:\n            ans.append( c[v] * 2 )\n            k -= 1\n        else:\n            ans.append( c[v] )\n\n    print ("".join(ans))\n            \n            \n\n#print ("\\n".join(ANS))', '#include <bits/stdc++.h>\nusing namespace std;\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \' \' << H;\n  debug_out(T...);\n}\nconst long long MOD = 1e9 + 7;\nconst int N = 2e5 + 1;\nint l[N], r[N], lm[N], p[N][20], nxt[N], dept[N];\nvector<bool> nxtpos(N + 1, 0);\nvector<char> s(N);\nint n, k;\nvoid lmq(int cur) {\n  lm[cur] = cur;\n  if (l[cur] > 0) {\n    dept[l[cur]] = dept[cur] + 1;\n    p[l[cur]][0] = cur;\n    lmq(l[cur]);\n    lm[cur] = lm[l[cur]];\n  }\n  if (r[cur] > 0) {\n    dept[r[cur]] = dept[cur] + 1;\n    p[r[cur]][0] = cur;\n    lmq(r[cur]);\n  }\n}\nvoid setnext(int cur, int rlp) {\n  if (r[cur] > 0) {\n    nxt[cur] = lm[r[cur]];\n    setnext(r[cur], rlp);\n  } else {\n    nxtpos[cur] = 1;\n    nxt[cur] = rlp;\n  }\n  if (l[cur] > 0) setnext(l[cur], cur);\n}\nint main() {\n  cin >> n >> k;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n  }\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dept[1] = 1;\n  lmq(1);\n  setnext(1, 0);\n  for (int i = 1; i < 20; i++) {\n    for (int j = 1; j <= n; j++) {\n      p[j][i] = p[p[j][i - 1]][i - 1];\n    }\n  }\n  vector<bool> dup(n + 1, 0), ndup(n + 1, 0);\n  int cur = lm[1];\n  while (cur != 0) {\n    if (dup[cur] || ndup[cur]) {\n      cur = nxt[cur];\n      continue;\n    }\n    if (s[cur] < s[nxt[cur]]) {\n      int len = 0, temp = cur, i = 19;\n      while (p[temp][0] > 0 && !dup[p[temp][0]]) {\n        for (; i >= 0; i--) {\n          if (p[temp][i] > 0 && !dup[p[temp][i]]) {\n            len += (1 << i);\n            temp = p[temp][i];\n            break;\n          }\n        }\n      }\n      len++;\n      temp = cur;\n      if (len <= k) {\n        k -= len;\n        while (len--) {\n          dup[temp] = 1;\n          temp = p[temp][0];\n        }\n      }\n    }\n    if (s[cur] > s[nxt[cur]]) {\n      queue<int> q;\n      q.push(cur);\n      while (!q.empty()) {\n        int temp = q.front();\n        q.pop();\n        ndup[temp] = 1;\n        if (l[temp] > 0) {\n          q.push(l[temp]);\n        }\n        if (r[temp] > 0) {\n          q.push(r[temp]);\n        }\n      }\n    }\n    cur = nxt[cur];\n  }\n  int start = lm[1];\n  while (start != 0) {\n    if (dup[start]) {\n      cout << s[start] << s[start];\n    } else {\n      cout << s[start];\n    }\n    start = nxt[start];\n  }\n  cout << "\\n";\n  return 0;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)2e5 + 50, LOGN = 17;\nconst int INF = (int)1e9;\nint n, k;\nint ord[N], in[N], tim = 0;\nchar las[N];\nint lc[N], rc[N];\nint res[N];\nstring str;\nvoid dfs(int v) {\n  if (lc[v] != -1) dfs(lc[v]);\n  ord[tim] = v;\n  in[v] = tim++;\n  if (rc[v] != -1) dfs(rc[v]);\n}\nvoid solve(int v, int& rem) {\n  int la = -1;\n  int cur = v;\n  for (int i = 0; i < (rem); ++i) {\n    if (cur == -1) break;\n    if (las[cur] != ' ' && las[cur] > str[cur]) {\n      la = i;\n    }\n    cur = lc[v];\n  }\n  cur = v;\n  vector<int> vs;\n  for (int i = 0; i < (la + 1); ++i) {\n    res[cur] = 1;\n    rem--;\n    vs.push_back(cur);\n    cur = lc[cur];\n  }\n  while (!vs.empty()) {\n    if (rc[vs.back()] != -1) solve(rc[vs.back()], rem);\n    vs.pop_back();\n  }\n}\nvoid print_ans(int v) {\n  if (lc[v] != -1) print_ans(lc[v]);\n  cout << str[v];\n  if (res[v]) cout << str[v];\n  if (rc[v] != -1) print_ans(rc[v]);\n}\nint pos[256];\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n  cin >> n >> k;\n  cin >> str;\n  for (int i = 0; i < (n); ++i) {\n    cin >> lc[i] >> rc[i];\n    lc[i]--, rc[i]--;\n  }\n  dfs(0);\n  fill(pos, pos + 256, INF);\n  for (int i = n - 1; i >= 0; i--) {\n    pos[str[ord[i]]] = i;\n    char f = ' ';\n    for (char c = 'a'; c <= 'z'; c++) {\n      if (c != str[ord[i]] && pos[f] > pos[c]) f = c;\n    }\n    las[ord[i]] = f;\n  }\n  solve(0, k);\n  assert(k >= 0);\n  print_ans(0);\n}\n", '// package c1623;\n\nimport java.io.File;\nimport java.lang.invoke.MethodHandles;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n//\n// Codeforces Round #763 (Div. 2) 2021-12-28 05:35\n// E. Middle Duplication\n// https://codeforces.com/contest/1623/problem/E\n// time limit per test 1 second; memory limit per test 256 megabytes\n// public class Pseudo for \'Source should satisfy regex [^{}]*public\\s+(final)?\\s*class\\s+(\\w+).*\'\n//\n// A binary tree of n nodes is given. Nodes of the tree are numbered from 1 to n and the root is the\n// node 1. Each node can have no child, only one left child, only one right child, or both children.\n// For convenience, let\'s denote l_u and r_u as the left and the right child of the node u\n// respectively, l_u = 0 if u does not have the left child, and r_u = 0 if the node u does not have\n// the right child.\n//\n// Each node has a string label, initially is a single character c_u. Let\'s define the string\n// representation of the binary tree as the concatenation of the labels of the nodes in the .\n// Formally, let f(u) be the string representation of the tree rooted at the node u. f(u) is defined\n// as follows: <div class="MathJax_Display" style="text-align: center;"></div> f(u) = \\begin{cases}\n// \\texttt{<empty string>}, & \\text{if }u = 0; \\\\ f(l_u) + c_u + f(r_u) & \\text{otherwise},\n// \\end{cases} where + denotes the string concatenation operation.\n//\n// This way, the string representation of the tree is f(1).\n//\n// For each node, we can its label , that is, assign c_u with c_u + c_u, but only if u is the root\n// of the tree, or if its parent also has its label duplicated.\n//\n// You are given the tree and an integer k. What is the lexicographically smallest string\n// representation of the tree, if we can duplicate labels of at most k nodes?\n//\n// A string a is lexicographically smaller than a string b if and only if one of the following\n// holds:\n//  * a is a prefix of b, but a \\ne b;\n//  * in the first position where a and b differ, the string a has a letter that appears earlier in\n//    the alphabet than the corresponding letter in b. </div><div class="input-specification"><div\n// class="section-title">Input</div>\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Input\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Output\n//\n// Print a single line, containing the lexicographically smallest string representation of the tree\n// if at most k nodes have their labels duplicated.\n//\n// Example\n/*\ninput:\n4 3\nabab\n2 3\n0 0\n0 4\n0 0\n\noutput:\nbaaaab\n\ninput:\n8 2\nkadracyn\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndaarkkcyan\n\ninput:\n8 3\nkdaracyn\n2 5\n0 3\n0 4\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndarkcyan\n*/\n// Note\n//\n// The images below present the tree for the examples. The number in each node is the node number,\n// while the subscripted letter is its label. To the right is the string representation of the tree,\n// with each letter having the same color as the corresponding node.\n//\n// Here is the tree for the first example. Here we duplicated the labels of nodes 1 and 3. We should\n// not duplicate the label of node 2 because it would give us the string "", which is\n// lexicographically greater than "".\n// https://espresso.codeforces.com/30116fa124ec3edbd4c16ac29fa8eb45c19cc171.png\n//\n// In the second example, we can duplicate the labels of nodes 1 and 2. Note that only duplicating\n// the label of the root will produce a worse result than the initial string.\n// https://espresso.codeforces.com/e66a56b1c8dee019f4f4c138ee0333caf44b312c.png\n//\n// In the third example, we should not duplicate any character at all. Even though we would want to\n// duplicate the label of the node 3, by duplicating it we must also duplicate the label of the node\n// 2, which produces a worse result.\n// https://espresso.codeforces.com/19b0d4c5514801c166e9b3f0ef4c110939711a20.png\n//\n// There is no way to produce string "" from a tree with the initial string representation "" :(.\n//\npublic class C1623E {\n  static final int MOD = (int)1e9+7;\n  static final Random RAND = new Random();\n\n  static String solve(String s, int k, int[][] lr) {\n    // Note that both s and lr have length n + 1\n    int n = s.length() - 1;\n\n    // [parent, depth, subtree size, done, duplicate]\n    int[][] nodes = dfsNodes(lr);\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n\n    // ids in in-order\n    int[] ids = new int[n];\n\n    // id, offset\n    Queue<int[]> q = new LinkedList<>();\n    q.add(new int[] {1, 0});\n    while (!q.isEmpty()) {\n      int[] e = q.poll();\n      int v = e[0];\n      int offset = e[1];\n      int l = lr[v][0];\n      int r = lr[v][1];\n      int idx = offset;\n      if (l > 0) {\n        q.add(new int[] {l, idx});\n        idx += nodes[l][2];\n      }\n      ids[idx++] = v;\n      if (r > 0) {\n        q.add(new int[] {r, idx});\n      }\n    }\n    // System.out.format("%s\\n", Utils.trace(ids));\n\n    // fill arr[i][1] which indicate whether to duplicate arr[i][0]\n    int b = 1;\n    int avail = k;\n    while (b < n) {\n      int v = ids[b];\n      // System.out.format("  b:%d v:%d depth:%d k:%d\\n", b, v, nodes[v][1], k);\n      if (nodes[v][1] > k) {\n        // don\'t bother if v is too deep\n        b++;\n        continue;\n      }\n      char c = s.charAt(v);\n      int e = b + 1;\n      while (e < n && s.charAt(ids[e]) == c) {\n        e++;\n      }\n      boolean duplicate = e < n && s.charAt(ids[e]) > c;\n      // System.out.format("  b:%d v:%d e:%d dup:%b\\n", b, v, e, duplicate);\n      if (!duplicate) {\n        b = e;\n        continue;\n      }\n\n      // We may duplicate some nodes between [b,e) as long as there is budget\n      for (int i = b; i < e; i++) {\n        int id = ids[i];\n        if (nodes[id][4] == 1) {\n          // skip ones already decided to duplicate earlier (part chain).\n          continue;\n        }\n\n        // Can we afford duplicate i?\n        // walk up parent chain until a duplicated node or root\n        int needed = 0;\n        // w is the node id\n        int w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          needed++;\n          w = nodes[w][0];\n        }\n        // System.out.format("    i:%d id:%d needed:%d avail:%d\\n", i, id, needed, avail);\n        if (needed > avail) {\n          continue;\n        }\n        w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          nodes[w][4] = 1;\n          avail--;\n          w = nodes[w][0];\n        }\n        myAssert(avail >= 0);\n      }\n      b = e;\n    }\n    // System.out.format("%s\\n", Utils.trace(ids));\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    StringBuilder sb = new StringBuilder();\n    for (int v : ids) {\n      sb.append(s.charAt(v));\n      if (nodes[v][4] == 1) {\n        sb.append(s.charAt(v));\n      }\n    }\n    return sb.toString();\n  }\n\n  // [parent, depth, subtree size, done]\n  static int[][] dfsNodes(int[][] lr) {\n    int n = lr.length - 1;\n    int[][] nodes = new int[n + 1][5];\n    Stack<Integer> stack = new Stack<>();\n    stack.push(1);\n    nodes[1][1] = 1;\n    while (!stack.isEmpty()) {\n      int v = stack.peek();\n      // System.out.format("  v:%d %s\\n", v, Arrays.toString(nodes[v]));\n      int l = lr[v][0];\n      int r = lr[v][1];\n      if (l == 0 && r == 0) {\n        nodes[v][2] = 1;\n        nodes[v][3] = 1;\n        stack.pop();\n      } else if (l > 0 && r == 0) {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        } else {\n          nodes[v][2] = 1 + nodes[l][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else if (l == 0 && r > 0) {\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        } else {\n          nodes[v][2] = 1 + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        }\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        }\n        if (nodes[l][3] == 1 && nodes[r][3] == 1) {\n          nodes[v][2] = 1 + nodes[l][2] + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      }\n    }\n    return nodes;\n  }\n\n  static String trace(int[] a) {\n    StringBuilder sb = new StringBuilder();\n    for (int v : a) {\n     if (sb.length() > 0) {\n       sb.append(\' \');\n     }\n      sb.append(v);\n    }\n    return sb.toString();\n  }\n\n  static void myAssert(boolean cond) {\n    if (!cond) {\n      throw new RuntimeException("Unexpected");\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner in = getInputScanner();\n    int n = in.nextInt();\n    int k = in.nextInt();\n    String s = \' \' + in.next();\n    int[][] lr = new int[n + 1][2];\n    for (int i = 1; i <= n; i++) {\n      lr[i][0] = in.nextInt();\n      lr[i][1] = in.nextInt();\n    }\n    String ans = solve(s, k, lr);\n    System.out.println(ans);\n    in.close();\n  }\n\n  static Scanner getInputScanner() {\n    try {\n      final String USERDIR = System.getProperty("user.dir");\n      final String CNAME = MethodHandles.lookup().lookupClass().getSimpleName();\n      final File fin = new File(USERDIR + "/io/c" + CNAME.substring(1,5) + "/" + CNAME + ".in");\n      return fin.exists() ? new Scanner(fin) : new Scanner(System.in);\n    } catch (Exception e) {\n      return new Scanner(System.in);\n    }\n  }\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename A,typename B>\nstring to_string(pair<A,B>p){return"("+to_string(p.first)+", "+to_string(p.second)+")";}\ntemplate<typename A,typename B,typename C>\nstring to_string(tuple<A,B,C>p){return"("+to_string(get<0>(p))+", "+to_string(get<1>(p))+", "+to_string(get<2>(p))+")";}\ntemplate<typename A,typename B,typename C,typename D>\nstring to_string(tuple<A,B,C,D>p){return"("+to_string(get<0>(p))+", "+to_string(get<1>(p))+", "+to_string(get<2>(p))+", "+to_string(get<3>(p))+")";}\nstring to_string(const string &s){return\'"\'+s+\'"\';}\nstring to_string(const char *s){return to_string((string)s);}\nstring to_string(bool b){return(b?"true":"false");}\nstring to_string(vector<bool>v){int f=0;string r="{";for(bool i:v)r+=(f++?",":"")+to_string(i);r+="}";return r;}\ntemplate<size_t N>\nstring to_string(bitset<N>v){string res="";for(size_t i=0;i<N;res+=char(\'0\'+v[i++]));return res;}\ntemplate<typename A>\nstring to_string(A v){int f=0;string r="{";for(auto&i:v)r+=(f++?",":"")+to_string(i);r+="}";return r;}\nvoid debug_out(){cerr<<\']\'<<endl;}\ntemplate<typename Head,typename...Tail>\nvoid debug_out(Head H,Tail...T){cerr<<to_string(H);if(sizeof...(T))cerr<<", ";debug_out(T...);}\n#ifdef LOCAL\n#define debug(x...) cerr << "[" << (#x) << "] = [", debug_out(x)\n#else\n#define debug(x...) 33\n#endif\n#define int long long\nint N, K;\nchar S[200\'200];\nvector<int> g[200\'200];\nint par[200\'200];\nint dep[200\'200];\n\nvector<int> dfsOrder;\nint dfsN[200\'200];\nvoid dfs(int now)\n{\n\t\n\tfor (int i = 0; i < 2; ++i)\n\t{\n\t\tint it = g[now][i];\n\t\tif (it != -1) \n\t\t{\n\t\t\tdep[it] = dep[now] + 1;\n\t\t\tdfs(it);\n\t\t}\n\t\tif (!i)\n\t\t{\n            dfsN[now] = (int)dfsOrder.size();\n            dfsOrder.push_back(now);\n        }\n\t}\n\t// for (auto &it: g[now]) \n\t// {\n\t// \tif (it != -1) \n\t// \t{\n\t// \t\tdep[it] = dep[now] + 1;\n\t// \t\tdfs(it);\n\t// \t}\n\t// }\n}\nint nextNode[200\'200];\nbool go_dup[200\'200];\nint NodeNode[200\'200];\n\nbool real_iduc[200\'200];\nint for_who_dfsN[200\'200];\nvoid dfs2(int now)\n{\n\tfor (auto &it: g[now]) \n\t{\n\t\tif (it != -1) dfs2(it);\n\t}\n\treal_iduc[now] = go_dup[now];\n\tif (go_dup[now])\n\t{\n\t\tfor_who_dfsN[now] = dfsN[now];\n\t}\n\tif (g[now][0] != -1)\n\t{\n\t\treal_iduc[now] |= real_iduc[g[now][0]];\n\n\t\tif (real_iduc[g[now][0]])\n\t\t{\n\t\t\tfor_who_dfsN[now] = for_who_dfsN[g[now][0]];\n\t\t}\n\t}\n}\nvoid dfs3(int now, int reallll)\n{\n\treal_iduc[now] = real_iduc[now] && reallll;\n\tfor (auto &it: g[now])\n\t{\n\t\tif (it != -1) dfs3(it, reallll && real_iduc[now]);\n\t}\n}\nint really_dup[200\'200];\nsigned main()\n{\n    cin.tie(0)->sync_with_stdio(false);\n\tcin >> N >> K;\n\tcin >> S;\n\n\tpar[0] = -1;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tint u, v; cin >> u >> v; --u, --v;\n\n\t\tg[i].push_back(u);\n\t\tg[i].push_back(v);\n\t\t\n\t\tpar[u] = par[v] = i;\n\t}\n\tdfs(0);\n\t// debug(dfsOrder);\n\tmemset(nextNode, -1, sizeof nextNode);\n\tfor (int x = 0; x + 1 < (int)dfsOrder.size(); ++x)\n\t{\n\t\tnextNode[dfsOrder[x]] = dfsOrder[x + 1];\n\t}\n\n\tfor (int i = 0, j = 0; i < (int)dfsOrder.size(); ++i)\n\t{\n\t\twhile(j < (int)dfsOrder.size() && S[dfsOrder[i]] == S[dfsOrder[j]])\n\t\t\t++j;\n\n\t\tassert(i < j);\n\t\tif (j == (int)dfsOrder.size())\n\t\t{\n\t\t\tNodeNode[dfsOrder[i]] = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNodeNode[dfsOrder[i]] = dfsOrder[j];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (NodeNode[i] == -1) go_dup[i] =false;\n\t\telse\n\t\t{\n\t\t\tassert(S[i] != S[NodeNode[i]]);\n\n\t\t\tif (S[i] > S[NodeNode[i]]) go_dup[i] = false;\n\t\t\telse go_dup[i] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (dep[i] >= K)\n\t\t{\n\t\t\tgo_dup[i] = false;\n\t\t}\n\t}\n\tdfs2(0);\n\tdfs3(0, 1);\n\tvector<tuple<int, int, int>> omy;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (real_iduc[i])\n\t\t{\n\t\t\tomy.push_back({for_who_dfsN[i], -dep[i], i});\n\t\t}\n\t}\n\tsort(omy.begin(), omy.end());\n\tfor (int i = 0; i < K && i < (int)omy.size(); ++i)\n\t{\n\t\treally_dup[get<2>(omy[i])] = true;\n\t}\n\tvector<pair<int, int>> pp;\n\tfor (int i = 1; i < N; ++i)\n\t{\n\n\t\tpp.push_back({dep[i], i});\n\t}\n\tsort(pp.begin(), pp.end());\n\tfor (auto &[dp, node]: pp)\n\t{\n\t\t\n\t\tif (really_dup[par[node]] == false)\n\t\t{\n\t\t\treally_dup[node] = false;\n\t\t}\n\t}\n\tfor (int i = 1; i < N; ++i)\n\t{\n\t\tif (really_dup[i]) assert(really_dup[par[i]]);\n\t}\n\t\n\tfor (auto &it: dfsOrder)\n\t{\n\t\tcout << S[it];\n\n\t\tif (really_dup[it]) cout << S[it];\n\t}\n\tcout << \'\\n\';\n\n    return 0;\n}', '#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nint SIZE(T(&t)) {\n  return t.size();\n}\ntemplate <typename T, size_t N>\nint SIZE(T (&t)[N]) {\n  return N;\n}\nstring to_string(char t) { return "\'" + string({t}) + "\'"; }\nstring to_string(bool t) { return t ? "true" : "false"; }\nstring to_string(const string& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)), _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += t[i];\n  }\n  return \'"\' + ret + \'"\';\n}\nstring to_string(const char* t) {\n  string ret(t);\n  return to_string(ret);\n}\ntemplate <size_t N>\nstring to_string(const bitset<N>& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)); i <= min(x2, SIZE(t) - 1); ++i) {\n    ret += t[i] + \'0\';\n  }\n  return to_string(ret);\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1 = 0, int x2 = 1e9, Coords... C);\ntemplate <typename T, typename S>\nstring to_string(const pair<T, S>& t) {\n  return "(" + to_string(t.first) + ", " + to_string(t.second) + ")";\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1, int x2, Coords... C) {\n  string ret = "[";\n  x1 = min(x1, SIZE(t));\n  auto e = begin(t);\n  advance(e, x1);\n  for (int i = x1, _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += to_string(*e, C...) + (i != _i ? ", " : "");\n    e = next(e);\n  }\n  return ret + "]";\n}\ntemplate <int Index, typename... Ts>\nstruct print_tuple {\n  string operator()(const tuple<Ts...>& t) {\n    string ret = print_tuple<Index - 1, Ts...>{}(t);\n    ret += (Index ? ", " : "");\n    return ret + to_string(get<Index>(t));\n  }\n};\ntemplate <typename... Ts>\nstruct print_tuple<0, Ts...> {\n  string operator()(const tuple<Ts...>& t) { return to_string(get<0>(t)); }\n};\ntemplate <typename... Ts>\nstring to_string(const tuple<Ts...>& t) {\n  const auto Size = tuple_size<tuple<Ts...>>::value;\n  return print_tuple<Size - 1, Ts...>{}(t);\n}\nvoid dbgr() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgr(Heads H, Tails... T) {\n  cout << to_string(H) << " | ";\n  dbgr(T...);\n}\nvoid dbgs() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgs(Heads H, Tails... T) {\n  cout << H << " ";\n  dbgs(T...);\n}\nconst int N = 1e5 + 5;\nconst long long INF = 1e18 + 7;\nconst int MAXA = 1e9;\nconst int B = sqrt(N) + 5;\nint l[N], r[N], pv[N];\nbool dou[N], ok[N];\nstring s;\ndeque<char> ans[N];\ndeque<int> pos[N];\nint n, k;\nvoid dfs(int u) {\n  if (u == 0) return;\n  dfs(l[u]);\n  dfs(r[u]);\n  if (ans[l[u]].size() > ans[r[u]].size()) {\n    swap(ans[u], ans[l[u]]);\n    swap(pos[u], pos[l[u]]);\n    ans[u].push_back(s[u]);\n    pos[u].push_back(u);\n    for (char i : ans[r[u]]) {\n      ans[u].push_back(i);\n    }\n    for (int i : pos[r[u]]) {\n      pos[u].push_back(i);\n    }\n  } else {\n    swap(ans[u], ans[r[u]]);\n    swap(pos[u], pos[r[u]]);\n    ans[u].push_front(s[u]);\n    pos[u].push_front(u);\n    reverse(ans[l[u]].begin(), ans[l[u]].end());\n    reverse(pos[l[u]].begin(), pos[l[u]].end());\n    for (char i : ans[l[u]]) {\n      ans[u].push_front(i);\n    }\n    for (int i : pos[l[u]]) {\n      pos[u].push_front(i);\n    }\n  }\n}\nbool dfs_opt(int u, int h) {\n  bool f = false;\n  if (ok[pv[u]] && k >= h) {\n    k -= h;\n    dou[u] = true;\n    if (l[u]) dfs_opt(l[u], 1);\n    if (r[u]) dfs_opt(r[u], 1);\n    return true;\n  } else {\n    if (l[u]) f |= dfs_opt(l[u], h + 1);\n    if (f) dou[u] = true;\n    if (dou[u]) dfs_opt(r[u], h + 1);\n    return false;\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  cin >> s;\n  s = " " + s;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  dfs(1);\n  s = " ";\n  for (char i : ans[1]) s += i;\n  for (int i = 0; i < n; ++i) pv[pos[1][i]] = i + 1;\n  int l = 1;\n  for (int i = 1; i < n; ++i) {\n    if (s[i] != s[i + 1]) {\n      if (s[i] < s[i + 1]) {\n        for (int j = l; j <= i; ++j) ok[j] = true;\n      }\n      l = i + 1;\n    }\n  }\n  dfs_opt(1, 1);\n  for (int i = 1; i <= n; ++i) {\n    cout << s[i];\n    if (dou[pos[1][i - 1]]) cout << s[i];\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\ntemplate <typename T>\nbool chmax(T &x, const T &y) {\n  return (x < y) ? (x = y, true) : false;\n}\ntemplate <typename T>\nbool chmin(T &x, const T &y) {\n  return (x > y) ? (x = y, true) : false;\n}\ntemplate <typename T>\nint flg(T x, int i) {\n  return (x >> i) & 1;\n}\ntemplate <typename T>\nvoid print(const vector<T> &v, T x = 0) {\n  int n = v.size();\n  for (int i = 0; i < n; i++) cout << v[i] + x << (i == n - 1 ? '\\n' : ' ');\n  if (v.empty()) cout << '\\n';\n}\ntemplate <typename T>\nvoid printn(const vector<T> &v, T x = 0) {\n  int n = v.size();\n  for (int i = 0; i < n; i++) cout << v[i] + x << '\\n';\n}\ntemplate <typename T>\nint lb(const vector<T> &v, T x) {\n  return lower_bound(begin(v), end(v), x) - begin(v);\n}\ntemplate <typename T>\nint ub(const vector<T> &v, T x) {\n  return upper_bound(begin(v), end(v), x) - begin(v);\n}\ntemplate <typename T>\nvoid rearrange(vector<T> &v) {\n  sort(begin(v), end(v));\n  v.erase(unique(begin(v), end(v)), end(v));\n}\ntemplate <typename T>\nvector<int> id_sort(const vector<T> &v, bool greater = false) {\n  int n = v.size();\n  vector<int> ret(n);\n  iota(begin(ret), end(ret), 0);\n  sort(begin(ret), end(ret),\n       [&](int i, int j) { return greater ? v[i] > v[j] : v[i] < v[j]; });\n  return ret;\n}\ntemplate <typename S, typename T>\npair<S, T> operator+(const pair<S, T> &p, const pair<S, T> &q) {\n  return make_pair(p.first + q.first, p.second + q.second);\n}\ntemplate <typename S, typename T>\npair<S, T> operator-(const pair<S, T> &p, const pair<S, T> &q) {\n  return make_pair(p.first - q.first, p.second - q.second);\n}\ntemplate <typename S, typename T>\nistream &operator>>(istream &is, pair<S, T> &p) {\n  S a;\n  T b;\n  is >> a >> b;\n  p = make_pair(a, b);\n  return is;\n}\ntemplate <typename S, typename T>\nostream &operator<<(ostream &os, const pair<S, T> &p) {\n  return os << p.first << ' ' << p.second;\n}\nstruct io_setup {\n  io_setup() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout << fixed << setprecision(15);\n  }\n} io_setup;\nconst int inf = (1 << 30) - 1;\nconst ll INF = (1LL << 60) - 1;\nconst int MOD = 1000000007;\nstring S;\ntemplate <bool directed = false>\nstruct Graph {\n  const int n;\n  vector<int> l, r;\n  vector<int> vs;\n  vector<int> ls, rs;\n  string ans;\n  vector<bool> flag;\n  Graph(int n) : n(n), ls(n), rs(n), l(n, -1), r(n, -1), flag(n, false) {}\n  void euler_tour(int now) {\n    ls[now] = vs.size(), vs.push_back(now);\n    if (l[now] != -1) euler_tour(l[now]);\n    if (r[now] != -1) euler_tour(r[now]);\n    rs[now] = vs.size();\n  }\n  int dfs(int now, int k) {\n    int ret = 0;\n    bool used = false;\n    if (l[now] != -1) {\n      int x = dfs(l[now], max(k - 1, 0));\n      ret += x;\n      k -= x;\n      if (x > 0) used = true;\n    }\n    if (k > 0 && !used && flag[now]) used = true;\n    ans += S[now];\n    if (used) k--, ret++, ans += S[now];\n    if (r[now] != -1) {\n      int y = dfs(r[now], (used ? k : 0));\n      ret += y;\n      k -= y;\n    }\n    return ret;\n  }\n  void solve(int k) {\n    euler_tour(0);\n    for (int i = 0; i < n;) {\n      int j = 0;\n      while (i + j < n && S[vs[i + j]] == S[vs[i]]) j++;\n      bool tmp = (i + j < n && S[vs[i]] < S[vs[i + j]]);\n      for (int k = 0; k < j; k++) flag[vs[i + k]] = tmp;\n      i += j;\n    }\n    dfs(0, k);\n    cout << ans << '\\n';\n  }\n};\nint main() {\n  int N, K;\n  cin >> N >> K >> S;\n  Graph<true> G(N);\n  for (int i = 0; i < N; i++) {\n    int l, r;\n    cin >> l >> r;\n    l--, r--;\n    if (l >= 0) G.l[i] = l;\n    if (r >= 0) G.r[i] = r;\n  }\n  G.solve(K);\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nvector<int> o;\nvector<pair<int, int>> v;\nvoid dfs(int u) {\n  if (v[u].first != 0) dfs(v[u].first);\n  o.push_back(u);\n  if (v[u].second != 0) dfs(v[u].second);\n}\nbool dup[100008];\nbool rdup[100008];\nint k;\nbool dfs2(int u, int d) {\n  bool l, r, ret = 0;\n  if (v[u].first != 0) l = dfs2(v[u].first, d + 1);\n  if (l == 1) {\n    rdup[u] = 1;\n    if (v[u].second != 0) r = dfs2(v[u].second, 1);\n    ret = 1;\n  } else {\n    if (dup[u] == 1 && d <= k) {\n      k -= d;\n      rdup[u] = 1;\n      ret = 1;\n      if (v[u].second != 0) r = dfs2(v[u].second, 1);\n    }\n  }\n  return ret;\n}\nint main() {\n  int n;\n  cin >> n >> k;\n  string second;\n  cin >> second;\n  int l, r;\n  v.push_back({0, 0});\n  for (int i = 0; i < n; i++) {\n    cin >> l >> r;\n    v.push_back({l, r});\n  }\n  dfs(1);\n  for (int i = n - 2; i >= 0; i--) {\n    if (second[o[i] - 1] < second[o[i + 1] - 1]) {\n      dup[o[i]] = 1;\n    } else if (second[o[i] - 1] == second[o[i + 1] - 1] && dup[o[i + 1]] == 1) {\n      dup[o[i]] = 1;\n    }\n  }\n  dfs2(1, 1);\n  for (int i = 0; i < n; i++) {\n    cout << second[o[i] - 1];\n    if (rdup[o[i]] == 1) {\n      cout << second[o[i] - 1];\n    }\n  }\n  cout << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nlong long MAXN = 2e5 + 10;\nvoid f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return;\n  f(g[cur].first, g, s);\n  pos.push_back(cur);\n  f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(MAXN));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 29; i >= 0; i--) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(MAXN);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = "";\n  for (auto &a : pos) initial += s[a];\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  long long operations = 0;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      while (cur and taken[cur] == 0) {\n        assert(operations++ < 1e6);\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize("O3,unroll-loops")\n#pragma target optimize("avx2,bmi,bmi2,lzcnt,popcnt")\ntemplate <class T>\nbool chmin(T &a, T b) {\n  return b < a and (a = b, true);\n}\ntemplate <class T>\nbool chmax(T &a, T b) {\n  return b > a and (a = b, true);\n}\nconst int maxn = 2e5 + 5;\nvector<int> vec;\nvector<int> stk;\nint ch[maxn][2];\nbool add[maxn];\nbool dub[maxn];\nint n, m;\nvoid dfs(int u) {\n  if (!u) return;\n  dfs(ch[u][0]);\n  vec.emplace_back(u);\n  ((void)0);\n  dfs(ch[u][1]);\n}\nvoid dfs2(int u) {\n  if (!u) return;\n  stk.emplace_back(u);\n  dfs2(ch[u][0]);\n  if (m >= stk.size() and add[u] and !dub[u]) {\n    for (int v : stk) dub[v] = 1;\n    m -= stk.size();\n    stk.clear();\n  }\n  if (add[u]) dfs2(ch[u][1]);\n  if (!stk.empty() and stk.back() == u) stk.pop_back();\n}\nvoid solve() {\n  string str, tmp;\n  cin >> n >> m;\n  cin >> str;\n  str = "@" + str;\n  for (int i = 1; i <= n; i++) cin >> ch[i][0] >> ch[i][1];\n  dfs(1);\n  for (int i = n - 2; ~i; i--)\n    add[vec[i]] = (str[vec[i]] < str[vec[i + 1]]) or\n                  (str[vec[i]] == str[vec[i + 1]] and add[vec[i + 1]]);\n  dfs2(1);\n  ((void)0);\n  ((void)0);\n  ((void)0);\n  string ans;\n  for (int v : vec) {\n    ans.push_back(str[v]);\n    if (dub[v]) ans.push_back(str[v]);\n  }\n  cout << ans << \'\\n\';\n}\nsigned main() {\n  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n  int T = 1;\n  while (T--) solve();\n  return 0;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  vector<pair<long long, long long>> parent(n);\n  parent[0] = make_pair(-1, -1);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  char last = char(1);\n  for (int i = n - 1; i >= 0; i--) {\n    suffix[i] = last;\n    if (initial[i] != last) last = initial[i];\n  }\n  cerr << initial << endl;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] == initial[i]) {\n      continue;\n    }\n    long long sum = 0;\n    bool ok = 1;\n    long long cur = pos[i];\n    cerr << "testing " << i << " " << initial[i] << endl;\n    while (cur != -1) {\n      if (taken[cur]) break;\n      sum++;\n      cerr << cur << " " << parent[cur].first << " " << parent[cur].second\n           << endl;\n      if (cur == 0 || taken[parent[cur].first]) break;\n      if (parent[cur].second) {\n        ok = 0;\n        break;\n      }\n      cur = parent[cur].first;\n    }\n    if (ok and k >= sum) {\n      cerr << initial[i] << " was ok with sum of " << sum << " and k is " << k\n           << endl;\n      long long cur = pos[i];\n      while (cur != -1) {\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      k -= sum;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', 'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class e {\n\tstatic final int LOG=30;\n\tstatic final int INF=Integer.MAX_VALUE/2-5;\n\tpublic static void main(String[] args) {\n\t\tFastScanner scan=new FastScanner();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\n\t\tint n=scan.nextInt();\n\t\tk=scan.nextInt();\n\t\tc=scan.next().toCharArray();\n\n\t\ta=new int[n][2];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i][0]=scan.nextInt()-1;\n\t\t\ta[i][1]=scan.nextInt()-1;\n\t\t}\n\t\tinorder=new ArrayList<>();\n\t\tdepth=new int[n];\n\t\tparent=new int[n];\n\t\tid=new int[n];\n\t\tinit(0,0,-1);\n\n\t\tint[] last=new int[26];\n\t\tArrays.fill(last,-1);\n\t\tlast[(int)(c[inorder.get(n-1)]-\'a\')]=n-1;\n\t\tgood=new boolean[n];\n\n\t\tfor(int i=n-2;i>=0;i--) {\n\t\t\tint p=inorder.get(i), q=inorder.get(i+1);\n\t\t\tint nxtdif=Integer.MAX_VALUE;\n\t\t\tchar nxtchar=\' \';\n\t\t\tfor(int j=0;j<26;j++) {\n\t\t\t\tif(j!=(int)(c[q]-\'a\')&&last[j]!=-1) {\n\t\t\t\t\tif(nxtdif>last[j]) {\n\t\t\t\t\t\tnxtdif=last[j];\n\t\t\t\t\t\tnxtchar=(char)(j+\'a\');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c[p]<c[q]) {\n\t\t\t\t//expanding here\n\t\t\t\tgood[p]=true;\n\t\t\t}\n\t\t\telse if(c[p]==c[q]&&nxtdif!=Integer.MAX_VALUE&&nxtchar>c[p]) {\n\t\t\t\t//expanding here\n\t\t\t\tgood[p]=true;\n\t\t\t}\n\t\t\tlast[(int)(c[inorder.get(i)]-\'a\')]=i;\n\t\t}\n\t\texpand=new boolean[n];\n\t\tdfs(0,depth);\n\t\t\n\t\tStringBuilder res=new StringBuilder();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint cur=inorder.get(i);\n\t\t\tres.append(c[cur]);\n\t\t\tif(expand[cur]) {\n\t\t\t\tres.append(c[cur]);\n\t\t\t}\n\t\t}\n\t\tout.println(res);\n\t\tout.close();\n\t}\n\tpublic static boolean dfs(int at, int[] cost) {\n\t\tboolean exploreRight=false;\n\t\tint l=a[at][0], r=a[at][1];\n\t\t\n\t\tif(good[at]&&cost[at]<=k) {\n\t\t\texpand[at]=true;\n\t\t\tk-=cost[at];\n\t\t\texploreRight=true;\n\t\t}\n\t\tif(l!=-1) cost[l]=1;\n\t\tif(r!=-1) cost[r]=1;\n\t\t\n\t\tif(l!=-1) {\n\t\t\tif(dfs(a[at][0],cost)) {\n\t\t\t\tk-=cost[l];\n\t\t\t\texploreRight=true;\n\t\t\t\texpand[at]=true;\n\t\t\t}\n\t\t}\n\t\tif(exploreRight&&r!=-1) {\n\t\t\tdfs(r,cost);\n\t\t}\n\t\treturn expand[at];\n\t}\n\tpublic static void init(int at, int d, int p) {\n\t\tdepth[at]=d;\n\t\tparent[at]=p;\n\t\tif(a[at][0]!=-1) init(a[at][0],d+1,at);\n\t\tinorder.add(at);\n\t\tid[at]=inorder.size()-1;\n\t\tif(a[at][1]!=-1) init(a[at][1],d+1,at);\n\t}\n\tstatic int k;\n\tstatic boolean[] expand,good;\n\tstatic ArrayList<Integer> inorder;\n\tstatic int[][] a;\n\tstatic int[] id;\n\tstatic int[] depth,parent;\n\tstatic char[] c;\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\ttry\t{\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e){e.printStackTrace();}\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (st.hasMoreTokens())\treturn st.nextToken();\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (Exception e) {e.printStackTrace();}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() {return Long.parseLong(next());}\n\n\t\tpublic double nextDouble() {return Double.parseDouble(next());}\n\n\t\tpublic String nextLine() {\n\t\t\tString line = "";\n\t\t\tif(st.hasMoreTokens()) line = st.nextToken();\n\t\t\telse try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n\t\t\twhile(st.hasMoreTokens()) line += " "+st.nextToken();\n\t\t\treturn line;\n\t\t}\n\t}\n}', '#include <bits/stdc++.h>\n#pragma GCC optimize("O3")\nusing namespace std;\nconst long long mod = 998244353;\nint n, k, cnt;\nvector<pair<int, int>> ch;\nvector<int> f, good;\nstring s;\nstring dfs1(int u) {\n  string ret;\n  if (ch[u].first != -1) ret += dfs1(ch[u].first);\n  f[cnt++] = u;\n  ret += s[u];\n  if (ch[u].second != -1) ret += dfs1(ch[u].second);\n  return ret;\n}\npair<string, int> dfs(int u, int k) {\n  pair<string, int> ret;\n  ret.second = 0;\n  bool added = 0;\n  if (ch[u].first != -1) {\n    auto l = dfs(ch[u].first, k - 1);\n    ret.first = l.first;\n    if (l.second)\n      ret.second = l.second, added = 1;\n    else\n      ret.second = 0;\n  }\n  if (k > 0) {\n    if (good[u] || ret.second) {\n      ret.first += s[u];\n      added = 1;\n    } else\n      ret.first += s[u];\n  } else\n    ret.first += s[u];\n  if (ch[u].second != -1) {\n    auto r = dfs(ch[u].second, k - ret.second - 1);\n    if (added) ret.second++, ret.first += s[u];\n    if (added) {\n      ret.second += r.second;\n      ret.first += r.first;\n    } else {\n      ret.first += dfs1(ch[u].second);\n    }\n  } else {\n    if (added) ret.second++, ret.first += s[u];\n  }\n  return ret;\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, k;\n  cin >> n >> k;\n  ch.resize(n);\n  f.resize(n);\n  good.resize(n);\n  cin >> s;\n  for (int i = 0; i < n; i++) {\n    cin >> ch[i].first >> ch[i].second;\n    ch[i].first--;\n    ch[i].second--;\n  }\n  dfs1(0);\n  for (int i = n - 2; i >= 0; i--) {\n    if (s[f[i]] == s[f[i + 1]])\n      good[f[i]] = good[f[i + 1]];\n    else if (s[f[i]] < s[f[i + 1]])\n      good[f[i]] = 1;\n    else\n      good[f[i]] = 0;\n  }\n  cout << dfs(0, k).first;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nint SIZE(T(&t)) {\n  return t.size();\n}\ntemplate <typename T, size_t N>\nint SIZE(T (&t)[N]) {\n  return N;\n}\nstring to_string(char t) { return "\'" + string({t}) + "\'"; }\nstring to_string(bool t) { return t ? "true" : "false"; }\nstring to_string(const string& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)), _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += t[i];\n  }\n  return \'"\' + ret + \'"\';\n}\nstring to_string(const char* t) {\n  string ret(t);\n  return to_string(ret);\n}\ntemplate <size_t N>\nstring to_string(const bitset<N>& t, int x1 = 0, int x2 = 1e9) {\n  string ret = "";\n  for (int i = min(x1, SIZE(t)); i <= min(x2, SIZE(t) - 1); ++i) {\n    ret += t[i] + \'0\';\n  }\n  return to_string(ret);\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1 = 0, int x2 = 1e9, Coords... C);\ntemplate <typename T, typename S>\nstring to_string(const pair<T, S>& t) {\n  return "(" + to_string(t.first) + ", " + to_string(t.second) + ")";\n}\ntemplate <typename T, typename... Coords>\nstring to_string(const T(&t), int x1, int x2, Coords... C) {\n  string ret = "[";\n  x1 = min(x1, SIZE(t));\n  auto e = begin(t);\n  advance(e, x1);\n  for (int i = x1, _i = min(x2, SIZE(t) - 1); i <= _i; ++i) {\n    ret += to_string(*e, C...) + (i != _i ? ", " : "");\n    e = next(e);\n  }\n  return ret + "]";\n}\ntemplate <int Index, typename... Ts>\nstruct print_tuple {\n  string operator()(const tuple<Ts...>& t) {\n    string ret = print_tuple<Index - 1, Ts...>{}(t);\n    ret += (Index ? ", " : "");\n    return ret + to_string(get<Index>(t));\n  }\n};\ntemplate <typename... Ts>\nstruct print_tuple<0, Ts...> {\n  string operator()(const tuple<Ts...>& t) { return to_string(get<0>(t)); }\n};\ntemplate <typename... Ts>\nstring to_string(const tuple<Ts...>& t) {\n  const auto Size = tuple_size<tuple<Ts...>>::value;\n  return print_tuple<Size - 1, Ts...>{}(t);\n}\nvoid dbgr() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgr(Heads H, Tails... T) {\n  cout << to_string(H) << " | ";\n  dbgr(T...);\n}\nvoid dbgs() { ; }\ntemplate <typename Heads, typename... Tails>\nvoid dbgs(Heads H, Tails... T) {\n  cout << H << " ";\n  dbgs(T...);\n}\nconst int N = 2e5 + 5;\nconst long long INF = 1e18 + 7;\nconst int MAXA = 1e9;\nconst int B = sqrt(N) + 5;\nint l[N], r[N], pv[N];\nbool dou[N], ok[N];\nstring s;\ndeque<char> ans[N];\ndeque<int> pos[N];\nint n, k;\nvoid dfs(int u) {\n  if (u == 0) return;\n  dfs(l[u]);\n  dfs(r[u]);\n  if (ans[l[u]].size() > ans[r[u]].size()) {\n    swap(ans[u], ans[l[u]]);\n    swap(pos[u], pos[l[u]]);\n    ans[u].push_back(s[u]);\n    pos[u].push_back(u);\n    for (char i : ans[r[u]]) {\n      ans[u].push_back(i);\n    }\n    for (int i : pos[r[u]]) {\n      pos[u].push_back(i);\n    }\n  } else {\n    swap(ans[u], ans[r[u]]);\n    swap(pos[u], pos[r[u]]);\n    ans[u].push_front(s[u]);\n    pos[u].push_front(u);\n    reverse(ans[l[u]].begin(), ans[l[u]].end());\n    reverse(pos[l[u]].begin(), pos[l[u]].end());\n    for (char i : ans[l[u]]) {\n      ans[u].push_front(i);\n    }\n    for (int i : pos[l[u]]) {\n      pos[u].push_front(i);\n    }\n  }\n}\nbool dfs_opt(int u, int h) {\n  bool f = false;\n  if (ok[pv[u]] && k >= h) {\n    k -= h;\n    dou[u] = true;\n    if (l[u]) dfs_opt(l[u], 1);\n    if (r[u]) dfs_opt(r[u], 1);\n    return true;\n  } else {\n    if (l[u]) f |= dfs_opt(l[u], h + 1);\n    if (f) dou[u] = true;\n    if (dou[u] && r[u]) dfs_opt(r[u], h + 1);\n    return dou[u];\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  cin >> s;\n  s = " " + s;\n  for (int i = 1; i <= n; ++i) {\n    cin >> l[i] >> r[i];\n  }\n  dfs(1);\n  s = " ";\n  for (char i : ans[1]) s += i;\n  for (int i = 0; i < n; ++i) pv[pos[1][i]] = i + 1;\n  int l = 1;\n  for (int i = 1; i < n; ++i) {\n    if (s[i] != s[i + 1]) {\n      if (s[i] < s[i + 1]) {\n        for (int j = l; j <= i; ++j) ok[j] = true;\n      }\n      l = i + 1;\n    }\n  }\n  dfs_opt(1, 1);\n  for (int i = 1; i <= n; ++i) {\n    cout << s[i];\n    if (dou[pos[1][i - 1]]) cout << s[i];\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int t = 1;\n  while (t--) {\n    solve();\n  }\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  vector<pair<long long, long long>> parent(n);\n  parent[0] = make_pair(-1, -1);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  for (int i = n - 1; i >= 0; i--) {\n    suffix[i] = max(suffix[i + 1], (long long)initial[i]);\n  }\n  cerr << initial << endl;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1] ||\n        (initial[i] == initial[i + 1] and suffix[i] == initial[i]))\n      continue;\n    long long sum = 0;\n    bool ok = 1;\n    long long cur = pos[i];\n    cerr << "testing " << i << " " << initial[i] << endl;\n    while (cur != -1) {\n      sum++;\n      cerr << cur << " " << parent[cur].first << " " << parent[cur].second\n           << endl;\n      if (cur == 0 || taken[parent[cur].first]) break;\n      if (parent[cur].second) {\n        ok = 0;\n        break;\n      }\n      cur = parent[cur].first;\n    }\n    if (ok and k >= sum) {\n      cerr << initial[i] << " was ok with sum of " << sum << " and k is " << k\n           << endl;\n      long long cur = pos[i];\n      while (cur != -1) {\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      k -= sum;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nlong long MAXN = 2e5 + 10;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(MAXN));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 29; i >= 0; i--) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(MAXN);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = f(0, g, s);\n  if (s[0] == \'z\') cout << "hello" << endl;\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  long long operations = 0;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      while (cur and taken[cur] == 0) {\n        assert(operations++ < 1e6);\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '// Problem: E. Middle Duplication\n// Contest: Codeforces - Codeforces Round #763 (Div. 2)\n// URL: https://codeforces.com/contest/1623/problem/E\n// Memory Limit: 256 MB\n// Time Limit: 1000 ms\n// Author: abhidot\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n#define ll long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);\n#define pb push_back\n#define mod 1000000007\n#define mod2 998244353\n#define lld long double\n#define pii pair<int, int>\n#define ff first\n#define ss second\n#define all(x) (x).begin(), (x).end()\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define rep(i,x,y) for(int i=x; i<y; i++)\n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define V vector\n#define setbits(x) __builtin_popcountll(x)\n#define w(x)  int x; cin>>x; while(x--)\nusing namespace std;\nusing namespace __gnu_pbds; \ntemplate <typename num_t> using ordered_set = tree<num_t, null_type, less<num_t>, rb_tree_tag, tree_order_statistics_node_update>;\nconst long long N=200005, INF=2000000000000000000, inf = 2e9+5;\n\nint power(int a, int b, int p){\n\tif(a==0)\n\treturn 0;\n\tint res=1;\n\ta%=p;\n\twhile(b>0)\n\t{\n\t\tif(b&1)\n\t\tres=(res*a)%p;\n\t\tb>>=1;\n\t\ta=(a*a)%p;\n\t}\n\treturn res;\n}\n\n\nvoid print(bool n){\n    if(n){\n        cout<<"YES\\n";\n    }else{\n        cout<<"NO\\n";\n    }\n}\n\nint n, k;\nstring s;\n\nint btree[N][2];\nint p[N][20];\nvector<vector<int>> g;\nint tin[N], tout[N];\n\nvector<int> inorder;\nint tim=0;\n\n\nvoid traversal(int u){\n\tif(u==0) return;\n\ttin[u] = ++tim;\n\ttraversal(btree[u][0]);\n\tinorder.push_back(u);\n\ttraversal(btree[u][1]);\n\ttout[u] = ++tim;\n}\n\nint32_t main()\n{\n    IOS;\n    cin>>n>>k>>s;\n    s = "$"+s;\n    vector<int> col(n+1, 0);\n    col[0]=1;\n    for(int i=1;i<=n;i++){\n    \tcin>>btree[i][0]>>btree[i][1];\n    \tif(btree[i][0]) p[btree[i][0]][0]=i;\n    \tif(btree[i][1]) p[btree[i][1]][0]=i;\n    }\n    \n    traversal(1);\n    \n    // Binary Lifting\n    for(int j=1;j<20;j++){\n    \tfor(int i=1;i<=n;i++){\n    \t\tp[i][j] = p[p[i][j-1]][j-1];\n    \t}\n    }\n    \n    int left=k;\n    int i;\n    \n    auto calc = [&](int on){\n    \tif(col[on]) return 0LL;\n    \tint ans=1;\n    \t// cout<<on<<": ";\n    \tfor(int j=19;j>=0;j--){\n    \t\tif(col[p[on][j]]==0){\n    \t\t\ton = p[on][j];\n    \t\t\t// cout<<on<<" ";\n    \t\t\tans+=(1<<j);\n    \t\t}\n    \t}\n    \t// cout<<": "<<ans<<"\\n";\n    \t// cout<<"\\n";\n    \t\n    \treturn ans;\n    };\n    \n    // for(auto i:inorder) cout<<i<<" ";\n    // cout<<"\\n";\n    \n    int upto=0;\n    for(i=0;inorder[i]!=1;i++){\n    \tif(s[inorder[i]]>s[inorder[i+1]]||tin[inorder[i+1]]<upto){\n    \t\t// cout<<s[inorder[i]]<<" "<<s[inorder[i+1]]<<"\\n";\n    \t\tupto = max(upto, tout[inorder[i]]);\n    \t\tcontinue;\n    \t}\n    \tint req = calc(inorder[i]);\n    \t// cout<<inorder[i]<<" "<<req<<" "<<left<<"\\n";\n    \tif(req>left) continue;\n    \tleft-=req;\n    \tint on=inorder[i];\n    \twhile(on&&col[on]==0){\n    \t\t// cout<<on<<" ";\n    \t\tcol[on]=1;\n    \t\ton = p[on][0];\n    \t}\n    \t// cout<<"\\n";\n    }\n    \n\tif(i<n-1&&s[inorder[i]]<=s[inorder[i+1]]){\n\t\tint req = calc(inorder[i]);\n    \t// cout<<inorder[i]<<" "<<req<<" "<<left<<"\\n";\n    \tif(req<=left){\n\t    \tleft-=req;\n\t    \tint on=inorder[i];\n\t    \twhile(col[on]==0){\n\t    \t\tcol[on]=1;\n\t    \t\ton = p[on][0];\n\t    \t}\n    \t}\t\n\t}\n    \n    if(col[1]==1){\n    \ti++;\n    \tfor(;i<n-1;i++){\n    \t\tif(s[inorder[i]]>s[inorder[i+1]]||tin[inorder[i+1]]<upto){\n    \t\t\tupto = max(upto, tout[inorder[i]]);\n    \t\t}\n\t    \tint req = calc(inorder[i]);\n\t    \tif(req>left) continue;\n\t    \tleft-=req;\n\t    \tint on=inorder[i];\n\t    \twhile(col[on]==0){\n\t    \t\tcol[on]=1;\n\t    \t\ton = p[on][0];\n\t    \t}\n    \t}\n    }\n    \n    for(int i=0;i<n;i++){\n    \tcout<<s[inorder[i]];\n    \tif(col[inorder[i]]) cout<<s[inorder[i]];\n    }\n}', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(1e6));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 0; i < int(30); ++i) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(1e6);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      long long operations = 0;\n      while (cur) {\n        assert(++operations < 1e7);\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nconst int MAXN = 200005;\nlong long qpow(long long d, long long z) {\n  long long res = 1;\n  for (; z; z >>= 1) {\n    if (z & 1) res = res * d % MOD;\n    d = d * d % MOD;\n  }\n  return res;\n}\nint n, k;\nchar str[MAXN];\nint ch[MAXN][2], fa[MAXN];\nint p[MAXN], rk[MAXN], cur = 0;\nint dep[MAXN];\nvoid inord(int x) {\n  if (x == 0) return;\n  dep[x] = dep[fa[x]] + 1;\n  inord(ch[x][0]);\n  p[++cur] = x;\n  rk[x] = cur;\n  inord(ch[x][1]);\n}\nint diff[MAXN];\nbool rep[MAXN];\nint curdep;\nvoid solve(int x, int fas) {\n  if (x == 0) return;\n  solve(ch[x][0], fas);\n  int remcd = curdep;\n  if (fas == 0) {\n    int i = rk[x];\n    int z = diff[i];\n    if (str[x] < str[p[z]] && dep[x] - curdep <= k) {\n      int rc = dep[x] - curdep, xd = x;\n      for (int i = 1; i <= rc; i++) {\n        rep[xd] = 1;\n        xd = fa[xd];\n      }\n      k -= rc;\n      curdep = dep[x];\n    } else {\n      if (!rep[x]) fas++;\n    }\n  }\n  solve(ch[x][1], fas);\n  curdep = remcd;\n}\nint main() {\n  scanf("%d%d", &n, &k);\n  scanf("%s", str + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", &ch[i][0], &ch[i][1]);\n    fa[ch[i][0]] = fa[ch[i][1]] = i;\n  }\n  fa[0] = 0;\n  dep[1] = 1;\n  str[n + 1] = 0;\n  inord(1);\n  for (int i = n; i >= 1; i--) {\n    if (str[p[i]] != str[p[i + 1]])\n      diff[i] = i + 1;\n    else\n      diff[i] = diff[i + 1];\n  }\n  curdep = 0;\n  solve(1, 0);\n  for (int i = 1; i <= n; i++) {\n    printf("%c", str[p[i]]);\n    if (rep[p[i]]) printf("%c", str[p[i]]);\n  }\n  printf("\\n");\n  return 0;\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(1e6));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 0; i < int(30); ++i) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(1e6);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      long long operations = 0;\n      while (cur) {\n        if (n == 200000 and initial[i] == \'m\') cout << jump[28][cur] << \'.\';\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '// package c1623;\n\nimport java.io.File;\nimport java.lang.invoke.MethodHandles;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n//\n// Codeforces Round #763 (Div. 2) 2021-12-28 05:35\n// E. Middle Duplication\n// https://codeforces.com/contest/1623/problem/E\n// time limit per test 1 second; memory limit per test 256 megabytes\n// public class Pseudo for \'Source should satisfy regex [^{}]*public\\s+(final)?\\s*class\\s+(\\w+).*\'\n//\n// A binary tree of n nodes is given. Nodes of the tree are numbered from 1 to n and the root is the\n// node 1. Each node can have no child, only one left child, only one right child, or both children.\n// For convenience, let\'s denote l_u and r_u as the left and the right child of the node u\n// respectively, l_u = 0 if u does not have the left child, and r_u = 0 if the node u does not have\n// the right child.\n//\n// Each node has a string label, initially is a single character c_u. Let\'s define the string\n// representation of the binary tree as the concatenation of the labels of the nodes in the .\n// Formally, let f(u) be the string representation of the tree rooted at the node u. f(u) is defined\n// as follows: <div class="MathJax_Display" style="text-align: center;"></div> f(u) = \\begin{cases}\n// \\texttt{<empty string>}, & \\text{if }u = 0; \\\\ f(l_u) + c_u + f(r_u) & \\text{otherwise},\n// \\end{cases} where + denotes the string concatenation operation.\n//\n// This way, the string representation of the tree is f(1).\n//\n// For each node, we can its label , that is, assign c_u with c_u + c_u, but only if u is the root\n// of the tree, or if its parent also has its label duplicated.\n//\n// You are given the tree and an integer k. What is the lexicographically smallest string\n// representation of the tree, if we can duplicate labels of at most k nodes?\n//\n// A string a is lexicographically smaller than a string b if and only if one of the following\n// holds:\n//  * a is a prefix of b, but a \\ne b;\n//  * in the first position where a and b differ, the string a has a letter that appears earlier in\n//    the alphabet than the corresponding letter in b. </div><div class="input-specification"><div\n// class="section-title">Input</div>\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Input\n//\n// The first line contains two integers n and k (1 <= k <= n <= 2 * 10^5).\n//\n// The second line contains a string c of n lower-case English letters, where c_i is the initial\n// label of the node i for 1 <= i <= n. Note that the given string c is the initial string\n// representation of the tree.\n//\n// The i-th of the next n lines contains two integers l_i and r_i (0 <= l_i, r_i <= n). If the node\n// i does not have the left child, l_i = 0, and if the node i does not have the right child, r_i =\n// 0.\n//\n// It is guaranteed that the given input forms a binary tree, rooted at 1.\n//\n// Output\n//\n// Print a single line, containing the lexicographically smallest string representation of the tree\n// if at most k nodes have their labels duplicated.\n//\n// Example\n/*\ninput:\n4 3\nabab\n2 3\n0 0\n0 4\n0 0\n\noutput:\nbaaaab\n\ninput:\n8 2\nkadracyn\n2 5\n3 4\n0 0\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndaarkkcyan\n\ninput:\n8 3\nkdaracyn\n2 5\n0 3\n0 4\n0 0\n6 8\n0 7\n0 0\n0 0\n\noutput:\ndarkcyan\n*/\n// Note\n//\n// The images below present the tree for the examples. The number in each node is the node number,\n// while the subscripted letter is its label. To the right is the string representation of the tree,\n// with each letter having the same color as the corresponding node.\n//\n// Here is the tree for the first example. Here we duplicated the labels of nodes 1 and 3. We should\n// not duplicate the label of node 2 because it would give us the string "", which is\n// lexicographically greater than "".\n// https://espresso.codeforces.com/30116fa124ec3edbd4c16ac29fa8eb45c19cc171.png\n//\n// In the second example, we can duplicate the labels of nodes 1 and 2. Note that only duplicating\n// the label of the root will produce a worse result than the initial string.\n// https://espresso.codeforces.com/e66a56b1c8dee019f4f4c138ee0333caf44b312c.png\n//\n// In the third example, we should not duplicate any character at all. Even though we would want to\n// duplicate the label of the node 3, by duplicating it we must also duplicate the label of the node\n// 2, which produces a worse result.\n// https://espresso.codeforces.com/19b0d4c5514801c166e9b3f0ef4c110939711a20.png\n//\n// There is no way to produce string "" from a tree with the initial string representation "" :(.\n//\npublic class C1623E {\n  static final int MOD = (int)1e9+7;\n  static final Random RAND = new Random();\n\n  static String solve(String s, int k, int[][] lr) {\n    // Note that both s and lr have length n + 1\n    int n = s.length() - 1;\n\n    // [parent, depth, subtree size, dfs-done, duplicate, in-order index]\n    //  0       1      2             3         4          5\n    int[][] nodes = dfsNodes(lr);\n\n    bfsInOrder(lr, nodes);\n\n    int[] ids = new int[n];\n    for (int i = 1; i <= n; i++) {\n      ids[nodes[i][5]] = i;\n    }\n\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    // System.out.format("%s\\n", Utils.trace(ids));\n\n    // Note that ids[] is 0-indexed!\n    int b = 0;\n    int avail = k;\n    while (b < n) {\n      int v = ids[b];\n      // System.out.format("  b:%d v:%d depth:%d k:%d\\n", b, v, nodes[v][1], k);\n      if (nodes[v][1] > k) {\n        // don\'t bother if v is too deep\n        b++;\n        continue;\n      }\n      char c = s.charAt(v);\n      int e = b + 1;\n      while (e < n && s.charAt(ids[e]) == c) {\n        e++;\n      }\n      boolean duplicate = e < n && s.charAt(ids[e]) > c;\n      // System.out.format("  b:%d v:%d e:%d dup:%b\\n", b, v, e, duplicate);\n      if (!duplicate) {\n        b = e;\n        continue;\n      }\n\n      // We may duplicate some nodes between [b,e) as long as there is budget\n      for (int i = b; i < e; i++) {\n        int id = ids[i];\n        if (nodes[id][4] == 1) {\n          // skip ones already decided to duplicate earlier (part chain).\n          continue;\n        }\n\n        // Can we afford duplicate i?\n        // walk up parent chain until a duplicated node or root\n        int needed = 0;\n        // w is the node id\n        int w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          needed++;\n          int p = nodes[w][0];\n          if (p != 0 && nodes[p][4] == 0 && nodes[p][5] < nodes[w][5]) {\n            // do not trigger duplicate of an ancestor in front as it will make things worse\n            needed = Integer.MAX_VALUE;\n            break;\n          }\n          // if (p != 0 && nodes[p][4])\n          w = nodes[w][0];\n        }\n        // System.out.format("    i:%d id:%d needed:%d avail:%d\\n", i, id, needed, avail);\n        if (needed > avail) {\n          continue;\n        }\n\n        // Set duplicate flag up the chain until an ancestor already set or the parent of root.\n        w = ids[i];\n        while (w != 0 && nodes[w][4] == 0) {\n          nodes[w][4] = 1;\n          avail--;\n          w = nodes[w][0];\n        }\n        myAssert(avail >= 0);\n      }\n      b = e;\n    }\n    // System.out.format("%s\\n", Utils.trace(ids));\n    // System.out.format("%s\\n", Utils.trace(nodes, true));\n    StringBuilder sb = new StringBuilder();\n    for (int v : ids) {\n      sb.append(s.charAt(v));\n      if (nodes[v][4] == 1) {\n        sb.append(s.charAt(v));\n      }\n    }\n    return sb.toString();\n  }\n\n  // [parent, depth, subtree size, done]\n  static int[][] dfsNodes(int[][] lr) {\n    int n = lr.length - 1;\n    int[][] nodes = new int[n + 1][6];\n    Stack<Integer> stack = new Stack<>();\n    stack.push(1);\n    nodes[1][1] = 1;\n    while (!stack.isEmpty()) {\n      int v = stack.peek();\n      // System.out.format("  v:%d %s\\n", v, Arrays.toString(nodes[v]));\n      int l = lr[v][0];\n      int r = lr[v][1];\n      if (l == 0 && r == 0) {\n        nodes[v][2] = 1;\n        nodes[v][3] = 1;\n        stack.pop();\n      } else if (l > 0 && r == 0) {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        } else {\n          nodes[v][2] = 1 + nodes[l][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else if (l == 0 && r > 0) {\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        } else {\n          nodes[v][2] = 1 + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      } else {\n        nodes[l][0] = v;\n        nodes[l][1] = nodes[v][1] + 1;\n        nodes[r][0] = v;\n        nodes[r][1] = nodes[v][1] + 1;\n        if (nodes[l][3] == 0) {\n          stack.push(l);\n        }\n        if (nodes[r][3] == 0) {\n          stack.push(r);\n        }\n        if (nodes[l][3] == 1 && nodes[r][3] == 1) {\n          nodes[v][2] = 1 + nodes[l][2] + nodes[r][2];\n          nodes[v][3] = 1;\n          stack.pop();\n        }\n      }\n    }\n    return nodes;\n  }\n\n  // Fill nodes[i][5] which is the 0-based index of in-order traverse of the node.\n  // Note that both lr and nodes are 1-based\n  static void bfsInOrder(int[][] lr, int[][] nodes) {\n    int n = lr.length - 1;\n    Queue<int[]> q = new LinkedList<>();\n    q.add(new int[] {1, 0});\n    while (!q.isEmpty()) {\n      int[] e = q.poll();\n      int v = e[0];\n      int offset = e[1];\n      int l = lr[v][0];\n      int r = lr[v][1];\n      int idx = offset;\n      if (l > 0) {\n        q.add(new int[] {l, idx});\n        idx += nodes[l][2];\n      }\n      nodes[v][5] = idx;\n      if (r > 0) {\n        q.add(new int[] {r, idx});\n      }\n    }\n  }\n\n  static String trace(int[] a) {\n    StringBuilder sb = new StringBuilder();\n    for (int v : a) {\n     if (sb.length() > 0) {\n       sb.append(\' \');\n     }\n      sb.append(v);\n    }\n    return sb.toString();\n  }\n\n  static void myAssert(boolean cond) {\n    if (!cond) {\n      throw new RuntimeException("Unexpected");\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner in = getInputScanner();\n    int n = in.nextInt();\n    int k = in.nextInt();\n    String s = \' \' + in.next();\n    int[][] lr = new int[n + 1][2];\n    for (int i = 1; i <= n; i++) {\n      lr[i][0] = in.nextInt();\n      lr[i][1] = in.nextInt();\n    }\n    String ans = solve(s, k, lr);\n    System.out.println(ans);\n    in.close();\n  }\n\n  static Scanner getInputScanner() {\n    try {\n      final String USERDIR = System.getProperty("user.dir");\n      final String CNAME = MethodHandles.lookup().lookupClass().getSimpleName();\n      final File fin = new File(USERDIR + "/io/c" + CNAME.substring(1,5) + "/" + CNAME + ".in");\n      return fin.exists() ? new Scanner(fin) : new Scanner(System.in);\n    } catch (Exception e) {\n      return new Scanner(System.in);\n    }\n  }\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nvector<vector<long long>> jump(30, vector<long long>(1e6));\nlong long nearest_taken(vector<bool> &taken, long long cur) {\n  long long sum = 0;\n  for (int i = 0; i < int(30); ++i) {\n    if (!taken[jump[i][cur]]) {\n      sum += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return sum + 1;\n}\nlong long dist_to_root(long long cur, long long root) {\n  long long ans = 0;\n  if (cur == root) return 1;\n  for (int i = 0; i < int(30); ++i) {\n    if (jump[i][cur] != root) {\n      ans += 1ll << i;\n      cur = jump[i][cur];\n    }\n  }\n  return ans + 2;\n}\nvector<pair<long long, long long>> parent(1e6);\nlong long dist(vector<bool> &taken, long long cur) {\n  if (taken[cur]) return 0;\n  if (jump[29][cur] != 0) {\n    if (taken[parent[jump[29][cur]].first])\n      return dist_to_root(cur, jump[29][cur]);\n    return inf;\n  }\n  return min(nearest_taken(taken, cur), dist_to_root(cur, 0));\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  parent[0] = make_pair(0, 0);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  for (int i = 0; i < int(n); ++i)\n    jump[0][i] = parent[i].second ? i : parent[i].first;\n  for (int i = 1; i < int(30); ++i)\n    for (int j = 0; j < int(n); ++j) jump[i][j] = jump[i - 1][jump[i - 1][j]];\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  suffix[n - 1] = 0;\n  for (int i = n - 2; i >= 0; i--) {\n    if (initial[i] == initial[i + 1])\n      suffix[i] = suffix[i + 1];\n    else\n      suffix[i] = initial[i + 1];\n  }\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] <= initial[i]) {\n      continue;\n    }\n    long long cur = pos[i];\n    if (taken[cur]) continue;\n    if (dist(taken, cur) <= k) {\n      k -= dist(taken, cur);\n      long long operations = 0;\n      while (cur) {\n        if (n == 200000 and initial[i] == \'m\') cout << cur << \'.\';\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      taken[0] = 1;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', 'import java.io.*;\nimport java.util.*;\n\npublic class e {\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int k = Integer.parseInt(tokenizer.nextToken());\n        String lab = in.readLine();\n        node[] list = new node[n];\n        for (int i = 0; i < n; i++) {\n            list[i] = new node(i, lab.substring(i, i + 1));\n        }\n        for (int i = 0; i < n; i++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            int left = Integer.parseInt(tokenizer.nextToken()) - 1;\n            int right = Integer.parseInt(tokenizer.nextToken()) - 1;\n            if (left != -1) {\n                list[i].left = list[left];\n                list[left].parent = list[i];\n            }\n            if (right != -1) {\n                list[i].right = list[right];\n                list[right].parent = list[i];\n            }\n            // System.out.println(list[i].left.id + " " + list[i].right.id);\n        }\n        node[] order = new node[n];\n        inorder(order, 0, list[0]);\n        for (int i = 0; i < n; i++) {\n            System.out.print(order[i].id + " ");\n        }\n        System.out.println();\n        int rem = k;\n        ArrayList<String> vals = new ArrayList<>();\n        for (int i = order.length - 1; i >= 0; i--) {\n            if (vals.size() == 0 || !order[i].label.equals(vals.get(vals.size() - 1))) {\n                vals.add(order[i].label);\n            }\n            if (vals.size() <= 1 || vals.get(vals.size() - 1).compareTo(vals.get(vals.size() - 2)) >= 0) {\n                order[i].good = false;\n            } else {\n                order[i].good = true;\n            }\n        }\n        dfs(list[0], 1);\n        for (int i = 0; i < order.length; i++) {\n            if(order[i].cost <= rem && order[i].good){\n                rem -= order[i].cost;\n                update(order[i]);\n            }\n        }\n        StringBuilder b = new StringBuilder();\n        for(int i = 0; i < order.length; i++){\n            b.append(order[i].label);\n            if(order[i].used){\n                b.append(order[i].label);\n            }\n        }\n        System.out.println(b);\n        in.close();\n        out.close();\n    }\n\n    public static void dfs(node n, int val) {\n        if (n == null || n.used)\n            return;\n        n.cost = val;\n        dfs(n.left, val + 1);\n        dfs(n.right, val + 1);\n    }\n\n    public static void update(node n) {\n        n.used = true;\n        dfs(n, 0);\n        if(n.parent != null && !n.parent.used){\n            update(n.parent);\n        }\n    }\n\n    public static int inorder(node[] order, Integer index, node n) {\n        if (n != null) {\n            index = inorder(order, index, n.left);\n            order[index++] = n;\n            index = inorder(order, index, n.right);\n        }\n\n        return index;\n    }\n\n    public static class node {\n        int id;\n        String label;\n        node left = null;\n        node right = null;\n        node parent = null;\n        int cost = 0;\n        boolean used = false;\n        boolean good = false;\n\n        public node(int id, String label) {\n            this.id = id;\n            this.label = label;\n        }\n\n        public int cost() {\n            int val = 0;\n            node pointer = this;\n            while (pointer != null && !pointer.used) {\n                pointer = pointer.parent;\n                val++;\n            }\n            return cost = val;\n        }\n    }\n}', '#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n  int x = 0, f = 0;\n  char ch = getchar();\n  while (!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - \'0\', ch = getchar();\n  return f ? -x : x;\n}\ntemplate <class T>\nvoid print(T x) {\n  if (x < 0) putchar(\'-\'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + \'0\');\n}\ntemplate <class T>\nvoid print(T x, char let) {\n  print(x), putchar(let);\n}\ntemplate <class T1, class T2>\nvoid ckmin(T1& x, T2 y) {\n  if (x > y) x = y;\n}\ntemplate <class T1, class T2>\nvoid ckmax(T1& x, T2 y) {\n  if (x < y) x = y;\n}\nconst int N = 200005;\nconst int inf = 1e9;\nchar s[N];\nint ls[N], rs[N];\nint a[N], sq[N], p[N], ans[N], c;\nint n, k;\nvoid dfs(int u) {\n  if (!u) return;\n  dfs(ls[u]);\n  ++c, sq[c] = s[u], p[u] = c;\n  dfs(rs[u]);\n}\nvoid dfs0(int u) {\n  if (!u) return;\n  dfs0(ls[u]);\n  if (a[u])\n    printf("%c%c", s[u], s[u]);\n  else\n    printf("%c", s[u]);\n  dfs0(rs[u]);\n}\nint sol(int u, int d) {\n  if (ls[u] && sol(ls[u], d + 1)) a[u] = 1;\n  if (rs[u]) {\n    if (a[u] || (ans[p[u]] && k >= d)) {\n      if (!a[u])\n        a[u] = 1, k -= d;\n      else if (sol(rs[u], 1))\n        a[u] = 1;\n    } else {\n      if (sol(rs[u], inf)) a[u] = 1;\n    }\n  } else {\n    if (a[u] || !(ans[p[u]] && k >= d))\n      ;\n    else\n      a[u] = 1, k -= d;\n  }\n  return a[u];\n}\nint main() {\n  scanf("%d%d%s", &n, &k, s + 1);\n  for (int i = (1); i <= (n); i++) ls[i] = read(), rs[i] = read();\n  dfs(1), ans[n] = 0;\n  for (int i = (1); i <= (c); i++) sq[i] -= \'a\';\n  for (int i = (n - 1); i >= (0); i--)\n    ans[i] = sq[i] != sq[i + 1] ? (sq[i] < sq[i + 1]) : ans[i + 1];\n  sol(1, 1);\n  dfs0(1);\n  return 0;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nconst int inf = 2147483647;\nlong long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') x = x * 10ll + ch - '0', ch = getchar();\n  return x * f;\n}\nint n, k, lc[N], rc[N], a[N], id, dep[N], dfn, L[N], R[N], fa[N];\nchar d[N];\nbool v[N];\nstring str, s;\nlong long o[N];\nvoid add(int x, long long v) {\n  for (; x <= n; x += (x & (-x))) o[x] += v;\n}\nvoid Add(int l, int r, long long v) { add(l, v), add(r + 1, -v); }\nlong long query(int x) {\n  long long t = 0;\n  for (; x; x -= (x & (-x))) t += o[x];\n  return t;\n}\nvoid dfs1(int x) {\n  if (lc[x]) dep[lc[x]] = dep[x] + 1, dfs1(lc[x]);\n  s += str[x - 1];\n  a[++id] = x;\n  if (rc[x]) dep[rc[x]] = dep[x] + 1, dfs1(rc[x]);\n}\nvoid dfs2(int x) {\n  L[x] = ++dfn;\n  if (lc[x]) dfs2(lc[x]);\n  if (rc[x]) dfs2(rc[x]);\n  R[x] = dfn;\n}\nvoid dfs3(int x) {\n  if (lc[x]) dfs3(lc[x]);\n  putchar(str[x - 1]);\n  if (v[x]) putchar(str[x - 1]);\n  if (rc[x]) dfs3(rc[x]);\n}\nint main() {\n  n = read(), k = read();\n  cin >> str;\n  for (int i = 1; i <= n; i++) {\n    lc[i] = read(), rc[i] = read();\n    if (lc[i]) fa[lc[i]] = i;\n    if (rc[i]) fa[rc[i]] = i;\n  }\n  s += '#';\n  dfs1(1);\n  s += ' ';\n  d[n] = ' ';\n  for (int i = n - 1; i; i--)\n    if (s[i] == s[i + 1])\n      d[i] = d[i + 1];\n    else\n      d[i] = s[i + 1];\n  dfs2(1);\n  for (int i = 1; i <= n; i++) Add(L[i], L[i], dep[i] + 1);\n  for (int i = 1; i <= n; i++)\n    if (s[i] < d[i] && query(L[a[i]]) <= k) {\n      int t = a[i];\n      while (t && !v[t]) {\n        v[t] = true;\n        k--;\n        Add(L[t], R[t], -1);\n        t = fa[t];\n      }\n    } else if (s[i] > d[i])\n      Add(L[a[i]], R[a[i]], inf);\n  dfs3(1);\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nlong long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (ch < '0' || ch > '9') {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (ch >= '0' && ch <= '9') x = x * 10ll + ch - '0', ch = getchar();\n  return x * f;\n}\nint n, k, lc[N], rc[N], a[N], id, dep[N], dfn, L[N], R[N], fa[N];\nchar d[N];\nbool v[N];\nstring str, s;\nlong long o[N];\nvoid add(int x, long long v) {\n  for (; x <= n; x += (x & (-x))) o[x] += v;\n}\nvoid Add(int l, int r, long long v) { add(l, v), add(r + 1, -v); }\nlong long query(int x) {\n  long long t = 0;\n  for (; x; x -= (x & (-x))) t += o[x];\n  return t;\n}\nvoid dfs1(int x) {\n  if (lc[x]) dep[lc[x]] = dep[x] + 1, dfs1(lc[x]);\n  s += str[x - 1];\n  a[++id] = x;\n  if (rc[x]) dep[rc[x]] = dep[x] + 1, dfs1(rc[x]);\n}\nvoid dfs2(int x) {\n  L[x] = ++dfn;\n  if (lc[x]) dfs2(lc[x]);\n  if (rc[x]) dfs2(rc[x]);\n  R[x] = dfn;\n}\nvoid dfs3(int x) {\n  if (lc[x]) dfs3(lc[x]);\n  putchar(str[x - 1]);\n  if (v[x]) putchar(str[x - 1]);\n  if (rc[x]) dfs3(rc[x]);\n}\nint main() {\n  n = read(), k = read();\n  cin >> str;\n  for (int i = 1; i <= n; i++) {\n    lc[i] = read(), rc[i] = read();\n    if (lc[i]) fa[lc[i]] = i;\n    if (rc[i]) fa[rc[i]] = i;\n  }\n  s += '#';\n  dfs1(1);\n  s += ' ';\n  d[n] = ' ';\n  for (int i = n - 1; i; i--)\n    if (s[i] == s[i + 1])\n      d[i] = d[i + 1];\n    else\n      d[i] = s[i + 1];\n  dfs2(1);\n  for (int i = 1; i <= n; i++) Add(L[i], L[i], dep[i] + 1);\n  for (int i = 1; i <= n; i++)\n    if (s[i] < d[i] && query(L[a[i]]) <= k) {\n      int t = a[i];\n      while (t && !v[t]) {\n        v[t] = true;\n        k--;\n        Add(L[t], R[t], -1);\n        t = fa[t];\n      }\n    } else if (s[i] > d[i])\n      Add(L[a[i]], R[a[i]], n + 1);\n  dfs3(1);\n  return 0;\n}\n", '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  vector<pair<long long, long long>> parent(n);\n  parent[0] = make_pair(-1, -1);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  for (int i = n - 1; i >= 0; i--) {\n    suffix[i] = max(suffix[i + 1], (long long)initial[i]);\n  }\n  cerr << initial << endl;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1]) {\n      bool good = 0;\n      for (int j = i; j < int(initial.size() - 1); ++j) {\n        if (initial[j] != initial[j + 1]) {\n          good = initial[j] < initial[j + 1];\n          break;\n        }\n      }\n      if (!good) continue;\n    }\n    long long sum = 0;\n    bool ok = 1;\n    long long cur = pos[i];\n    cerr << "testing " << i << " " << initial[i] << endl;\n    while (cur != -1) {\n      sum++;\n      cerr << cur << " " << parent[cur].first << " " << parent[cur].second\n           << endl;\n      if (cur == 0 || taken[parent[cur].first]) break;\n      if (parent[cur].second) {\n        ok = 0;\n        break;\n      }\n      cur = parent[cur].first;\n    }\n    if (ok and k >= sum) {\n      cerr << initial[i] << " was ok with sum of " << sum << " and k is " << k\n           << endl;\n      long long cur = pos[i];\n      while (cur != -1) {\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      k -= sum;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint n, k, ls[200005], rs[200005];\nint cnt, rk[200005];\nint vis[200005];\nchar a[200005];\nint fa[200005];\nvoid dfs(int u) {\n  if (u == 0) return;\n  dfs(ls[u]);\n  rk[++cnt] = u;\n  dfs(rs[u]);\n}\nint get(int u) {\n  if (u == 0) return 0;\n  if (vis[u]) return 0;\n  return get(fa[u]) + 1;\n}\nvoid to(int u) {\n  if (u == 0) return;\n  if (vis[u] == 0) {\n    vis[u] = -1;\n    to(ls[u]);\n    to(rs[u]);\n  }\n}\nvoid print(int u) {\n  if (u == 0) return;\n  print(ls[u]);\n  printf("%c", a[u]);\n  if (vis[u] == 1) printf("%c", a[u]);\n  print(rs[u]);\n}\nint main() {\n  scanf("%d%d\\n%s", &n, &k, a + 1);\n  for (int i = 1; i <= n; i++) {\n    scanf("%d%d", &ls[i], &rs[i]);\n    fa[ls[i]] = fa[rs[i]] = i;\n  }\n  dfs(1);\n  print(1);\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nint i, j, k, n, m, t, l[200500], r[200500], siz[200500], tp[200500], it,\n    id[200500], dep[200500], sb[200500], fa[200500];\nchar s[200500];\nint q[200500];\nstring res;\nvoid dfs0(int x, int d) {\n  if (!x) return;\n  dep[x] = d;\n  fa[l[x]] = fa[r[x]] = x;\n  dfs0(l[x], d + 1);\n  q[++it] = x;\n  dfs0(r[x], d + 1);\n  siz[x] = 1 + siz[l[x]] + siz[r[x]];\n}\nvoid dfs01(int x, int to) {\n  if (!x) return;\n  tp[x] = to;\n  id[x] = ++it;\n  if (siz[l[x]] >= siz[r[x]]) {\n    dfs01(l[x], to);\n    dfs01(r[x], r[x]);\n  } else {\n    dfs01(r[x], to);\n    dfs01(l[x], l[x]);\n  }\n}\nstruct SB {\n  int f[800500], t[805000];\n  void push(int id, int l, int r) {\n    t[(id << 1)] = t[((id << 1) + 1)] = t[id];\n    f[(id << 1)] = ((t[id] < 1) ? -1000000 : (((l + r) >> 1) - l + 1));\n    f[((id << 1) + 1)] = ((t[id] < 1) ? -1000000 : (r - ((l + r) >> 1)));\n    t[id] = 0;\n  }\n  void ass(int id, int l, int r, int x, int y, int w) {\n    if (x <= l && r <= y) {\n      t[id] = w;\n      f[id] = ((w < 1) ? -1000000 : (r - l + 1));\n      return;\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (x <= ((l + r) >> 1)) ass((id << 1), l, ((l + r) >> 1), x, y, w);\n    if (y > ((l + r) >> 1))\n      ass(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y, w);\n    f[id] = max(-1000000, f[(id << 1)] + f[((id << 1) + 1)]);\n  }\n  int get(int id, int l, int r, int x, int y) {\n    if (x <= l && r <= y) {\n      return f[id];\n    }\n    if (t[id]) {\n      push(id, l, r);\n    }\n    if (y <= ((l + r) >> 1)) return get((id << 1), l, ((l + r) >> 1), x, y);\n    if (x > ((l + r) >> 1))\n      return get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y);\n    return max(-1000000, get((id << 1), l, ((l + r) >> 1), x, y) +\n                             get(((id << 1) + 1), ((l + r) >> 1) + 1, r, x, y));\n  }\n} SB;\nvoid hld_ass(int x, int w) {\n  while (x) {\n    SB.ass(1, 1, n, id[tp[x]], id[x], 1);\n    x = fa[tp[x]];\n  }\n}\nint hld_get(int x, int w = 0) {\n  while (x) {\n    w += SB.get(1, 1, n, id[tp[x]], id[x]);\n    w = max(w, -1000000);\n    x = fa[tp[x]];\n  }\n  return w;\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin >> n >> m >> s + 1;\n  for (i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs0(1, 1);\n  it = 0;\n  dfs01(1, 1);\n  for (i = n; i >= 1; i--) {\n    if (s[q[i]] == s[q[i + 1]]) {\n      sb[i] = sb[i + 1];\n    } else {\n      sb[i] = (s[q[i]] < s[q[i + 1]]);\n    }\n  }\n  for (i = 1; i < n; i++) {\n    res += s[q[i]];\n    if (SB.get(1, 1, n, id[q[i]], id[q[i]])) {\n      res += s[q[i]];\n      continue;\n    }\n    if (sb[i]) {\n      k = hld_get(q[i]);\n      if (k + m >= dep[q[i]]) {\n        res += s[q[i]];\n        m -= (dep[q[i]] - k);\n        hld_ass(q[i], 1);\n      }\n    } else {\n      SB.ass(1, 1, n, id[q[i]], id[q[i]], -1000000);\n    }\n  }\n  res += s[q[n]];\n  cout << res;\n}\n', "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nint l[200005], r[200005];\nchar m[200005], nxt[200005];\nstring s, t;\nstring res;\nvector<int> v;\nvoid dfs1(int u) {\n  if (!u) return;\n  dfs1(l[u]);\n  t += s[u];\n  v.push_back(u);\n  dfs1(r[u]);\n}\nvoid dfs(int u, int h) {\n  int k0 = k;\n  if (l[u]) {\n    dfs(l[u], h - 1);\n  }\n  bool smaller = false;\n  if (s[u] < nxt[u]) {\n    smaller = true;\n  }\n  if (h > 0 && (k != k0 || smaller)) {\n    k--;\n    res += s[u];\n    res += s[u];\n  } else {\n    res += s[u];\n  }\n  if (r[u]) {\n    if (h > 0 && (k != k0 || smaller))\n      dfs(r[u], k);\n    else\n      dfs(r[u], 0);\n  }\n}\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(NULL);\n  cin >> n >> k;\n  cin >> s;\n  s = '#' + s;\n  for (int i = 1; i <= n; i++) {\n    cin >> l[i] >> r[i];\n  }\n  dfs1(1);\n  char cur = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    m[v[i]] = cur;\n    cur = max(cur, t[i]);\n    if (i != n - 1) {\n      if (t[i] == t[i + 1])\n        nxt[v[i]] = nxt[v[i + 1]];\n      else\n        nxt[v[i]] = t[i + 1];\n    }\n  }\n  dfs(1, k);\n  cout << res << endl;\n  return 0;\n}\n", '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\nconst int M = 4e5 + 1;\nconst long long MOD = 1e9 + 7;\nconst long long MOD1 = 998244353;\nconst long long INF = 1e17;\nconst int inf = 1e9;\nlong long n, m, k;\nstring s;\nvector<int> l(n + 1), r(n + 1);\nvector<char> val(n + 1);\nvector<int> pos(n + 1);\nvector<bool> dup(n + 1), good(n + 1);\nstring dfs1(int node, int len) {\n  if (node == 0) return "";\n  string before = dfs1(l[node], len);\n  pos[before.length() + len] = node;\n  return before + val[node] + dfs1(r[node], len + before.size() + 1);\n}\nvoid dfs2(int node, int depth) {\n  if (depth > k || node == 0) return;\n  dfs2(l[node], depth + 1);\n  if (dup[l[node]])\n    dup[node] = true;\n  else if (good[node]) {\n    dup[node] = true;\n    k -= depth;\n  }\n  if (dup[node]) {\n    dfs2(r[node], 1);\n  }\n}\nvoid solve() {\n  cin >> n >> k;\n  l.clear();\n  r.clear();\n  val.clear();\n  pos.clear();\n  dup.clear();\n  good.clear();\n  l.resize(n + 1);\n  r.resize(n + 1);\n  val.resize(n + 1);\n  pos.resize(n + 1);\n  dup.resize(n + 1);\n  good.resize(n + 1);\n  for (int i = 1; i <= n; i++) {\n    char c;\n    cin >> c;\n    val[i] = c;\n  }\n  for (int i = 1; i <= n; i++) {\n    int l1, r1;\n    cin >> l1 >> r1;\n    l[i] = l1;\n    r[i] = r1;\n  }\n  s = dfs1(1, 0);\n  for (int i = 0; i < n - 1; i++) {\n    if (val[pos[i]] <= val[pos[i + 1]]) {\n      good[pos[i]] = true;\n    }\n  }\n  dfs2(1, 1);\n  for (int i = 0; i < n; i++) {\n    cout << val[pos[i]];\n    if (dup[pos[i]]) {\n      cout << val[pos[i]];\n    }\n  }\n  cout << endl;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int tc = 1;\n  for (int t = 1; t <= tc; t++) {\n    solve();\n  }\n}\n', '#include <bits/stdc++.h>\nconst long long inf = 2e9;\nusing namespace std;\nvector<long long> pos;\nstring f(long long cur, vector<pair<long long, long long>> &g, string &s) {\n  if (cur == -1) return "";\n  string before = f(g[cur].first, g, s);\n  pos.push_back(cur);\n  return before + s[cur] + f(g[cur].second, g, s);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  long long n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  vector<pair<long long, long long>> g(n);\n  vector<pair<long long, long long>> parent(n);\n  parent[0] = make_pair(-1, -1);\n  for (int i = 0; i < int(n); ++i) {\n    long long a, b;\n    cin >> a >> b;\n    a--, b--;\n    g[i] = make_pair(a, b);\n    if (a != -1) parent[a] = make_pair(i, 0);\n    if (b != -1) parent[b] = make_pair(i, 1);\n  }\n  string initial = f(0, g, s);\n  vector<bool> taken(n);\n  vector<long long> suffix(n + 1);\n  for (int i = n - 1; i >= 0; i--) {\n    suffix[i] = max(suffix[i + 1], (long long)initial[i]);\n  }\n  cerr << initial << endl;\n  for (int i = 0; i < int(initial.size() - 1); ++i) {\n    if (initial[i] > initial[i + 1])\n      continue;\n    else if (initial[i] == initial[i + 1] and suffix[i] == initial[i]) {\n      continue;\n    }\n    long long sum = 0;\n    bool ok = 1;\n    long long cur = pos[i];\n    cerr << "testing " << i << " " << initial[i] << endl;\n    while (cur != -1) {\n      if (taken[cur]) break;\n      sum++;\n      cerr << cur << " " << parent[cur].first << " " << parent[cur].second\n           << endl;\n      if (cur == 0 || taken[parent[cur].first]) break;\n      if (parent[cur].second) {\n        ok = 0;\n        break;\n      }\n      cur = parent[cur].first;\n    }\n    if (ok and k >= sum) {\n      cerr << initial[i] << " was ok with sum of " << sum << " and k is " << k\n           << endl;\n      long long cur = pos[i];\n      while (cur != -1) {\n        taken[cur] = 1;\n        cur = parent[cur].first;\n      }\n      k -= sum;\n    }\n  }\n  string res = "";\n  for (int i = 0; i < int(initial.size()); ++i) {\n    res += initial[i];\n    if (taken[pos[i]]) {\n      res += initial[i];\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n', '#include <bits/stdc++.h>\nlong getbit(long first, long second) { return ((first >> second) & 1); }\nusing namespace std;\nconst long N = 2e5 + 5;\nlong cnt, n, k, l[N], r[N], h[N];\nchar c[N];\nstring s;\nvector<long> so;\nbool dd[N], Next[N];\nvoid tao(long u, long pa) {\n  h[u] = h[pa] + 1;\n  if (l[u] != 0) tao(l[u], u);\n  s += c[u];\n  so.push_back(u);\n  if (r[u] != 0) tao(r[u], u);\n}\nvoid dfs(long u, long last) {\n  if (l[u] != 0) {\n    if (Next[l[u]] && cnt + h[l[u]] - h[last] <= k) {\n      dd[l[u]] = 1;\n      cnt += h[l[u]] - h[last];\n      last = u;\n      dfs(l[u], l[u]);\n    }\n  }\n  if (r[u] != 0) {\n    if ((last == u || Next[u]) && cnt + h[u] - h[last] <= k) {\n      dd[u] = 1;\n      cnt += h[u] - h[last];\n      dfs(r[u], u);\n    }\n  }\n}\nvoid dfs1(long u) {\n  if (l[u] != 0) {\n    dfs1(l[u]);\n    dd[u] |= dd[l[u]];\n  }\n  if (r[u] != 0) {\n    dfs1(r[u]);\n    dd[u] |= dd[r[u]];\n  }\n}\nvoid tao1(long u) {\n  if (l[u] != 0) tao1(l[u]);\n  if (dd[u])\n    s += c[u], s += c[u];\n  else\n    s += c[u];\n  if (r[u] != 0) tao1(r[u]);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n >> k;\n  for (long i = 1; i <= n; i++) cin >> c[i];\n  for (long i = 1; i <= n; i++) cin >> l[i] >> r[i];\n  s = "";\n  tao(1, 0);\n  for (long i = (long)s.size() - 1; i >= 0; i--)\n    if (i == (long)s.size() - 1)\n      Next[so[i]] = 0;\n    else if (s[i] < s[i + 1])\n      Next[so[i]] = 1;\n    else if (s[i] == s[i + 1])\n      Next[so[i]] = Next[so[i + 1]];\n    else\n      Next[so[i]] = 0;\n  dfs(1, 0);\n  dfs1(1);\n  s = "";\n  tao1(1);\n  cout << s << \'\\n\';\n  return 0;\n}\n', '#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 7;\nint n, k;\nstring s;\nvector<int> nodes;\nvector<pair<int, int>> g(N), p(N);\nstring solveInitial(int u) {\n  string t;\n  if (~g[u].first) t += solveInitial(g[u].first);\n  t += s[u];\n  nodes.push_back(u);\n  if (~g[u].second) t += solveInitial(g[u].second);\n  return t;\n}\npair<string, bool> solve(int u, int c, int canDup) {\n  string t;\n  bool dupPar = 0;\n  pair<string, bool> ret = {"", 0};\n  if (~g[u].first) ret = solve(g[u].first, c + 1, canDup);\n  t += ret.first, t += s[u];\n  if (ret.second)\n    dupPar = 1;\n  else {\n    if (c <= k && p[u].first > p[u].second) dupPar = 1;\n  }\n  if (dupPar && canDup)\n    t += s[u], k -= c, c = 0;\n  else\n    canDup = 0;\n  ret = {"", 0};\n  if (~g[u].second) ret = solve(g[u].second, c + 1, canDup);\n  t += ret.first;\n  return {t, dupPar};\n}\nvoid testCase() {\n  cin >> n >> k >> s;\n  for (int i = 0; i < n; i++)\n    cin >> g[i].first >> g[i].second, g[i].first--, g[i].second--;\n  string t = solveInitial(0);\n  vector<int> v(26, -1);\n  for (int i = t.size() - 1; i >= 0; i--) {\n    int l = 1e9, r = 1e9;\n    for (int j = t[i] - \'a\' + 1; j < 26; j++) {\n      if (~v[j]) r = min(r, v[j]);\n    }\n    for (int j = t[i] - \'a\' - 1; j >= 0; j--) {\n      if (~v[j]) l = min(l, v[j]);\n    }\n    p[nodes[i]] = {l, r};\n    v[t[i] - \'a\'] = i;\n  }\n  cout << solve(0, 1, 1).first;\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int T = 1;\n  while (T--) testCase();\n  return 0;\n}\n']}
----------------------------------------------------------------------------------------------------
cf_contest_id
1623
----------------------------------------------------------------------------------------------------
cf_index
E
----------------------------------------------------------------------------------------------------
cf_points
2750.0
----------------------------------------------------------------------------------------------------
cf_rating
2500
----------------------------------------------------------------------------------------------------
cf_tags
['data structures', 'dfs and similar', 'greedy', 'strings', 'trees']
----------------------------------------------------------------------------------------------------
is_description_translated
False
----------------------------------------------------------------------------------------------------
untranslated_description

----------------------------------------------------------------------------------------------------
time_limit
{'nanos': 0, 'seconds': 1}
----------------------------------------------------------------------------------------------------
memory_limit_bytes
256000000
----------------------------------------------------------------------------------------------------
input_file

----------------------------------------------------------------------------------------------------
output_file

----------------------------------------------------------------------------------------------------
source
CODEFORCES
----------------------------------------------------------------------------------------------------
difficulty
E
----------------------------------------------------------------------------------------------------
multiple_solutions
False
----------------------------------------------------------------------------------------------------
is_valid_problem
True
----------------------------------------------------------------------------------------------------
dataset_name
codecontest
----------------------------------------------------------------------------------------------------
completions
['def dfs(node, labels, left_children, right_children, k, duplicated, parent_duplicated):\n    if node == 0:\n        return ""\n    \n    left = dfs(left_children[node], labels, left_children, right_children, k, duplicated, parent_duplicated or duplicated[node])\n    \n    if duplicated[node]:\n        labels[node] *= 2\n    \n    if labels[node] > \'z\':\n        return ""\n    \n    right = dfs(right_children[node], labels, left_children, right_children, k, duplicated, parent_duplicated or duplicated[node])\n    \n    if not parent_duplicated and duplicated[node]:\n        labels[node] = chr(ord(labels[node]) // 2)\n    \n    if left == "" and right == "":\n        return labels[node]\n    \n    return left + labels[node] + right\n\nif __name__ == "__main__":\n    n, k = map(int, input().split())\n    labels = [\'\'] + list(input().strip())\n    left_children = [0] + [0] * n\n    right_children = [0] + [0] * n\n    duplicated = [False] + [False] * n\n    \n    for i in range(1, n + 1):\n        l, r = map(int, input().split())\n        left_children[i] = l\n        right_children[i] = r\n    \n    result = dfs(1, labels, left_children, right_children, k, duplicated, False)\n    print(result)', 'def dfs(node, parent, labels, dp, k, tree):\n    if node == 0:\n        return\n    \n    left_child = tree[node][0]\n    right_child = tree[node][1]\n    \n    dfs(left_child, node, labels, dp, k, tree)\n    dfs(right_child, node, labels, dp, k, tree)\n    \n    if left_child != 0:\n        for label in dp[left_child]:\n            if len(dp[node]) < k:\n                dp[node].add(label)\n            elif label < max(dp[node]):\n                dp[node].remove(max(dp[node]))\n                dp[node].add(label)\n    \n    if right_child != 0:\n        for label in dp[right_child]:\n            if len(dp[node]) < k:\n                dp[node].add(label)\n            elif label < max(dp[node]):\n                dp[node].remove(max(dp[node]))\n                dp[node].add(label)\n    \n    if parent != 0:\n        if len(dp[parent]) < k:\n            for label in dp[node]:\n                dp[parent].add(label)\n        else:\n            for label in dp[node]:\n                if label < max(dp[parent]):\n                    dp[parent].remove(max(dp[parent]))\n                    dp[parent].add(label)\n\ndef construct_string(node, labels, dp, tree):\n    if node == 0:\n        return ""\n    \n    left_child = tree[node][0]\n    right_child = tree[node][1]\n    \n    left_str = construct_string(left_child, labels, dp, tree)\n    right_str = construct_string(right_child, labels, dp, tree)\n    \n    label = labels[node - 1]\n    \n    if label * 2 in dp[node]:\n        label *= 2\n    \n    return left_str + label + right_str\n\nif __name__ == "__main__":\n    n, k = map(int, input().split())\n    labels = input().strip()\n    \n    tree = {}\n    for i in range(1, n + 1):\n        l, r = map(int, input().split())\n        tree[i] = (l, r)\n    \n    dp = {i: set([labels[i-1]]) for i in range(1, n+1)}\n    \n    dfs(1, 0, labels, dp, k, tree)\n    \n    result = construct_string(1, labels, dp, tree)\n    \n    print(result)', 'def sort_key(x):\n    return (x, x[::-1])\n\ndef dfs(node, parent_duplicated, best_string):\n    if node == 0 or node > len(labels):\n        return "", best_string\n\n    left_string, best_string = dfs(left_child[node], parent_duplicated or node_duplicated[node], best_string)\n    current_string = labels[node - 1] + left_string\n    right_string, best_string = dfs(right_child[node], parent_duplicated or node_duplicated[node], best_string)\n\n    if node_duplicated[node]:\n        current_string += labels[node - 1]\n\n    if parent_duplicated:\n        current_string = min(current_string, labels[node - 1] + right_string, key=sort_key)\n\n    best_string = min(best_string, current_string, key=sort_key)\n\n    return current_string, best_string\n\nif __name__ == "__main__":\n    n, k = map(int, input().split())\n    labels = input().strip()\n    left_child = [0] * (n + 1)\n    right_child = [0] * (n + 1)\n    node_duplicated = [False] * (n + 1)\n\n    for i in range(1, n + 1):\n        left, right = map(int, input().split())\n        left_child[i] = left\n        right_child[i] = right\n\n    best_string = "z" * (n + 1)  # Initialize best_string\n    _, best_string = dfs(1, False, best_string)\n    print(best_string)', 'def dfs(node, labels, duplicates, k, tree):\n    if node == 0:\n        return \'\', 0\n    \n    left, left_dup = dfs(tree[node][0], labels, duplicates, k, tree)\n    label = labels[node - 1]\n    right, right_dup = dfs(tree[node][1], labels, duplicates, k, tree)\n    \n    total_dup = left_dup + right_dup\n    \n    if node in duplicates:\n        if duplicates[node] < 2 and total_dup < k:\n            label *= 2\n            duplicates[node] += 1\n            total_dup += 1\n    else:\n        duplicates[node] = 1\n        total_dup += 1\n    \n    if node != 1 and tree[node][0] != 0:\n        parent = tree[node][0]\n        if duplicates[parent] < 2 and total_dup < k:\n            temp_label = label\n            temp_duplicates = dict(duplicates)\n            temp_duplicates[parent] += 1\n            temp_left, temp_left_dup = dfs(tree[parent][0], labels, temp_duplicates, k, tree)\n            temp_right, temp_right_dup = dfs(tree[parent][1], labels, temp_duplicates, k, tree)\n            if len(temp_left) + len(temp_right) + len(temp_label) <= k:\n                left = temp_left\n                right = temp_right\n                label *= 2\n                duplicates[parent] += 1\n                total_dup += 1\n    \n    return left + label + right, total_dup\n\nif __name__ == "__main__":\n    n, k = map(int, input().split())\n    labels = input().strip()\n    tree = {}\n    for i in range(1, n + 1):\n        l, r = map(int, input().split())\n        tree[i] = (l, r)\n    \n    duplicates = {}\n    result, _ = dfs(1, labels, duplicates, k, tree)\n    print(result)', 'def dfs(node, labels, left_children, right_children, k, duplicates, best_string):\n    if node == 0:\n        return ""\n\n    left = dfs(left_children[node], labels, left_children, right_children, k, duplicates, best_string)\n    current_label = labels[node - 1] * (duplicates[node] + 1)\n    right = dfs(right_children[node], labels, left_children, right_children, k, duplicates, best_string)\n\n    current_string = left + current_label + right\n\n    if node in duplicates:\n        if duplicates[node] < k:\n            new_duplicates = duplicates.copy()\n            new_duplicates[node] += 1\n            new_string = left + current_label + right\n            if new_string < best_string[0]:\n                best_string[0] = new_string\n                return new_string\n\n    if current_string < best_string[0]:\n        best_string[0] = current_string\n\n    return current_string\n\nif __name__ == "__main__":\n    n, k = map(int, input().split())\n    labels = input().strip()\n    left_children = {}\n    right_children = {}\n    duplicates = {}\n\n    for i in range(1, n + 1):\n        l, r = map(int, input().split())\n        left_children[i] = l\n        right_children[i] = r\n        duplicates[i] = 0\n\n    best_string = [dfs(1, labels, left_children, right_children, k, duplicates, [labels])]\n\n    print(best_string[0])', 'def f1(n, k, c, children, parent, dp, kdp):\n    if n == 0:\n        return ""\n    if dp[n][k] != -1:\n        return dp[n][k]\n    res = f1(children[n][0], k, c, children, parent, dp, kdp) + c[n-1] + f1(children[n][1], k, c, children, parent, dp, kdp)\n    if parent[n] != 0:\n        if k > 0:\n            res2 = f1(children[n][0], k-1, c, children, parent, dp, kdp) + c[n-1] + f1(children[n][1], k-1, c, children, parent, dp, kdp)\n            if res2 < res:\n                res = res2\n    dp[n][k] = res\n    return res\n\ndef f2(n, k, c, children):\n    parent = [0] * (n+1)\n    for i in range(1, n+1):\n        if children[i][0] != 0:\n            parent[children[i][0]] = i\n        if children[i][1] != 0:\n            parent[children[i][1]] = i\n\n    dp = [[-1] * (k+1) for _ in range(n+1)]\n    kdp = [[-1] * (k+1) for _ in range(n+1)]\n    return f1(1, k, c, children, parent, dp, kdp)\n\nif __name__ == "__main__":\n    n, k = map(int, input().split())\n    c = input().strip()\n    children = {}\n    for i in range(1, n+1):\n        l, r = map(int, input().split())\n        children[i] = (l, r)\n    \n    result = f2(n, k, c, children)\n    print(result)', 'def build_tree(n, k, c, children):\n    tree = {}\n    for i in range(1, n + 1):\n        tree[i] = {\'label\': c[i - 1], \'children\': children[i - 1]}\n    return tree\n\ndef build_initial_string(tree, node):\n    if node == 0:\n        return \'\'\n    return build_initial_string(tree, tree[node][\'children\'][0]) + tree[node][\'label\'] + build_initial_string(tree, tree[node][\'children\'][1])\n\ndef duplicate_labels(tree, node, parent_duplicated, total_duplicates, k):\n    if node == 0:\n        return parent_duplicated, total_duplicates\n\n    left_child = tree[node][\'children\'][0]\n    right_child = tree[node][\'children\'][1]\n\n    left_duplicated, total_duplicates = duplicate_labels(tree, left_child, parent_duplicated or total_duplicates > 0, total_duplicates, k)\n\n    if total_duplicates < k and (parent_duplicated or left_duplicated):\n        if tree[node][\'label\'] * 2 < tree[left_child][\'label\'] + tree[node][\'label\'] + tree[right_child][\'label\']:\n            tree[node][\'label\'] *= 2\n            total_duplicates += 1\n\n    right_duplicated, total_duplicates = duplicate_labels(tree, right_child, parent_duplicated or left_duplicated, total_duplicates, k)\n\n    return right_duplicated, total_duplicates\n\ndef build_final_string(tree, node):\n    if node == 0:\n        return \'\'\n    return build_final_string(tree, tree[node][\'children\'][0]) + tree[node][\'label\'] + build_final_string(tree, tree[node][\'children\'][1])\n\nif __name__ == "__main__":\n    n, k = map(int, input().split())\n    c = input().strip()\n    children = [list(map(int, input().split())) for _ in range(n)]\n\n    tree = build_tree(n, k, c, children)\n    \n    initial_string = build_initial_string(tree, 1)\n    \n    _, _ = duplicate_labels(tree, 1, False, 0, k)\n    \n    final_string = build_final_string(tree, 1)\n    \n    print(final_string)', 'def solve_tree_representation(n, k, labels, children, dp, node, duplicate):\n    if node == 0:\n        return ""\n    \n    if dp[node][duplicate] != "":\n        return dp[node][duplicate]\n    \n    left_child = children[node][0]\n    right_child = children[node][1]\n    \n    result = labels[node-1]\n    \n    if duplicate < k or (duplicate == k and dp[node][duplicate-1] != ""):\n        for i in range(duplicate+1):\n            left_str = solve_tree_representation(n, k, labels, children, dp, left_child, i)\n            right_str = solve_tree_representation(n, k, labels, children, dp, right_child, duplicate-i)\n            new_str = left_str + labels[node-1] * (i+1) + right_str\n            if new_str < result:\n                result = new_str\n    \n    dp[node][duplicate] = result\n    return result\n\nif __name__ == "__main__":\n    n, k = map(int, input().split())\n    labels = input().strip()\n    children = [list(map(int, input().split())) for _ in range(n)]\n    \n    dp = [["" for _ in range(k+1)] for _ in range(n+1)]\n    \n    result = solve_tree_representation(n, k, labels, children, dp, 1, 0)\n    print(result)', 'def f1(n, k, c, children, parent, dp, kdp):\n    if n == 0:\n        return ""\n    if dp[n][k] != -1:\n        return dp[n][k]\n    res = f1(children[n][0], k, c, children, parent, dp, kdp) + c[n-1] + f1(children[n][1], k, c, children, parent, dp, kdp)\n    if parent[n] != 0:\n        if k > 0:\n            res2 = f1(children[n][0], k-1, c, children, parent, dp, kdp) + c[n-1] + f1(children[n][1], k-1, c, children, parent, dp, kdp)\n            if res2 < res:\n                res = res2\n    dp[n][k] = res\n    return res\n\ndef f2(n, k, c, children):\n    parent = [0] * (n+1)\n    for i in range(1, n+1):\n        if children[i][0] != 0:\n            parent[children[i][0]] = i\n        if children[i][1] != 0:\n            parent[children[i][1]] = i\n\n    dp = [[-1] * (k+1) for _ in range(n+1)]\n    kdp = [[-1] * (k+1) for _ in range(n+1)]\n    return f1(1, k, c, children, parent, dp, kdp)\n\nif __name__ == "__main__":\n    n, k = map(int, input().split())\n    c = input().strip()\n    children = {}\n    for i in range(1, n+1):\n        l, r = map(int, input().split())\n        children[i] = (l, r)\n    \n    result = f2(n, k, c, children)\n    print(result)', 'def construct_tree(n, c, children):\n    tree = {}\n    for i in range(1, n + 1):\n        tree[i] = {\'label\': c[i - 1], \'children\': []}\n    \n    for i in range(1, n + 1):\n        l, r = children[i - 1]\n        if l != 0:\n            tree[i][\'children\'].append(l)\n        if r != 0:\n            tree[i][\'children\'].append(r)\n    \n    return tree\n\ndef post_order_traversal(node, tree, duplicated_labels, k):\n    if not node[\'children\']:\n        return node[\'label\']\n    \n    left_str = post_order_traversal(tree[node[\'children\'][0]], tree, duplicated_labels, k)\n    right_str = \'\'\n    if len(node[\'children\']) == 2:\n        right_str = post_order_traversal(tree[node[\'children\'][1]], tree, duplicated_labels, k)\n    \n    if node[\'label\'] * 2 < left_str[0] or (len(node[\'children\']) == 2 and node[\'label\'] * 2 < right_str[0]):\n        if len(duplicated_labels) < k:\n            duplicated_labels.add(node[\'label\'])\n            return node[\'label\'] * 2 + left_str + right_str\n    return left_str + node[\'label\'] + right_str\n\nif __name__ == "__main__":\n    n, k = map(int, input().split())\n    c = input().strip()\n    children = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    tree = construct_tree(n, c, children)\n    duplicated_labels = set()\n    result = post_order_traversal(tree[1], tree, duplicated_labels, k)\n    \n    print(result)']
----------------------------------------------------------------------------------------------------
plans
['- name: \nDynamic Programming Approach\n- content: \n- Define a dynamic programming approach where each state represents a node and the number of times its label has been duplicated.\n- Initialize the DP array with values representing the lexicographically smallest string representation for each state.\n- Use dynamic programming to explore all possible duplications at each node while keeping track of the constraints on the total number of duplications allowed.\n- Update the DP array based on the optimal choices for duplicating labels at each node.\n- Traverse the DP array to construct the final string representation of the tree with the minimum lexicographic value.\n\n', '- name: \nDynamic Programming (DP)\n- content: \n1. Define a DP state that represents the lexicographically smallest string formed at each node with a certain count of duplicated labels used.\n2. Implement a DP solution where each state considers whether to duplicate the label of the current node or not, based on the constraints and the choices made at its parent nodes.\n3. Recursively update the DP states for each node while considering the possible choices and constraints.\n4. Use memoization to avoid redundant calculations and optimize the overall solution.\n5. Finally, retrieve the lexicographically smallest string representation by considering all possible DP states and return the result.\n', '- name: \nDepth-First Search (DFS) with Backtracking\n- content: \n- Implement a DFS traversal of the tree where each node can be visited multiple times to explore different label duplication scenarios.\n- At each node, consider duplicating its label and recursively explore the subtree to see if it leads to a lexicographically smaller string representation.\n- Keep track of the current best string representation found so far and backtrack when necessary to explore other possibilities.\n\n', '- name: \nDFS with Backtracking\n- content: \n1. Implement a Depth First Search (DFS) algorithm to traverse the tree from the root node.\n2. During the traversal, keep track of the labels that have been duplicated and the total number of duplications so far.\n3. Use backtracking to explore all possible choices of duplicating labels for each node while respecting the constraints.\n4. Return the lexicographically smallest string representation found after trying all possible combinations.\n\n', "- name: \nGreedy Approach\n- content: \n- Initialize a priority queue to store nodes based on their labels in increasing order.\n- Initialize a set to keep track of nodes whose labels have been duplicated.\n- Initialize a counter for the total number of label duplications used.\n- Start traversing the tree in in-order using a stack, starting from the root.\n- While traversing:\n  - Pop a node from the stack.\n  - If the node's label has not been duplicated and the total duplications used is less than k, duplicate its label and update the counter.\n  - Add the node's children to the stack.\n  - If both children are present, push the right child first and then the left child to maintain the in-order traversal order.\n  - Add the node to the priority queue if its label has been duplicated.\n- While the priority queue is not empty and there are duplications remaining:\n  - Pop the node with the smallest label from the priority queue.\n  - Duplicate its label if possible and update the counter.\n- Reconstruct the string representation of the tree using the updated labels.\n- Output the lexicographically smallest string representation.\n\n", '- name: \nGreedy Approach\n- content: \n- Start by constructing the tree following the given input.\n- Traverse the tree in post-order and keep track of the number of duplicates needed at each node.\n- At each node, check if duplicating its label would lead to a lexicographically smaller string representation without violating the constraints.\n- If duplicating the label is beneficial, do so and update the number of duplicates needed for its children accordingly.\n- Continue this process until all nodes are processed.\n- Finally, reconstruct the string representation of the tree considering the duplicates made.\n\n', '- name: \nDFS with Dynamic Programming\n- content: \n1. Implement a depth-first search (DFS) algorithm to traverse the tree and calculate the best possible label duplication for each node.\n2. Define a dynamic programming (DP) table to store the best duplication choices for each node considering the constraints.\n3. During DFS traversal:\n   - Propagate the best duplication choices from children to parents in a bottom-up manner.\n   - Update the DP table with the optimal duplication decisions at each node.\n4. After completing DFS, use the DP table to construct the lexicographically smallest string representation.\n\n', '- name: \nGreedy Approach\n- content: \n- Start at the root node and traverse the tree in an in-order manner.\n- Maintain a priority queue to store the nodes based on their labels in lexicographical order.\n- For each node, check if duplicating its label would result in a lexicographically smaller string.\n- If duplicating the label is beneficial, do so and update the label accordingly.\n- Keep track of the number of nodes whose labels have been duplicated and ensure it does not exceed k.\n- Construct the final string representation using the updated labels.\n- Output the lexicographically smallest string representation obtained.\n\n', '- name: \nGreedy Approach\n- content: \n- Start by assigning the original labels to the nodes in the tree.\n- Traverse the tree in post-order and for each node, calculate the lexicographically smallest string that can be formed by duplicating labels at most k nodes in its subtree.\n- At each node, consider the cases of not duplicating the label, duplicating the label once, or duplicating it twice.\n- Keep track of the count of nodes whose label has been duplicated so far.\n- If the count is less than or equal to k, update the label accordingly.\n- Return the label at the root node as the final result.\n\n', '- name: \nGreedy Approach\n- content: \n- Start by assigning the original labels to the nodes.\n- Initialize a variable to keep track of the remaining duplications allowed.\n- Perform a DFS traversal on the tree in post-order.\n- During the traversal, calculate the lexicographically smallest string representation of the subtree rooted at the current node.\n- For each node, update its label to the lexicographically smallest label possible while considering the duplications allowed.\n- If duplications are still allowed, check if duplicating the label of the current node or its children would lead to a lexicographically smaller result.\n- Update the label accordingly and decrement the remaining duplications if a label was duplicated.\n- Return the lexicographically smallest string representation of the entire tree.\n\n']
----------------------------------------------------------------------------------------------------
passed
False
----------------------------------------------------------------------------------------------------
pass_num
0
39
len of loaded problems: 39
----------------------------------------round: 0------------------------------
----------selecting seed----------
path & finish
[False]
current seed index:0
----------mutating----------
--------------------------------------------------
expand_one2two
--------------------------------------------------
Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.

Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.

A string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:

  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; 
  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. 
