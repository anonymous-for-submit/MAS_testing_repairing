['\n[NO]']
Namespace(dataset='codecontest', split_name='test', model='deepseek-coder', solution_file_name='solutions.json', id_range=None, id_list=None, dir_path='results_repair', method='pair_programming', output_path='./outputs/repair/', input_path='/data/zlyuaj/muti-agent/PairCoder/outputs/fuzzing/results-fuzzing_deepseek-coder_codecontest_1-1/_node_1000.jsonl', output_file_name='repair_deepseek-coder_codecontest', num_generate=10, parallel=0, mutate_method='random', num_round=1000, save_seed=1, recover=0, calc_analyst=1, calc_final_result=1, save_all_seed=0, set_threshold_analyst=1, calc_relative_reward=1, clean_mutate_method=1, split_input=1, mutate_level='whole', alpha=1.0, beta=1, add_monitor=1, repair_plan=1, repair_code=1, run_multi_gen=1, repair_prompt_num=2)
num_problems: 165
private_tests_dict 165
len of loaded problems: 20
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the books lexicographically in ascending order, while Budi wants to sort them lexicographically in descending order.

Settling their fight, they decided to combine their ideas and sort them in an asc-desc-ending order, where the characters at odd positions will be compared in ascending order, and the characters at even positions will be compared in descending order.

A

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
multi-gen-prompt:
 Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending. Settling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly. A string a occurs before a string b in asc-desc-ending

Input

The first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).

The i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.

Output

Output n integers — the indices of the strings after they are sorted asc-desc-endingly.

Example

Input


5 2
AA
AB
BB
BA
AZ


Output


5 2 1 3 4

Note

The following illustrates the first example.

<image>
generating with deepseek-coder
----------
['def custom_sort_key(s, index):\n    key = []\n    for i, char in enumerate(s):\n        if (i + 1) % 2 == 1:  # Odd index\n            key.append(ord(char))\n        else:  # Even index\n            key.append(-ord(char))\n    return tuple(key + [index])\n\ndef f1(n, m, books):\n    indexed_books = [(book, i + 1) for i, book in enumerate(books)]\n    sorted_books = sorted(indexed_books, key=lambda x: custom_sort_key(x[0], x[1]))\n    sorted_indices = [index for book, index in sorted_books]\n    return sorted_indices\n\nif __name__ == "__main__":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    result = f1(n, m, books)\n    print(\' \'.join(map(str, result)))', 'def custom_comparator(s1, s2, m):\n    for i in range(m):\n        if i % 2 == 0:  # Odd position\n            if s1[i] < s2[i]:\n                return -1\n            elif s1[i] > s2[i]:\n                return 1\n        else:  # Even position\n            if s1[i] > s2[i]:\n                return -1\n            elif s1[i] < s2[i]:\n                return 1\n    return 0\n\ndef sort_strings_asc_desc_endingly(n, m, books):\n    indexed_books = list(enumerate(books, start=1))\n    indexed_books.sort(key=lambda x: [x[1][i] if i % 2 == 0 else -ord(x[1][i]) for i in range(m)])\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\nif __name__ == "__main__":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    sorted_indices = sort_strings_asc_desc_endingly(n, m, books)\n    print(\' \'.join(map(str, sorted_indices)))', 'def hybrid_lexicographical_sort(books, n, m):\n    def hybrid_key(book):\n        key = []\n        for i in range(m):\n            if i % 2 == 0:\n                key.append(book[i])\n            else:\n                key.append(chr(122 - ord(book[i])))  # Reverse order for even positions\n        return tuple(key)\n\n    indexed_books = list(enumerate(books, start=1))\n    indexed_books.sort(key=lambda x: hybrid_key(x[1]))\n    return [index for index, _ in indexed_books]\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    books = []\n    index = 2\n    for _ in range(n):\n        books.append(data[index])\n        index += 1\n    \n    result = hybrid_lexicographical_sort(books, n, m)\n    print(" ".join(map(str, result)))', 'def custom_sort_key(s, index):\n    # Create a key for the string based on the custom sorting rules\n    key = ""\n    for i, char in enumerate(s):\n        if i % 2 == 0:\n            # For odd-indexed characters, sort in ascending order\n            key += chr(ord(\'A\') + (ord(char) - ord(\'A\')))\n        else:\n            # For even-indexed characters, sort in descending order\n            key += chr(ord(\'Z\') - (ord(char) - ord(\'A\')))\n    return key, index\n\ndef f1(n, m, books):\n    # Sort the books using the custom key function\n    sorted_books = sorted(range(1, n + 1), key=lambda x: custom_sort_key(books[x - 1], x))\n    return sorted_books\n\nif __name__ == "__main__":\n    # Read input\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    \n    # Get the sorted indices\n    sorted_indices = f1(n, m, books)\n    \n    # Print the sorted indices\n    print(" ".join(map(str, sorted_indices)))', 'def hybrid_sort(s):\n    # Custom sorting function\n    def hybrid_key(book, index):\n        char = book[index]\n        if index % 2 == 0:\n            # Even index: sort in descending order\n            return -ord(char)\n        else:\n            # Odd index: sort in ascending order\n            return ord(char)\n\n    return hybrid_key\n\nif __name__ == "__main__":\n    # Read input values for n and m\n    n, m = map(int, input().split())\n    \n    # Read the book titles\n    books = [input().strip() for _ in range(n)]\n    \n    # Sort the books using the hybrid lexicographical order\n    sorted_indices = sorted(range(n), key=lambda i: [hybrid_sort(books[i])(books[i], j) for j in range(m)])\n    \n    # Output the indices of the sorted book titles\n    print(\' \'.join(map(str, sorted_indices)))', 'def custom_comparator(s1, s2, m):\n    for i in range(m):\n        if i % 2 == 0:  # Odd position\n            if s1[i] < s2[i]:\n                return -1\n            elif s1[i] > s2[i]:\n                return 1\n        else:  # Even position\n            if s1[i] > s2[i]:\n                return -1\n            elif s1[i] < s2[i]:\n                return 1\n    return 0\n\ndef sort_strings_asc_desc_endingly(n, m, books):\n    indexed_books = list(enumerate(books, start=1))\n    indexed_books.sort(key=lambda x: [x[1][i] if i % 2 == 0 else -ord(x[1][i]) for i in range(m)])\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\nif __name__ == "__main__":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    sorted_indices = sort_strings_asc_desc_endingly(n, m, books)\n    print(\' \'.join(map(str, sorted_indices)))', 'def custom_comparator(s1, s2, m):\n    for i in range(m):\n        if i % 2 == 0:  # Odd position\n            if s1[i] < s2[i]:\n                return -1\n            elif s1[i] > s2[i]:\n                return 1\n        else:  # Even position\n            if s1[i] > s2[i]:\n                return -1\n            elif s1[i] < s2[i]:\n                return 1\n    return 0\n\ndef sort_strings_asc_desc_endingly(n, m, books):\n    indexed_books = list(enumerate(books, start=1))\n    indexed_books.sort(key=lambda x: [x[1][i] if i % 2 == 0 else -ord(x[1][i]) for i in range(m)])\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\nif __name__ == "__main__":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    sorted_indices = sort_strings_asc_desc_endingly(n, m, books)\n    print(\' \'.join(map(str, sorted_indices)))', 'def custom_comparator(s1, s2, m):\n    for i in range(m):\n        if i % 2 == 0:  # Odd position\n            if s1[i] < s2[i]:\n                return -1\n            elif s1[i] > s2[i]:\n                return 1\n        else:  # Even position\n            if s1[i] > s2[i]:\n                return -1\n            elif s1[i] < s2[i]:\n                return 1\n    return 0\n\ndef sort_strings_asc_desc_endingly(n, m, books):\n    indexed_books = list(enumerate(books, start=1))\n    indexed_books.sort(key=lambda x: [x[1][i] if i % 2 == 0 else -ord(x[1][i]) for i in range(m)])\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\nif __name__ == "__main__":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    sorted_indices = sort_strings_asc_desc_endingly(n, m, books)\n    print(\' \'.join(map(str, sorted_indices)))', 'def hybrid_lexicographical_sort(books, n, m):\n    def hybrid_key(book):\n        key = []\n        for i in range(m):\n            if i % 2 == 0:\n                key.append(book[i])\n            else:\n                key.append(chr(122 - ord(book[i])))  # Reverse order for even positions\n        return tuple(key)\n\n    indexed_books = list(enumerate(books, start=1))\n    indexed_books.sort(key=lambda x: hybrid_key(x[1]))\n    return [index for index, _ in indexed_books]\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    books = []\n    index = 2\n    for _ in range(n):\n        books.append(data[index])\n        index += 1\n    \n    result = hybrid_lexicographical_sort(books, n, m)\n    print(" ".join(map(str, result)))', 'def custom_comparator(s1, s2, m):\n    for i in range(m):\n        if i % 2 == 0:  # Odd position\n            if s1[i] < s2[i]:\n                return -1\n            elif s1[i] > s2[i]:\n                return 1\n        else:  # Even position\n            if s1[i] > s2[i]:\n                return -1\n            elif s1[i] < s2[i]:\n                return 1\n    return 0\n\ndef sort_strings_asc_desc_endingly(n, m, books):\n    indexed_books = list(enumerate(books, start=1))\n    indexed_books.sort(key=lambda x: [x[1][i] if i % 2 == 0 else -ord(x[1][i]) for i in range(m)])\n    sorted_indices = [index for index, _ in indexed_books]\n    return sorted_indices\n\nif __name__ == "__main__":\n    n, m = map(int, input().split())\n    books = [input().strip() for _ in range(n)]\n    sorted_indices = sort_strings_asc_desc_endingly(n, m, books)\n    print(\' \'.join(map(str, sorted_indices)))']
----------
['- name: \nBrute Force Sorting with Custom Comparator\n\n- content: \nA brute-force approach would be to create a list of tuples where each tuple contains a string and its original index. Then, sort this list using a custom comparator. Finally, extract the sorted indices from the sorted list. Here\'s the plan:\n1. Create a list of tuples where each tuple contains a string and its original index.\n2. Sort this list using a custom comparator that follows the asc-desc-ending rules.\n3. Extract the indices from the sorted list and return them.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'lexicographical order\': This refers to the dictionary order of strings, where each character is compared one by one from left to right.\n    \'ascending\': This means in increasing order.\n    \'descending\': This means in decreasing order.\n    \'odd-indexed and even-indexed characters\': In a string, characters are indexed starting from 1. Odd-indexed characters are those at positions 1, 3, 5, etc., and even-indexed characters are those at positions 2, 4, 6, etc.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps 1-3 should be considered simultaneously.\n    "Create a list of tuples where each tuple contains a string and its original index."\n    "Sort this list using a custom comparator that follows the asc-desc-ending rules."\n    "Extract the indices from the sorted list and return them."\n    This can be achieved by using Python\'s `sorted` function with a custom key that handles the asc-desc-ending comparison logic.\n\n# [edge case] \n    Edge case 1:\n    Input: \n    3 3\n    AAA\n    BBB\n    CCC\n    Output:\n    1 2 3\n    Explanation:\n    Since there are no odd or even indexed characters to compare, the strings are sorted lexicographically by default, and the indices are 1, 2, 3 respectively.\n\n    Edge case 2:\n    Input:\n    2 2\n    AB\n    BA\n    Output:\n    1 2\n    Explanation:\n    The strings differ at the first position (odd index) where \'A\' and \'B\' are compared. Since \'A\' comes before \'B\' in the alphabet, the order is determined by this comparison, and the indices are 1, 2 respectively.\n\n    Edge case 3:\n    Input:\n    2 3\n    ZXY\n    XYZ\n    Output:\n    1 2\n    Explanation:\n    The strings differ at the second position (even index) where \'X\' and \'Y\' are compared. Since \'X\' comes after \'Y\' in the alphabet, the order is determined by this comparison, and the indices are 1, 2 respectively.\n\n# [extra code for edge case]\n    No extra code is needed for the given problem as the provided plan and logic can handle the edge cases effectively.', "- name: \nCustom Lexicographical Sorting\n\n- content: \nWe will use a custom comparator to sort the strings based on the given rules. The comparator will compare characters at each position based on whether the position is odd or even. For odd positions, we will compare characters in ascending order, and for even positions, we will compare characters in descending order. We can achieve this by implementing a custom key function for sorting.\n\nHere's the step-by-step approach:\n1. Define a custom comparator function that takes two strings and compares them based on the given rules.\n2. Use this comparator in the `sorted` function to sort the list of strings.\n3. Return the indices of the sorted strings.\n4. Ensure the function handles all edge cases, such as strings of equal length but different characters, strings with all identical characters, and strings with a mix of identical and unique characters.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical sorting': means sorting strings based on the dictionary order of their characters.\n    'custom comparator': means a function that defines a specific order for sorting.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps 1-4 should be implement simultaneously.\n    We need to define a custom comparator function that will compare characters at each position based on whether the position is odd or even. For odd positions, we will compare characters in ascending order, and for even positions, we will compare characters in descending order. This can be achieved by using a key function in the sorted function.\n\n# [edge case] \n    Input:\n    5 2\n    AA\n    AB\n    BB\n    BA\n    AZ\n\n    Output:\n    5 2 1 3 4\n\n    Explanation:\n    The custom comparator will compare the strings based on the rules:\n    - For odd positions (1st and 3rd character), we compare in ascending order.\n    - For even positions (2nd character), we compare in descending order.\n    - The strings are compared as follows:\n        - AA vs AB: 'A' (odd) < 'B', so AA < AB, AA comes first.\n        - AA vs BB: 'A' (odd) < 'B', so AA < BB, AA comes first.\n        - AA vs BA: 'A' (odd) < 'B', so AA < BA, AA comes first.\n        - AA vs AZ: 'A' (odd) < 'Z', so AA < AZ, AA comes first.\n        - AB vs BB: 'A' (odd) < 'B', so AB < BB, AB comes first.\n        - AB vs BA: 'A' (odd) < 'B', so AB < BA, AB comes first.\n        - AB vs AZ: 'A' (odd) < 'Z', so AB < AZ, AB comes first.\n        - BB vs BA: 'B' (odd) > 'A', so BB > BA, BA comes first.\n        - BB vs AZ: 'B' (odd) > 'A', so BB > AZ, BB comes first.\n        - BA vs AZ: 'B' (odd) > 'A', so BA > AZ, AZ comes first.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The custom comparator will naturally handle all cases, including strings of equal length but different characters, strings with all identical characters, and strings with a mix of identical and unique characters.", "- name: \nHybrid Lexicographical Sorting\n\n- content: \nThe solution involves sorting the book titles based on the custom lexicographical order defined by alternating ascending and descending character comparisons at odd and even positions, respectively.\n\n**Approach:**\n1. Read the input to get the number of books `n` and the length of each book title `m`.\n2. Store each book title as a list of characters for easier manipulation.\n3. Implement a custom comparator function that sorts the titles based on the specified hybrid order.\n4. Use Python's `sorted` function with a custom key to apply this comparator.\n5. Return the indices of the sorted titles in their original order.\n\n**Handling Edge Cases:**\n- The solution ensures that even for large values of `n` and `m`, it remains efficient by leveraging Python's built-in sorting functions.\n- The custom comparator ensures that the titles are sorted correctly according to the hybrid order.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Hybrid Lexicographical Sorting': This concept involves sorting strings based on a custom order where characters at odd positions are compared in ascending order and characters at even positions are compared in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented simultaneously as follows:\n    1. Read the input to get the number of books `n` and the length of each book title `m`.\n    2. Store each book title as a list of characters for easier manipulation.\n    3. Implement a custom comparator function that sorts the titles based on the specified hybrid order.\n    4. Use Python's `sorted` function with a custom key to apply this comparator.\n    5. Return the indices of the sorted titles in their original order.\n\n# [edge case] \n    Edge Case 1:\n    Input:\n    5 2\n    AA\n    AB\n    BB\n    BA\n    AZ\n\n    Output:\n    5 2 1 3 4\n\n    Explanation:\n    The titles are sorted based on the hybrid lexicographical order. The characters at odd positions are compared in ascending order, and the characters at even positions are compared in descending order. The sorted order is AZ, AB, AA, BA, BB, which corresponds to the indices 5, 2, 1, 3, 4.\n\n    Edge Case 2:\n    Input:\n    3 3\n    ABC\n    BCA\n    CAB\n\n    Output:\n    1 2 3\n\n    Explanation:\n    The titles are sorted based on the hybrid lexicographical order. The sorted order is ABC, BCA, CAB, which corresponds to the indices 1, 2, 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided solution is robust and handles the sorting based on the custom hybrid lexicographical order.", "- name: \nOptimized Sorting with Custom Key\n- content: \n**Solution Approach:**\n1. Read the input to get the number of books `n` and the length of each book title `m`.\n2. Store each book title in a list of strings.\n3. Use Python's `sorted` function with a custom key that defines the sorting logic:\n   - For odd-indexed characters, use a lambda function to sort them in ascending order.\n   - For even-indexed characters, use a lambda function to sort them in descending order.\n4. Return the indices of the sorted book titles.\n\n**Handling Edge Cases:**\n- Ensure that the input is read correctly and processed efficiently.\n- Handle cases where `m` is 1 by directly comparing characters.\n- Ensure that the custom key function works correctly for all possible character combinations.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one, from left to right.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented simultaneously to ensure the correct sorting order. The custom key function should be defined to handle the sorting logic for both odd and even indexed characters.\n\n# [edge case] \n    Edge Case 1:\n    Input: 5 2\n    AA\n    AB\n    BB\n    BA\n    AZ\n    Output: 5 2 1 3 4\n    Explanation: The sorting should consider odd-indexed characters in ascending order and even-indexed characters in descending order. The sorted order is AZ, BA, AB, BB, AA. The indices of these strings are 5, 2, 1, 3, 4.\n\n    Edge Case 2:\n    Input: 3 1\n    A\n    B\n    C\n    Output: 1 2 3\n    Explanation: Since the length of each book title is 1, the sorting is straightforward. The sorted order is A, B, C. The indices of these strings are 1, 2, 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the provided plan and logic should be sufficient for the given constraints. The custom key function will naturally handle cases where `m` is 1 by directly comparing characters.", "- name: \nTwo-Pass Sorting\n- content: \nAnother approach to solve this problem is to perform two separate sorts and then merge the results. This method involves:\n1. Sorting the book titles in ascending order for odd-indexed characters.\n2. Sorting the book titles in descending order for even-indexed characters.\n3. Combining these two sorted lists to get the final order based on the hybrid sorting criteria.\n4. Outputting the indices of the sorted book titles.\nThis approach ensures that we handle both ascending and descending comparisons separately before combining them.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical order': This refers to the dictionary order of strings, where each character is compared one by one, from left to right.\n    'ascending': This means arranging items in increasing order.\n    'descending': This means arranging items in decreasing order.\n    'hybrid sorting': This involves sorting based on a combination of two or more sorting criteria.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The plan suggests a two-pass sorting approach:\n    1. Sort the book titles based on odd-indexed characters in ascending order.\n    2. Sort the book titles based on even-indexed characters in descending order.\n    This can be implemented by using Python's built-in sorting functions with custom key functions to handle the hybrid sorting criteria.\n\n# [edge case] \n    Edge Case 1:\n    Input: 5 2\n    AA\n    AB\n    BB\n    BA\n    AZ\n    Output: 5 2 1 3 4\n    Explanation: The strings are sorted first by odd-indexed characters (ascending), then by even-indexed characters (descending). The sorted order is AZ, BA, AA, BB, AB, which corresponds to the indices 5, 4, 1, 3, 2.\n\n    Edge Case 2:\n    Input: 3 3\n    CBA\n    CAB\n    BCA\n    Output: 2 3 1\n    Explanation: The strings are sorted first by odd-indexed characters (ascending), then by even-indexed characters (descending). The sorted order is CAB, BCA, CBA, which corresponds to the indices 2, 3, 1.\n\n# [extra code for edge case]\n    No extra code is needed for handling the edge cases as the provided plan already covers the sorting logic for the given constraints. The plan's two-pass sorting approach ensures that the hybrid sorting criteria are met, and it can handle any input size within the given constraints.", "- name: \nCustom Lexicographical Sorting\n\n- content: \nWe will use a custom comparator to sort the strings based on the given rules. The comparator will compare characters at each position based on whether the position is odd or even. For odd positions, we will compare characters in ascending order, and for even positions, we will compare characters in descending order. We can achieve this by implementing a custom key function for sorting.\n\nHere's the step-by-step approach:\n1. Define a custom comparator function that takes two strings and compares them based on the given rules.\n2. Use this comparator in the `sorted` function to sort the list of strings.\n3. Return the indices of the sorted strings.\n4. Ensure the function handles all edge cases, such as strings of equal length but different characters, strings with all identical characters, and strings with a mix of identical and unique characters.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical sorting': means sorting strings based on the dictionary order of their characters.\n    'custom comparator': means a function that defines a specific order for sorting.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps 1-4 should be implement simultaneously.\n    We need to define a custom comparator function that will compare characters at each position based on whether the position is odd or even. For odd positions, we will compare characters in ascending order, and for even positions, we will compare characters in descending order. This can be achieved by using a key function in the sorted function.\n\n# [edge case] \n    Input:\n    5 2\n    AA\n    AB\n    BB\n    BA\n    AZ\n\n    Output:\n    5 2 1 3 4\n\n    Explanation:\n    The custom comparator will compare the strings based on the rules:\n    - For odd positions (1st and 3rd character), we compare in ascending order.\n    - For even positions (2nd character), we compare in descending order.\n    - The strings are compared as follows:\n        - AA vs AB: 'A' (odd) < 'B', so AA < AB, AA comes first.\n        - AA vs BB: 'A' (odd) < 'B', so AA < BB, AA comes first.\n        - AA vs BA: 'A' (odd) < 'B', so AA < BA, AA comes first.\n        - AA vs AZ: 'A' (odd) < 'Z', so AA < AZ, AA comes first.\n        - AB vs BB: 'A' (odd) < 'B', so AB < BB, AB comes first.\n        - AB vs BA: 'A' (odd) < 'B', so AB < BA, AB comes first.\n        - AB vs AZ: 'A' (odd) < 'Z', so AB < AZ, AB comes first.\n        - BB vs BA: 'B' (odd) > 'A', so BB > BA, BA comes first.\n        - BB vs AZ: 'B' (odd) > 'A', so BB > AZ, BB comes first.\n        - BA vs AZ: 'B' (odd) > 'A', so BA > AZ, AZ comes first.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The custom comparator will naturally handle all cases, including strings of equal length but different characters, strings with all identical characters, and strings with a mix of identical and unique characters.", "- name: \nCustom Lexicographical Sorting\n\n- content: \nWe will use a custom comparator to sort the strings based on the given rules. The comparator will compare characters at each position based on whether the position is odd or even. For odd positions, we will compare characters in ascending order, and for even positions, we will compare characters in descending order. We can achieve this by implementing a custom key function for sorting.\n\nHere's the step-by-step approach:\n1. Define a custom comparator function that takes two strings and compares them based on the given rules.\n2. Use this comparator in the `sorted` function to sort the list of strings.\n3. Return the indices of the sorted strings.\n4. Ensure the function handles all edge cases, such as strings of equal length but different characters, strings with all identical characters, and strings with a mix of identical and unique characters.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical sorting': means sorting strings based on the dictionary order of their characters.\n    'custom comparator': means a function that defines a specific order for sorting.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps 1-4 should be implement simultaneously.\n    We need to define a custom comparator function that will compare characters at each position based on whether the position is odd or even. For odd positions, we will compare characters in ascending order, and for even positions, we will compare characters in descending order. This can be achieved by using a key function in the sorted function.\n\n# [edge case] \n    Input:\n    5 2\n    AA\n    AB\n    BB\n    BA\n    AZ\n\n    Output:\n    5 2 1 3 4\n\n    Explanation:\n    The custom comparator will compare the strings based on the rules:\n    - For odd positions (1st and 3rd character), we compare in ascending order.\n    - For even positions (2nd character), we compare in descending order.\n    - The strings are compared as follows:\n        - AA vs AB: 'A' (odd) < 'B', so AA < AB, AA comes first.\n        - AA vs BB: 'A' (odd) < 'B', so AA < BB, AA comes first.\n        - AA vs BA: 'A' (odd) < 'B', so AA < BA, AA comes first.\n        - AA vs AZ: 'A' (odd) < 'Z', so AA < AZ, AA comes first.\n        - AB vs BB: 'A' (odd) < 'B', so AB < BB, AB comes first.\n        - AB vs BA: 'A' (odd) < 'B', so AB < BA, AB comes first.\n        - AB vs AZ: 'A' (odd) < 'Z', so AB < AZ, AB comes first.\n        - BB vs BA: 'B' (odd) > 'A', so BB > BA, BA comes first.\n        - BB vs AZ: 'B' (odd) > 'A', so BB > AZ, BB comes first.\n        - BA vs AZ: 'B' (odd) > 'A', so BA > AZ, AZ comes first.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The custom comparator will naturally handle all cases, including strings of equal length but different characters, strings with all identical characters, and strings with a mix of identical and unique characters.", "- name: \nCustom Lexicographical Sorting\n\n- content: \nWe will use a custom comparator to sort the strings based on the given rules. The comparator will compare characters at each position based on whether the position is odd or even. For odd positions, we will compare characters in ascending order, and for even positions, we will compare characters in descending order. We can achieve this by implementing a custom key function for sorting.\n\nHere's the step-by-step approach:\n1. Define a custom comparator function that takes two strings and compares them based on the given rules.\n2. Use this comparator in the `sorted` function to sort the list of strings.\n3. Return the indices of the sorted strings.\n4. Ensure the function handles all edge cases, such as strings of equal length but different characters, strings with all identical characters, and strings with a mix of identical and unique characters.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical sorting': means sorting strings based on the dictionary order of their characters.\n    'custom comparator': means a function that defines a specific order for sorting.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps 1-4 should be implement simultaneously.\n    We need to define a custom comparator function that will compare characters at each position based on whether the position is odd or even. For odd positions, we will compare characters in ascending order, and for even positions, we will compare characters in descending order. This can be achieved by using a key function in the sorted function.\n\n# [edge case] \n    Input:\n    5 2\n    AA\n    AB\n    BB\n    BA\n    AZ\n\n    Output:\n    5 2 1 3 4\n\n    Explanation:\n    The custom comparator will compare the strings based on the rules:\n    - For odd positions (1st and 3rd character), we compare in ascending order.\n    - For even positions (2nd character), we compare in descending order.\n    - The strings are compared as follows:\n        - AA vs AB: 'A' (odd) < 'B', so AA < AB, AA comes first.\n        - AA vs BB: 'A' (odd) < 'B', so AA < BB, AA comes first.\n        - AA vs BA: 'A' (odd) < 'B', so AA < BA, AA comes first.\n        - AA vs AZ: 'A' (odd) < 'Z', so AA < AZ, AA comes first.\n        - AB vs BB: 'A' (odd) < 'B', so AB < BB, AB comes first.\n        - AB vs BA: 'A' (odd) < 'B', so AB < BA, AB comes first.\n        - AB vs AZ: 'A' (odd) < 'Z', so AB < AZ, AB comes first.\n        - BB vs BA: 'B' (odd) > 'A', so BB > BA, BA comes first.\n        - BB vs AZ: 'B' (odd) > 'A', so BB > AZ, BB comes first.\n        - BA vs AZ: 'B' (odd) > 'A', so BA > AZ, AZ comes first.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The custom comparator will naturally handle all cases, including strings of equal length but different characters, strings with all identical characters, and strings with a mix of identical and unique characters.", "- name: \nHybrid Lexicographical Sorting\n\n- content: \nThe solution involves sorting the book titles based on the custom lexicographical order defined by alternating ascending and descending character comparisons at odd and even positions, respectively.\n\n**Approach:**\n1. Read the input to get the number of books `n` and the length of each book title `m`.\n2. Store each book title as a list of characters for easier manipulation.\n3. Implement a custom comparator function that sorts the titles based on the specified hybrid order.\n4. Use Python's `sorted` function with a custom key to apply this comparator.\n5. Return the indices of the sorted titles in their original order.\n\n**Handling Edge Cases:**\n- The solution ensures that even for large values of `n` and `m`, it remains efficient by leveraging Python's built-in sorting functions.\n- The custom comparator ensures that the titles are sorted correctly according to the hybrid order.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Hybrid Lexicographical Sorting': This concept involves sorting strings based on a custom order where characters at odd positions are compared in ascending order and characters at even positions are compared in descending order.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented simultaneously as follows:\n    1. Read the input to get the number of books `n` and the length of each book title `m`.\n    2. Store each book title as a list of characters for easier manipulation.\n    3. Implement a custom comparator function that sorts the titles based on the specified hybrid order.\n    4. Use Python's `sorted` function with a custom key to apply this comparator.\n    5. Return the indices of the sorted titles in their original order.\n\n# [edge case] \n    Edge Case 1:\n    Input:\n    5 2\n    AA\n    AB\n    BB\n    BA\n    AZ\n\n    Output:\n    5 2 1 3 4\n\n    Explanation:\n    The titles are sorted based on the hybrid lexicographical order. The characters at odd positions are compared in ascending order, and the characters at even positions are compared in descending order. The sorted order is AZ, AB, AA, BA, BB, which corresponds to the indices 5, 2, 1, 3, 4.\n\n    Edge Case 2:\n    Input:\n    3 3\n    ABC\n    BCA\n    CAB\n\n    Output:\n    1 2 3\n\n    Explanation:\n    The titles are sorted based on the hybrid lexicographical order. The sorted order is ABC, BCA, CAB, which corresponds to the indices 1, 2, 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided solution is robust and handles the sorting based on the custom hybrid lexicographical order.", "- name: \nCustom Lexicographical Sorting\n\n- content: \nWe will use a custom comparator to sort the strings based on the given rules. The comparator will compare characters at each position based on whether the position is odd or even. For odd positions, we will compare characters in ascending order, and for even positions, we will compare characters in descending order. We can achieve this by implementing a custom key function for sorting.\n\nHere's the step-by-step approach:\n1. Define a custom comparator function that takes two strings and compares them based on the given rules.\n2. Use this comparator in the `sorted` function to sort the list of strings.\n3. Return the indices of the sorted strings.\n4. Ensure the function handles all edge cases, such as strings of equal length but different characters, strings with all identical characters, and strings with a mix of identical and unique characters.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'lexicographical sorting': means sorting strings based on the dictionary order of their characters.\n    'custom comparator': means a function that defines a specific order for sorting.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps 1-4 should be implement simultaneously.\n    We need to define a custom comparator function that will compare characters at each position based on whether the position is odd or even. For odd positions, we will compare characters in ascending order, and for even positions, we will compare characters in descending order. This can be achieved by using a key function in the sorted function.\n\n# [edge case] \n    Input:\n    5 2\n    AA\n    AB\n    BB\n    BA\n    AZ\n\n    Output:\n    5 2 1 3 4\n\n    Explanation:\n    The custom comparator will compare the strings based on the rules:\n    - For odd positions (1st and 3rd character), we compare in ascending order.\n    - For even positions (2nd character), we compare in descending order.\n    - The strings are compared as follows:\n        - AA vs AB: 'A' (odd) < 'B', so AA < AB, AA comes first.\n        - AA vs BB: 'A' (odd) < 'B', so AA < BB, AA comes first.\n        - AA vs BA: 'A' (odd) < 'B', so AA < BA, AA comes first.\n        - AA vs AZ: 'A' (odd) < 'Z', so AA < AZ, AA comes first.\n        - AB vs BB: 'A' (odd) < 'B', so AB < BB, AB comes first.\n        - AB vs BA: 'A' (odd) < 'B', so AB < BA, AB comes first.\n        - AB vs AZ: 'A' (odd) < 'Z', so AB < AZ, AB comes first.\n        - BB vs BA: 'B' (odd) > 'A', so BB > BA, BA comes first.\n        - BB vs AZ: 'B' (odd) > 'A', so BB > AZ, BB comes first.\n        - BA vs AZ: 'B' (odd) > 'A', so BA > AZ, AZ comes first.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The custom comparator will naturally handle all cases, including strings of equal length but different characters, strings with all identical characters, and strings with a mix of identical and unique characters."]
----------
True
----------
9
multi-gen-prompt:
 Omkar is organizing tours of his country, Omkarland! There are n cities in Omkarland, and there are exactly n-1 bidirectional roads connecting the cities to each other. It is guaranteed that you can reach any city from any other city through the road network.

Each city has an enjoyment value e. Each road has a capacity c, denoting the maximum number of vehicles that can be on it, and an associated toll t. However, the toll system in Omkarland has an interesting quirk: if a vehicle travels on multiple roads on a single journey, they pay only the highest toll

Input

The first line contains two integers n and q (2 ≤ n ≤ 2 ⋅ 10^5, 1 ≤ q ≤ 2 ⋅ 10^5), representing the number of cities and the number of groups, respectively.

The next line contains n integers e_1, e_2, …, e_n (1 ≤ e_i ≤ 10^9), where e_i represents the enjoyment value for city i.

The next n-1 lines each contain four integers a, b, c, and t (1 ≤ a,b ≤ n, 1 ≤ c ≤ 10^9, 1 ≤ t ≤ 10^9), representing an road between city a and city b with capacity c and toll t.

The next q lines each contain two integers v and x (1 ≤ v ≤ 10^9, 1 ≤ x ≤ n), representing the number of vehicles in the tour group and the starting city, respectively.

Output

Output q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.

Examples

Input


5 3
2 2 3 3 3
1 2 4 7
1 3 2 8
2 4 8 2
2 5 1 1
1 3
9 5
6 2


Output


3 8
3 0
3 2


Input


5 5
1 2 3 4 5
1 2 4 1
1 3 3 1
1 4 2 1
2 5 1 1
5 1
4 1
3 1
2 1
1 1


Output


1 0
2 1
3 1
4 1
5 1


Input


5 5
1 2 2 2 2
1 2 5 8
1 3 6 3
1 4 4 5
1 5 7 1
4 1
5 1
6 1
7 1
8 1


Output


2 8
2 8
2 3
2 1
1 0

Note

A map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.

<image>

For the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.

For the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.

For the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.

A map of the second sample is shown below:

<image>

For the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.

For the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.

For the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.

For the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.

For the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.
multi-gen-prompt:
 Omkar is hosting tours of his country, Omkarland, with n cities and n-1 bidirectional roads. Each city has an enjoyment value e, and each road has a capacity c and a toll t. Omkar will host q tour groups, each with v vehicles starting at city x. The toll paid by a vehicle is the highest toll of any road on which it travels, and the tour group aims to reach a city with the maximum enjoyment value from x. Omkar needs to determine the enjoyment value and the maximum toll per vehicle for each tour group, ensuring reimbursement regardless of the chosen destination city.

Input

The first line contains two integers n and q (2 ≤ n ≤ 2 ⋅ 10^5, 1 ≤ q ≤ 2 ⋅ 10^5), representing the number of cities and the number of groups, respectively.

The next line contains n integers e_1, e_2, …, e_n (1 ≤ e_i ≤ 10^9), where e_i represents the enjoyment value for city i.

The next n-1 lines each contain four integers a, b, c, and t (1 ≤ a,b ≤ n, 1 ≤ c ≤ 10^9, 1 ≤ t ≤ 10^9), representing an road between city a and city b with capacity c and toll t.

The next q lines each contain two integers v and x (1 ≤ v ≤ 10^9, 1 ≤ x ≤ n), representing the number of vehicles in the tour group and the starting city, respectively.

Output

Output q lines. The i-th line should contain two integers: the highest possible enjoyment value of a city reachable by the i-th tour group, and the amount of money per vehicle Omkar needs to guarantee that he can reimburse the i-th tour group.

Examples

Input


5 3
2 2 3 3 3
1 2 4 7
1 3 2 8
2 4 8 2
2 5 1 1
1 3
9 5
6 2


Output


3 8
3 0
3 2


Input


5 5
1 2 3 4 5
1 2 4 1
1 3 3 1
1 4 2 1
2 5 1 1
5 1
4 1
3 1
2 1
1 1


Output


1 0
2 1
3 1
4 1
5 1


Input


5 5
1 2 2 2 2
1 2 5 8
1 3 6 3
1 4 4 5
1 5 7 1
4 1
5 1
6 1
7 1
8 1


Output


2 8
2 8
2 3
2 1
1 0

Note

A map of the first sample is shown below. For the nodes, unbolded numbers represent indices and bolded numbers represent enjoyment values. For the edges, unbolded numbers represent capacities and bolded numbers represent tolls.

<image>

For the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.

For the second query, a tour group of size 9 starting at city 5 can reach only city 5. Thus, the largest reachable enjoyment value is still 3, and Omkar will pay 0 per vehicle.

For the third query, a tour group of size 6 starting at city 2 can reach cities 2 and 4. The largest reachable enjoyment value is again 3. If the tour group chooses to go to city 4, Omkar will have to pay 2 per vehicle, which is the maximum.

A map of the second sample is shown below:

<image>

For the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.

For the second query, a tour group of size 4 starting at city 1 can reach cities 1 and 2. Thus, their maximum enjoyment value is 2 and Omkar will pay 1 per vehicle.

For the third query, a tour group of size 3 starting at city 1 can reach cities 1, 2, and 3. Thus, their maximum enjoyment value is 3 and Omkar will pay 1 per vehicle.

For the fourth query, a tour group of size 2 starting at city 1 can reach cities 1, 2, 3 and 4. Thus, their maximum enjoyment value is 4 and Omkar will pay 1 per vehicle.

For the fifth query, a tour group of size 1 starting at city 1 can reach cities 1, 2, 3, 4, and 5. Thus, their maximum enjoyment value is 5 and Omkar will pay 1 per vehicle.
generating with deepseek-coder
----------
['import sys\nfrom collections import defaultdict, deque\n\ndef f1(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef f2(n, e, graph):\n    max_enjoyment = [0] * (n + 1)\n    max_toll = [0] * (n + 1)\n    \n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([(start, 0)])\n        visited[start] = True\n        max_enjoy = e[start - 1]\n        max_toll_val = 0\n        \n        while queue:\n            node, current_toll = queue.popleft()\n            for neighbor, capacity, toll in graph[node]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n                    max_toll_val = max(max_toll_val, toll)\n                    max_enjoy = max(max_enjoy, e[neighbor - 1])\n        \n        return max_enjoy, max_toll_val\n    \n    for i in range(1, n + 1):\n        max_enjoyment[i], max_toll[i] = bfs(i)\n    \n    return max_enjoyment, max_toll\n\nif __name__ == "__main__":\n    input_lines = sys.stdin.readlines()\n    index = 0\n    \n    n, q = map(int, input_lines[index].split())\n    index += 1\n    e = list(map(int, input_lines[index].split()))\n    index += 1\n    \n    roads = []\n    for _ in range(n - 1):\n        a, b, c, t = map(int, input_lines[index].split())\n        roads.append((a, b, c, t))\n        index += 1\n    \n    queries = []\n    for _ in range(q):\n        v, x = map(int, input_lines[index].split())\n        queries.append((v, x))\n        index += 1\n    \n    graph = f1(n, roads)\n    for v, x in queries:\n        max_enjoyment, max_toll = f2(n, e, graph)\n        reachable_max_enjoy = max(max_enjoyment[x:])\n        max_toll_per_vehicle = max(max_toll[x:]) if max_toll[x:] else 0\n        print(reachable_max_enjoy, max_toll_per_vehicle)', 'import sys\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef dfs(graph, city, capacity, tolls, enjoyment):\n    max_enjoyment = enjoyment[city - 1]\n    max_toll = 0\n    stack = [(city, float(\'inf\'))]  # (current_city, current_capacity)\n    visited = set()\n    \n    while stack:\n        current_city, current_capacity = stack.pop()\n        if current_city in visited:\n            continue\n        visited.add(current_city)\n        \n        for neighbor, c, t in graph[current_city]:\n            if c >= capacity:\n                max_toll = max(max_toll, t)\n                max_enjoyment = max(max_enjoyment, enjoyment[neighbor - 1])\n                stack.append((neighbor, c))\n    \n    return max_enjoyment, max_toll\n\ndef f1(n, roads, queries):\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    results = []\n    for v, start in queries:\n        max_enjoyment, max_toll = dfs(graph, start, v, roads, enjoyment)\n        results.append((max_enjoyment, max_toll))\n    \n    return results\n\nif __name__ == "__main__":\n    n, q = read_ints()\n    enjoyment = read_ints()\n    roads = [read_ints() for _ in range(n - 1)]\n    queries = [read_ints() for _ in range(q)]\n    \n    results = f1(n, roads, queries)\n    for result in results:\n        print(*result)', 'import sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(10**6)\n\ndef f1(n, roads, queries):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    def bfs(start, vehicles):\n        visited = [False] * (n + 1)\n        max_enjoyment = -1\n        max_toll = 0\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            city, current_toll = queue.popleft()\n            max_toll = max(max_toll, current_toll)\n            max_enjoyment = max(max_enjoyment, enjoyment[city - 1])\n            \n            for neighbor, capacity, toll in graph[city]:\n                if not visited[neighbor] and capacity >= vehicles:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for v, start in queries:\n        max_enjoyment, max_toll = bfs(start, v)\n        results.append((max_enjoyment, max_toll))\n    \n    return results\n\nif __name__ == "__main__":\n    input_data = sys.stdin.read().splitlines()\n    n, q = map(int, input_data[0].split())\n    enjoyment = list(map(int, input_data[1].split()))\n    roads = [list(map(int, line.split())) for line in input_data[2:2+n-1]]\n    queries = [list(map(int, line.split())) for line in input_data[2+n-1:]]\n    \n    results = f1(n, roads, queries)\n    for result in results:\n        print(*result)', 'import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef f1(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef f2(n, e, graph):\n    max_enjoyment = [0] * (n + 1)\n    min_toll = [0] * (n + 1)\n    \n    def dfs(city, parent):\n        max_enjoyment[city] = e[city - 1]\n        min_toll[city] = 0\n        for neighbor, capacity, toll in graph[city]:\n            if neighbor == parent:\n                continue\n            dfs(neighbor, city)\n            if max_enjoyment[neighbor] > max_enjoyment[city]:\n                max_enjoyment[city] = max_enjoyment[neighbor]\n                min_toll[city] = toll\n            elif max_enjoyment[neighbor] == max_enjoyment[city] and toll > min_toll[city]:\n                min_toll[city] = toll\n    \n    dfs(1, -1)\n    return max_enjoyment, min_toll\n\ndef f3(q, max_enjoyment, min_toll):\n    results = []\n    for _ in range(q):\n        v, x = map(int, sys.stdin.readline().split())\n        results.append((max_enjoyment[x], min_toll[x]))\n    return results\n\nif __name__ == "__main__":\n    n, q = map(int, sys.stdin.readline().split())\n    e = list(map(int, sys.stdin.readline().split()))\n    roads = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n    graph = f1(n, roads)\n    max_enjoyment, min_toll = f2(n, e, graph)\n    results = f3(q, max_enjoyment, min_toll)\n    for result in results:\n        print(*result)', 'import sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(10**6)\n\ndef f1(n, roads):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    return graph\n\ndef f2(n, e, graph):\n    max_enjoyment = [0] * (n + 1)\n    min_toll = [float(\'inf\')] * (n + 1)\n    \n    def dfs(city, parent):\n        max_enjoyment[city] = e[city - 1]\n        min_toll[city] = float(\'inf\')\n        for neighbor, capacity, toll in graph[city]:\n            if neighbor == parent:\n                continue\n            dfs(neighbor, city)\n            if max_enjoyment[neighbor] > max_enjoyment[city]:\n                max_enjoyment[city] = max_enjoyment[neighbor]\n                min_toll[city] = min_toll[neighbor]\n            elif max_enjoyment[neighbor] == max_enjoyment[city] and min_toll[neighbor] < min_toll[city]:\n                min_toll[city] = min_toll[neighbor]\n        if min_toll[city] == float(\'inf\'):\n            min_toll[city] = toll\n        else:\n            min_toll[city] = max(min_toll[city], toll)\n    \n    dfs(1, -1)\n    return max_enjoyment, min_toll\n\ndef f3(q, max_enjoyment, min_toll):\n    results = []\n    for _ in range(q):\n        v, x = map(int, sys.stdin.readline().split())\n        results.append((max_enjoyment[x], min_toll[x]))\n    return results\n\nif __name__ == "__main__":\n    n, q = map(int, sys.stdin.readline().split())\n    e = list(map(int, sys.stdin.readline().split()))\n    roads = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n    graph = f1(n, roads)\n    max_enjoyment, min_toll = f2(n, e, graph)\n    results = f3(q, max_enjoyment, min_toll)\n    for result in results:\n        print(*result)', 'import sys\nfrom collections import defaultdict, deque\n\ndef f1(n, q, e, roads, queries):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    def bfs(start):\n        max_enjoyment = [0] * (n + 1)\n        max_toll = [0] * (n + 1)\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        max_enjoyment[start] = e[start - 1]\n        \n        while queue:\n            city = queue.popleft()\n            for neighbor, capacity, toll in graph[city]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    max_enjoyment[neighbor] = max(max_enjoyment[city], e[neighbor - 1])\n                    max_toll[neighbor] = max(max_toll[city], toll)\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for v, x in queries:\n        max_enjoyment, max_toll = bfs(x)\n        reimbursement = max_toll[1:]\n        enjoyment = max_enjoyment[1:]\n        results.append((max(enjoyment), max(reimbursement)))\n    \n    return results\n\nif __name__ == "__main__":\n    input_lines = sys.stdin.readlines()\n    n, q = map(int, input_lines[0].split())\n    e = list(map(int, input_lines[1].split()))\n    roads = [tuple(map(int, line.split())) for line in input_lines[2:n]]\n    queries = [tuple(map(int, line.split())) for line in input_lines[n+1:]]\n    \n    results = f1(n, q, e, roads, queries)\n    \n    for max_enjoyment, max_toll in results:\n        print(max_enjoyment, max_toll)', 'import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(node, parent, graph, enjoyment, max_enjoyment, min_toll):\n    max_enjoyment[node] = enjoyment[node - 1]\n    min_toll[node] = float(\'inf\')\n    \n    for child, capacity, toll in graph[node]:\n        if child == parent:\n            continue\n        dfs(child, node, graph, enjoyment, max_enjoyment, min_toll)\n        max_enjoyment[node] = max(max_enjoyment[node], max_enjoyment[child])\n        min_toll[node] = min(min_toll[node], toll)\n\ndef main():\n    n, q = map(int, input().split())\n    enjoyment = list(map(int, input().split()))\n    \n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a, b, c, t = map(int, input().split())\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    for _ in range(q):\n        v, x = map(int, input().split())\n        max_enjoyment = [0] * (n + 1)\n        min_toll = [0] * (n + 1)\n        dfs(x, -1, graph, enjoyment, max_enjoyment, min_toll)\n        max_enjoyment_value = max_enjoyment[x]\n        toll_per_vehicle = min_toll[x]\n        print(max_enjoyment_value, toll_per_vehicle)\n\nif __name__ == "__main__":\n    main()', 'import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(city, parent, graph, enjoyment):\n    max_enjoyment = enjoyment[city - 1]\n    max_toll = 0\n    for neighbor, capacity, toll in graph[city]:\n        if neighbor != parent:\n            neighbor_max_enjoyment, neighbor_max_toll = dfs(neighbor, city, graph, enjoyment)\n            if neighbor_max_enjoyment > max_enjoyment:\n                max_enjoyment = neighbor_max_enjoyment\n                max_toll = toll\n            elif neighbor_max_enjoyment == max_enjoyment:\n                max_toll = max(max_toll, toll)\n    return max_enjoyment, max_toll\n\ndef main():\n    n, q = map(int, input().split())\n    enjoyment = list(map(int, input().split()))\n    \n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a, b, c, t = map(int, input().split())\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    results = []\n    for _ in range(q):\n        v, x = map(int, input().split())\n        max_enjoyment, max_toll = dfs(x, -1, graph, enjoyment)\n        results.append((max_enjoyment, max_toll))\n    \n    for result in results:\n        print(*result)\n\nif __name__ == "__main__":\n    main()', 'from collections import defaultdict, deque\nimport sys\n\ndef f1(n, q, enjoyment_values, roads, tour_groups):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    def bfs(start):\n        visited = [False] * (n + 1)\n        max_toll = [0] * (n + 1)\n        max_enjoyment = [-1] * (n + 1)\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            city, current_toll = queue.popleft()\n            max_toll[city] = current_toll\n            max_enjoyment[city] = enjoyment_values[city - 1]\n            \n            for neighbor, capacity, toll in graph[city]:\n                if not visited[neighbor] and capacity >= v:\n                    visited[neighbor] = True\n                    queue.append((neighbor, max(current_toll, toll)))\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for v, start in tour_groups:\n        max_enjoyment, max_toll = bfs(start)\n        max_enjoy = max(max_enjoyment)\n        if max_enjoy == -1:\n            results.append((0, 0))\n        else:\n            max_toll_per_vehicle = max(max_toll[i] for i in range(1, n + 1) if max_enjoyment[i] == max_enjoy)\n            results.append((max_enjoy, max_toll_per_vehicle))\n    \n    return results\n\nif __name__ == "__main__":\n    input_data = sys.stdin.read().splitlines()\n    n, q = map(int, input_data[0].split())\n    enjoyment_values = list(map(int, input_data[1].split()))\n    roads = [list(map(int, line.split())) for line in input_data[2:2+n-1]]\n    tour_groups = [list(map(int, line.split())) for line in input_data[2+n-1:]]\n    \n    results = f1(n, q, enjoyment_values, roads, tour_groups)\n    \n    for result in results:\n        print(*result)', 'import sys\nfrom collections import defaultdict, deque\n\ndef f1(n, q, e, roads, queries):\n    graph = defaultdict(list)\n    for a, b, c, t in roads:\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n    \n    def bfs(start):\n        max_enjoyment = [0] * (n + 1)\n        max_toll = [0] * (n + 1)\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        max_enjoyment[start] = e[start - 1]\n        \n        while queue:\n            city = queue.popleft()\n            for neighbor, capacity, toll in graph[city]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    max_enjoyment[neighbor] = max(max_enjoyment[city], e[neighbor - 1])\n                    max_toll[neighbor] = max(max_toll[city], toll)\n        \n        return max_enjoyment, max_toll\n    \n    results = []\n    for v, x in queries:\n        max_enjoyment, max_toll = bfs(x)\n        reimbursement = max_toll[1:]\n        enjoyment = max_enjoyment[1:]\n        results.append((max(enjoyment), max(reimbursement)))\n    \n    return results\n\nif __name__ == "__main__":\n    input_lines = sys.stdin.readlines()\n    n, q = map(int, input_lines[0].split())\n    e = list(map(int, input_lines[1].split()))\n    roads = [tuple(map(int, line.split())) for line in input_lines[2:n]]\n    queries = [tuple(map(int, line.split())) for line in input_lines[n+1:]]\n    \n    results = f1(n, q, e, roads, queries)\n    \n    for max_enjoyment, max_toll in results:\n        print(max_enjoyment, max_toll)']
----------
["- name: \nGraph Traversal and Maximum Enjoyment Value\n- content: \nTo solve this problem, we can break it down into several steps:\n\n1. **Graph Representation**: Represent the cities and roads as a tree where each node has an associated enjoyment value.\n2. **Road Filtering**: For each tour group, filter the roads that can be traversed based on the vehicle capacity.\n3. **Depth-First Search (DFS)**: Use DFS to traverse the graph and find the maximum enjoyment value city reachable from the starting city.\n4. **Calculate Toll Cost**: For each tour group, calculate the maximum toll cost per vehicle by finding the highest toll among the traversed roads.\n5. **Output Results**: For each tour group, output the maximum enjoyment value and the toll cost per vehicle.\n\n**Algorithm**:\n- For each tour group, starting from the given city, use DFS to traverse the graph.\n- Track the maximum enjoyment value encountered during the traversal.\n- Calculate the highest toll cost by finding the maximum toll among the traversed roads.\n- Output the results.\n\n**Edge Cases**:\n- Handle cases where no roads can be traversed due to vehicle capacity.\n- Handle cases where multiple cities have the same maximum enjoyment value, allowing for a choice between them.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph Traversal': The process of exploring nodes and edges in a graph to find a path or determine the connectivity of the graph.\n    'Depth-First Search (DFS)': A graph traversal algorithm that explores as far as possible along each branch before backtracking.\n    'Maximum Enjoyment Value': The highest enjoyment value of a city that can be reached from a given starting city by the tour group.\n    'Toll Cost': The maximum toll among the roads traversed by the tour group, which is the cost per vehicle.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the vehicle capacity must be greater than or equal to the specified value.\n    Explanation: For each tour group, the vehicle capacity (v) must be greater than or equal to the capacity of the roads they will traverse.\n    Implementation: Filter roads based on the vehicle capacity before performing DFS.\n\n# [degree adverb] \n    'highest': Indicates the maximum value among a set of values.\n    Explanation: The highest toll among the roads traversed by the tour group determines the toll cost per vehicle.\n    Implementation: Track the maximum toll encountered during DFS traversal to calculate the toll cost.\n\n# [code logic]\n    The steps should be implemented sequentially:\n    1. Represent the cities and roads as a tree.\n    2. Filter roads based on the vehicle capacity.\n    3. Use DFS to traverse the graph and find the maximum enjoyment value city.\n    4. Calculate the highest toll cost per vehicle.\n    5. Output the results.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'Graph Traversal': The process of exploring nodes and edges in a graph to find a path or determine the connectivity of the graph.\n    'Depth-First Search (DFS)': A graph traversal algorithm that explores as far as possible along each branch before backtracking.\n    'Maximum Enjoyment Value': The highest enjoyment value of a city that can be reached from a given starting city by the tour group.\n    'Toll Cost': The maximum toll among the roads traversed by the tour group, which is the cost per vehicle.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the vehicle capacity must be greater than or equal to the specified value.\n    Explanation: For each tour group, the vehicle capacity (v) must be greater than or equal to the capacity of the roads they will traverse.\n    Implementation: Filter roads based on the vehicle capacity before performing DFS.\n\n# [degree adverb] \n    'highest': Indicates the maximum value among a set of values.\n    Explanation: The highest toll among the roads traversed by the tour group determines the toll cost per vehicle.\n    Implementation: Track the maximum toll encountered during DFS traversal to calculate the toll cost.\n\n# [code logic]\n    The steps should be implemented sequentially:\n    1. Represent the cities and roads as a tree.\n    2. Filter roads based on the vehicle capacity.\n    3. Use DFS to traverse the graph and find the maximum enjoyment value city.\n    4. Calculate the highest toll cost per vehicle.\n    5. Output the results.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)", "- name: \nGreedy Algorithm with Priority Queue\n\n- content: \nAnother approach involves using a greedy algorithm combined with a priority queue:\n1. **Graph Representation**: Represent the graph as an adjacency list.\n2. **Priority Queue for Maximum Tolls**: Use a priority queue to always expand the path with the maximum toll encountered so far.\n3. **DFS/BFS for Pathfinding**: Use DFS or BFS to traverse the graph while keeping track of the current toll and path length.\n4. **Enjoyment Value Calculation**: Calculate the enjoyment value for each reachable city and store it along with the toll cost.\n5. **Query Processing**: For each query, use the priority queue to find the maximum enjoyment value and associated toll cost.\n6. **Edge Case Handling**: Handle cases where no paths are available due to insufficient road capacity by checking the priority queue size before processing each query.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph Representation': The core concept here is representing the cities and roads as a graph, where cities are nodes and roads are edges.\n    'Priority Queue': This is used to efficiently find the path with the maximum toll encountered so far.\n    'DFS/BFS': These are used for traversing the graph to find the shortest paths.\n    'Enjoyment Value': This is the value associated with each city that determines the fun level for the tour groups.\n    'Toll Cost': This is the cost associated with each road that needs to be considered while calculating the total cost for the tour groups.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that the road capacity must be greater than or equal to the number of vehicles in the tour group.\n    Explanation: In the code, we need to ensure that the capacity of the road is at least as large as the number of vehicles in the tour group.\n    Implementation: Use a condition to check if the capacity of the road is greater than or equal to the number of vehicles.\n\n# [degree adverb]\n    'largest': This adverb indicates that we need to find the city with the highest enjoyment value that is reachable from the starting city.\n    Explanation: We need to find the city with the maximum enjoyment value that can be reached from the given starting city.\n    Implementation: Use a priority queue to always expand the path with the maximum enjoyment value encountered so far.\n\n# [code logic]\n    The steps should be implemented sequentially as follows:\n    1. Represent the graph as an adjacency list.\n    2. Use a priority queue to always expand the path with the maximum enjoyment value encountered so far.\n    3. Use DFS or BFS to traverse the graph while keeping track of the current enjoyment value and path length.\n    4. Calculate the enjoyment value for each reachable city and store it along with the toll cost.\n    5. For each query, use the priority queue to find the maximum enjoyment value and associated toll cost.\n    6. Handle cases where no paths are available due to insufficient road capacity by checking the priority queue size before processing each query.\n\n# [edge case]\n    Edge Case 1: Tour group with 1 vehicle starting at city 1\n    Expected Output: 5, 0\n    Explanation: The tour group can reach city 5 with an enjoyment value of 5, and no toll needs to be paid since the capacity is 1.\n\n    Edge Case 2: Tour group with 10 vehicles starting at city 1\n    Expected Output: -1, -1\n    Explanation: There is no road with a capacity of at least 10, so the tour group cannot travel to any city.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where no paths are available due to insufficient road capacity.\n    Implementation: Check the priority queue size before processing each query to ensure there are available paths.\n\n    ```python\n    if not priority_queue:\n        return -1, -1\n    ```", "- name: \nGraph Traversal and Data Structure Optimization\n\n- content: \nTo solve this problem, we can use a combination of graph traversal techniques and data structure optimizations. The goal is to efficiently find the maximum enjoyment value and the associated toll cost for each tour group.\n\n1. **Graph Representation**: Represent the cities and roads as a graph where each city is a node and each road is an edge. Use an adjacency list to store the graph.\n\n2. **DFS/BFS for Reachability**: Use Depth-First Search (DFS) or Breadth-First Search (BFS) to determine the reachable cities from a given starting city. During the traversal, keep track of the maximum enjoyment value and the highest toll encountered.\n\n3. **Data Structures**: Use a priority queue (max-heap) to efficiently find the highest toll encountered when multiple roads are traversed.\n\n4. **Implementation**:\n   - Traverse the graph starting from the given city.\n   - For each city, update the maximum enjoyment value and the highest toll encountered.\n   - Store the results for each tour group.\n\nThis approach ensures that we efficiently explore the graph and find the required values for each tour group. It handles large inputs efficiently by leveraging graph traversal and priority queues.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph Traversal': The core concept is to traverse a graph to find the maximum enjoyment value and the associated toll cost for each tour group.\n    Explanation: In this problem, we need to determine the cities that can be reached from a given starting city and calculate the maximum enjoyment value and the highest toll cost for a tour group visiting these cities.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    - Traverse the graph starting from the given city.\n    - For each city, update the maximum enjoyment value and the highest toll encountered.\n    - Store the results for each tour group.\n    These steps can be combined into a single function that performs a depth-first search (DFS) or breadth-first search (BFS) to explore the graph and calculate the required values.\n\n# [edge case] \n    Edge Case 1:\n    Input: n = 5, q = 3, cities = [2, 2, 3, 3, 3], roads = [(1, 2, 4, 7), (1, 3, 2, 8), (2, 4, 8, 2), (2, 5, 1, 1)], tour_groups = [(1, 3), (9, 5), (6, 2)]\n    Expected Output: 3 8\n    Explanation:\n    - A tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. The largest enjoyment value is 3. The highest toll is 8.\n\n    Edge Case 2:\n    Input: n = 5, q = 5, cities = [1, 2, 3, 4, 5], roads = [(1, 2, 4, 1), (1, 3, 3, 1), (1, 4, 2, 1), (2, 5, 1, 1)], tour_groups = [(5, 1), (4, 1), (3, 1), (2, 1), (1, 1)]\n    Expected Output: 1 0\n    Explanation:\n    - A tour group of size 5 starting at city 1 can only reach city 1. The largest enjoyment value is 1. The cost per vehicle is 0.\n\n    Edge Case 3:\n    Input: n = 5, q = 5, cities = [1, 2, 2, 2, 2], roads = [(1, 2, 5, 8), (1, 3, 6, 3), (1, 4, 4, 5), (1, 5, 7, 1)], tour_groups = [(4, 1), (5, 1), (6, 1), (7, 1), (8, 1)]\n    Expected Output: 2 8\n    Explanation:\n    - A tour group of size 4 starting at city 1 can reach cities 1 and 2. The largest enjoyment value is 2. The highest toll is 8.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic can handle the edge cases by considering the maximum enjoyment value and the highest toll encountered during the traversal.", '- name: \nDynamic Programming with Path Information\n\n- content: \nAnother approach to solve this problem is to use Dynamic Programming (DP) to efficiently compute the maximum enjoyment value and the highest toll for each city reachable from the starting city. We can use a DP table to store the results of subproblems and build up to the final solution. Here’s the step-by-step approach:\n\n1. **Graph Representation**: Represent the cities and roads as an adjacency list.\n2. **DP Initialization**: Initialize a DP table to store the maximum enjoyment value and the highest toll for each city and up to a given number of vehicles.\n3. **DP Transition**: Use a bottom-up approach to fill the DP table by considering the transitions between cities and updating the maximum enjoyment value and highest toll.\n4. **Output Calculation**: For each tour group, output the maximum enjoyment value and the cost per vehicle based on the highest toll encountered.\n\n**Algorithm**:\n- Initialize an adjacency list to represent the graph.\n- Initialize a DP table with dimensions `(n+1) x (max_vehicles+1)` to store the maximum enjoyment value and highest toll for each city and up to a given number of vehicles.\n- Use a nested loop to iterate over cities and vehicles, updating the DP table with the maximum enjoyment value and highest toll for each reachable city.\n- Output the results after processing each tour group.\n\n**Edge Cases**:\n- Ensure that the graph is connected (though guaranteed by the problem statement).\n- Handle cases where all cities have the same enjoyment value or all roads have the same toll.\n- Consider large inputs efficiently using DP with memoization or tabulation.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'Graph\': A collection of nodes (cities) and edges (roads) connecting them.\n    Explanation: In this problem, we are dealing with a graph where cities are nodes and roads are edges. Each road has a capacity and a toll, and we need to find the maximum enjoyment value reachable from a given city for a tour group.\n\n# [phrase showing quantity relationship]\n    \'more than\': Indicates that the capacity of the road must be greater than the number of vehicles in the tour group.\n    Explanation: For a road to be used, its capacity must be greater than the number of vehicles in the tour group. This ensures that the road can handle the tour group.\n\n# [degree adverb] \n    \'highest\': Indicates that we need to find the maximum toll encountered on the path from the starting city to the destination city.\n    Explanation: The highest toll is the maximum value of toll among all the roads used on the path from the starting city to the destination city. This is important because the tour group must pay the highest toll encountered.\n\n# [code logic]\n    Steps 2-4 should be considered simultaneously.\n    "Initialize an adjacency list to represent the graph."\n    "Initialize a DP table with dimensions (n+1) x (max_vehicles+1) to store the maximum enjoyment value and highest toll for each city and up to a given number of vehicles."\n    "Use a nested loop to iterate over cities and vehicles, updating the DP table with the maximum enjoyment value and highest toll for each reachable city."\n    This could be done by creating a graph using an adjacency list, initializing a DP table to store the results, and then iterating over the cities and vehicles to update the DP table with the maximum enjoyment value and highest toll.\n\n# [edge case] \n    Edge case 1: search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The input list has the number 3 appearing three times, which is more than its value. Therefore, the output is 3.\n    Edge case 2: search([5, 5, 4, 4, 4]) = -1\n    Explanation: The number 5 appears twice, which is more than its value, but the number 4 appears three times, which is also more than its value. Since there is no single number that appears more than its value, the output is -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases where all numbers appear the same number of times as their value.\n\n# [core concept]\n    \'Dynamic Programming\': A method for solving complex problems by breaking them down into simpler subproblems.\n    Explanation: In this problem, we use dynamic programming to efficiently compute the maximum enjoyment value and the highest toll for each city reachable from the starting city. This is done by initializing a DP table and updating it with the results of subproblems.\n\n# [phrase showing quantity relationship]\n    \'exactly n-1\': Indicates that there are exactly n-1 bidirectional roads in the graph.\n    Explanation: This is a given condition in the problem statement, ensuring that there is a path between any two cities in the graph.\n\n# [degree adverb] \n    \'bidirectional\': Indicates that each road connects two cities and can be traveled in both directions.\n    Explanation: This is a key characteristic of the roads in the graph, allowing for traversal between any two connected cities.\n\n# [code logic]\n    Steps 1-4 should be considered simultaneously.\n    "Initialize an adjacency list to represent the graph."\n    "Initialize a DP table with dimensions (n+1) x (max_vehicles+1) to store the maximum enjoyment value and highest toll for each city and up to a given number of vehicles."\n    "Use a nested loop to iterate over cities and vehicles, updating the DP table with the maximum enjoyment value and highest toll for each reachable city."\n    This could be done by creating a graph using an adjacency list, initializing a DP table to store the results, and then iterating over the cities and vehicles to update the DP table with the maximum enjoyment value and highest toll.\n\n# [edge case] \n    Edge case 1: search([2,2,3,3,3]) = 3\n    Explanation: The input list has the number 2 and 3 appearing three times, which is more than their values. Since 3 is the largest number that appears more than its value, the output is 3.\n    Edge case 2: search([3,3,2,4,4,4]) = -1\n    Explanation: None of the numbers appear more than their value, so the output is -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases where no number appears more than its value.', "- name: \nDepth-First Search (DFS) with Memoization\n\n- content: \nAnother approach is to use depth-first search (DFS) with memoization to explore all possible paths from the starting city.\n1. Build the graph using the given roads and capacities.\n2. For each tour group, perform a DFS starting from the given city.\n3. Use memoization to store the results of subproblems to avoid redundant calculations.\n4. Track the maximum enjoyment value and the highest toll encountered on the path to each reachable city.\n5. Output the highest enjoyment value and the cost per vehicle for each tour group.\n\nWe can use a dictionary to store the graph and memoization to optimize the DFS process.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph': The problem involves a network of cities connected by roads, where each road has a capacity and a toll. The goal is to find the maximum enjoyment value reachable from a given city and the associated cost per vehicle.\n    Explanation: In this context, a graph is a collection of nodes (cities) and edges (roads) where each edge has a weight (capacity and toll). The core concept here is to traverse this graph to find the best path based on given constraints.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be exceeded.\n    'at least as many times': Indicates a minimum frequency requirement.\n\n# [degree adverb] \n    'largest': Indicates the maximum value to be found.\n\n# [code logic]\n    The plan suggests using Depth-First Search (DFS) with memoization to explore all possible paths from the starting city. This approach involves:\n    1. Building the graph using the given roads and capacities.\n    2. Performing a DFS starting from the given city.\n    3. Using memoization to store results of subproblems.\n    4. Tracking the maximum enjoyment value and the highest toll encountered.\n    5. Outputting the results for each tour group.\n\n# [edge case] \n    Edge Case 1:\n    Input: search([1, 2, 2, 3, 3, 3, 4, 4, 4])\n    Expected Output: 3\n    Explanation: The number 3 appears at least 3 times, which is more than its value. Therefore, the largest integer that meets the condition is 3.\n\n    Edge Case 2:\n    Input: search([5, 5, 4, 4, 4])\n    Expected Output: -1\n    Explanation: No integer appears more than or equal to its value. Therefore, the function should return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases in this context, as the core logic of the problem can naturally handle cases where no integer meets the condition.", "- name: \nCentroid Decomposition and Dynamic Programming\n\n- content: \nThis solution involves decomposing the graph into centroid trees and using dynamic programming to efficiently find solutions for each tour group. Here's a high-level plan:\n\n1. **Centroid Decomposition**: Decompose the graph into centroid trees, which simplifies the problem by breaking it down into smaller subproblems.\n2. **Dynamic Programming**: Use dynamic programming to store and update information about the maximum enjoyment value and toll for each subtree in the centroid tree.\n3. **DFS Traversal**: Perform DFS traversals on the centroid tree to aggregate results from subproblems.\n4. **Output**: For each tour group, output the maximum enjoyment value reachable and the corresponding toll per vehicle based on dynamic programming results.\n\n**Algorithm**:\n- For each tour group starting at city `x` with `v` vehicles:\n  1. Decompose the graph into centroid trees.\n  2. Use dynamic programming to store results for each subtree in the centroid tree.\n  3. Perform DFS traversals on the centroid tree to aggregate results and calculate the final maximum enjoyment value and toll.\n  4. Output the results for each tour group.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Centroid Decomposition': This is a tree decomposition technique that breaks down a tree into smaller trees (centroids) to simplify the problem of finding the shortest path or maximum enjoyment value.\n    Explanation: Centroid decomposition is used to reduce the complexity of the graph by breaking it down into smaller, more manageable pieces. Each centroid represents a potential center of the graph, and the tree formed by these centroids helps in solving problems more efficiently.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented as described. Centroid decomposition and dynamic programming should be applied to efficiently find the solution for each tour group.\n\n# [edge case] \n    Edge Case 1:\n    Input: 5 3\n    2 2 3 3 3\n    1 2 4 7\n    1 3 2 8\n    2 4 8 2\n    2 5 1 1\n    1 3\n    9 5\n    6 2\n\n    Expected Output: 3 8\n    Explanation: For the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\n    Edge Case 2:\n    Input: 5 5\n    1 2 3 4 5\n    1 2 4 1\n    1 3 3 1\n    1 4 2 1\n    2 5 1 1\n    5 1\n    4 1\n    3 1\n    2 1\n    1 1\n\n    Expected Output: 1 0\n    Explanation: For the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can be used to find the maximum enjoyment value and the corresponding toll per vehicle based on dynamic programming results.", "- name: \nGraph Traversal and Maximum Enjoyment Calculation\n\n- content: \nTo solve this problem, we can break it down into several steps:\n1. Construct the graph from the given roads.\n2. For each tour group, perform a depth-first search (DFS) or breadth-first search (BFS) starting from the given city to find the farthest city in terms of enjoyment value.\n3. Track the maximum toll encountered during the traversal.\n4. Calculate the total reimbursement cost based on the maximum toll and the number of vehicles.\n5. Output the highest enjoyment value and the reimbursement cost for each tour group.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph Traversal': The process of exploring nodes and edges in a graph to find a path or determine the connectivity of the graph.\n    'Depth-First Search (DFS)': A search algorithm that explores as far as possible along each branch before backtracking.\n    'Breadth-First Search (BFS)': A search algorithm that explores all the neighbors of a node before moving on to the next level of nodes.\n    'Maximum Enjoyment': The highest enjoyment value of a city that can be reached from a given starting city by the tour group.\n    'Toll': The cost associated with traveling on a road, which is the highest toll encountered during the traversal.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that the number of vehicles is greater than a certain value.\n    'at least as many times': Indicates that the number of vehicles is at least as many as the value specified.\n\n# [degree adverb] \n    'largest': Indicates the highest or greatest value in the context of enjoyment values or tolls.\n\n# [code logic]\n    The steps should be implemented sequentially as follows:\n    1. Construct the graph from the given roads.\n    2. For each tour group, perform a DFS or BFS starting from the given city to find the farthest city in terms of enjoyment value.\n    3. Track the maximum toll encountered during the traversal.\n    4. Calculate the total reimbursement cost based on the maximum toll and the number of vehicles.\n    5. Output the highest enjoyment value and the reimbursement cost for each tour group.\n\n# [edge case] \n    Edge Case 1:\n    Input: \n    5 3\n    2 2 3 3 3\n    1 2 4 7\n    1 3 2 8\n    2 4 8 2\n    2 5 1 1\n    1 3\n    9 5\n    6 2\n\n    Output:\n    3 8\n    Explanation:\n    For the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\n    Edge Case 2:\n    Input:\n    5 5\n    1 2 3 4 5\n    1 2 4 1\n    1 3 3 1\n    1 4 2 1\n    2 5 1 1\n    5 1\n    4 1\n    3 1\n    2 1\n    1 1\n\n    Output:\n    1 0\n    Explanation:\n    For the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic should be sufficient to solve the problem as described.", "- name: \nGraph Traversal and Maximum Enjoyment Calculation\n\n- content: \nTo solve this problem, we can break it down into the following steps:\n1. **Build the Graph**: Create an adjacency list to represent the cities and roads.\n2. **Depth-First Search (DFS)**: Use DFS to find the farthest city from each starting city in terms of enjoyment value.\n3. **Calculate Maximum Tolls**: For each tour group, calculate the maximum toll they will have to pay per vehicle.\n4. **Output Results**: For each query, output the maximum enjoyment value and the toll per vehicle.\n\n**Algorithm**:\n- For each tour group starting at city \\( x \\), perform a DFS to find the farthest city \\( y \\) with the maximum enjoyment value.\n- Calculate the maximum toll along the path from \\( x \\) to \\( y \\).\n- Output the highest enjoyment value and the maximum toll for each tour group.\n\n**Edge Cases**:\n- Handle cases where there's only one city or no paths from the starting city.\n- Ensure the algorithm can handle large graphs efficiently.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph Traversal': The process of exploring nodes and edges in a graph to find a path or determine the connectivity of the graph.\n    'Depth-First Search (DFS)': A graph traversal algorithm that explores as far as possible along each branch before backtracking.\n    'Maximum Enjoyment': The highest enjoyment value of a city that can be reached from a given starting city by a tour group.\n    'Toll Calculation': The highest toll encountered on any road traveled from the starting city to the destination city.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than a specified amount.\n    'at least as many times': Indicates that a value must appear at least a specified number of times.\n\n# [degree adverb] \n    'largest': Indicates the maximum or highest value sought.\n\n# [code logic]\n    The steps should be implemented sequentially:\n    1. Build the graph using the adjacency list.\n    2. Perform DFS from the starting city to find the farthest city with the maximum enjoyment value.\n    3. Calculate the maximum toll along the path from the starting city to the farthest city.\n    4. Output the results for each tour group.\n\n# [edge case] \n    Edge Case 1:\n    Input: \n    1 1\n    10\n    1 2 1 1\n    1 1\n    Output:\n    10 1\n    Explanation:\n    There is only one city and one road, so the tour group can only reach city 1, which has the enjoyment value of 10. The only road has a toll of 1, so the maximum toll per vehicle is 1.\n\n    Edge Case 2:\n    Input:\n    2 1\n    1 2\n    1 2 1 1\n    1 1\n    Output:\n    2 1\n    Explanation:\n    There are two cities and one road. The tour group can reach either city 1 or city 2, both with an enjoyment value of 1. The road has a toll of 1, so the maximum toll per vehicle is 1.\n\n    Edge Case 3:\n    Input:\n    3 1\n    1 2 3\n    1 2 1 1\n    2 3 1 2\n    1 1\n    Output:\n    3 2\n    Explanation:\n    There are three cities and two roads. The tour group can reach city 3, which has the highest enjoyment value of 3. The road from city 1 to city 2 has a toll of 1, and the road from city 2 to city 3 has a toll of 2. The maximum toll per vehicle is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the provided logic can handle cases with a single city or a direct path between cities.", "- name: \nGraph Construction and Shortest Path Analysis\n\n- content: \nTo solve this problem, we can follow these steps:\n1. Construct a graph representation from the given cities and roads.\n2. Use a Breadth-First Search (BFS) algorithm to find the shortest path from the starting city to all other cities, considering the road capacity.\n3. For each tour group, determine the maximum enjoyment value reachable from the starting city and calculate the maximum toll paid per vehicle.\n4. In case of multiple cities with the same enjoyment value, allow the tour group to choose the one they prefer.\n5. Ensure that the solution handles edge cases such as a single city or all roads having the same capacity and toll.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph Construction': Understanding the relationship between cities and roads.\n    'Shortest Path Analysis': Finding the shortest path between cities considering road capacities.\n    'Breadth-First Search (BFS)': Algorithm to explore all nodes at the present depth prior to moving on to the nodes at the next depth level.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates the minimum capacity required for a tour group to travel on a road.\n    Explanation: For example, if a road has a capacity of 4 and a tour group has 5 vehicles, they can travel on this road.\n    Implementation: Use a condition to check if the vehicle capacity is less than or equal to the road capacity.\n\n# [degree adverb] \n    'largest': Indicates the maximum enjoyment value to be found.\n    Explanation: This means we need to find the city with the highest enjoyment value that is reachable from the starting city.\n    Implementation: Traverse the graph to find the city with the highest enjoyment value.\n\n# [code logic]\n    The steps should be implemented sequentially as follows:\n    1. Construct the graph using the given cities and roads.\n    2. Use BFS to find the shortest path from the starting city to all other cities, considering road capacities.\n    3. For each tour group, determine the maximum enjoyment value reachable and calculate the maximum toll paid per vehicle.\n    4. Handle edge cases where multiple cities have the same enjoyment value.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'Graph Construction': Understanding the relationship between cities and roads.\n    'Shortest Path Analysis': Finding the shortest path between cities considering road capacities.\n    'Breadth-First Search (BFS)': Algorithm to explore all nodes at the present depth prior to moving on to the nodes at the next depth level.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates the minimum capacity required for a tour group to travel on a road.\n    Explanation: For example, if a road has a capacity of 4 and a tour group has 5 vehicles, they can travel on this road.\n    Implementation: Use a condition to check if the vehicle capacity is less than or equal to the road capacity.\n\n# [degree adverb] \n    'largest': Indicates the maximum enjoyment value to be found.\n    Explanation: This means we need to find the city with the highest enjoyment value that is reachable from the starting city.\n    Implementation: Traverse the graph to find the city with the highest enjoyment value.\n\n# [code logic]\n    The steps should be implemented sequentially as follows:\n    1. Construct the graph using the given cities and roads.\n    2. Use BFS to find the shortest path from the starting city to all other cities, considering road capacities.\n    3. For each tour group, determine the maximum enjoyment value reachable and calculate the maximum toll paid per vehicle.\n    4. Handle edge cases where multiple cities have the same enjoyment value.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)", "- name: \nCentroid Decomposition and Dynamic Programming\n\n- content: \nThis solution involves decomposing the graph into centroid trees and using dynamic programming to efficiently find solutions for each tour group. Here's a high-level plan:\n\n1. **Centroid Decomposition**: Decompose the graph into centroid trees, which simplifies the problem by breaking it down into smaller subproblems.\n2. **Dynamic Programming**: Use dynamic programming to store and update information about the maximum enjoyment value and toll for each subtree in the centroid tree.\n3. **DFS Traversal**: Perform DFS traversals on the centroid tree to aggregate results from subproblems.\n4. **Output**: For each tour group, output the maximum enjoyment value reachable and the corresponding toll per vehicle based on dynamic programming results.\n\n**Algorithm**:\n- For each tour group starting at city `x` with `v` vehicles:\n  1. Decompose the graph into centroid trees.\n  2. Use dynamic programming to store results for each subtree in the centroid tree.\n  3. Perform DFS traversals on the centroid tree to aggregate results and calculate the final maximum enjoyment value and toll.\n  4. Output the results for each tour group.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Centroid Decomposition': This is a tree decomposition technique that breaks down a tree into smaller trees (centroids) to simplify the problem of finding the shortest path or maximum enjoyment value.\n    Explanation: Centroid decomposition is used to reduce the complexity of the graph by breaking it down into smaller, more manageable pieces. Each centroid represents a potential center of the graph, and the tree formed by these centroids helps in solving problems more efficiently.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps in the plan should be implemented as described. Centroid decomposition and dynamic programming should be applied to efficiently find the solution for each tour group.\n\n# [edge case] \n    Edge Case 1:\n    Input: 5 3\n    2 2 3 3 3\n    1 2 4 7\n    1 3 2 8\n    2 4 8 2\n    2 5 1 1\n    1 3\n    9 5\n    6 2\n\n    Expected Output: 3 8\n    Explanation: For the first query, a tour group of size 1 starting at city 3 can reach cities 1, 2, 3, 4, and 5. Thus, the largest enjoyment value that they can reach is 3. If the tour group chooses to go to city 4, Omkar will have to pay 8 per vehicle, which is the maximum.\n\n    Edge Case 2:\n    Input: 5 5\n    1 2 3 4 5\n    1 2 4 1\n    1 3 3 1\n    1 4 2 1\n    2 5 1 1\n    5 1\n    4 1\n    3 1\n    2 1\n    1 1\n\n    Expected Output: 1 0\n    Explanation: For the first query, a tour group of size 5 starting at city 1 can only reach city 1. Thus, their maximum enjoyment value is 1 and the cost Omkar will have to pay is 0 per vehicle.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The original logic can be used to find the maximum enjoyment value and the corresponding toll per vehicle based on dynamic programming results."]
----------
False
----------
0
multi-gen-prompt:
 Monocarp, the dedicated coach of the Berland State University programming teams, has gathered a total of n problems, all of which are new to his students. Each problem is uniquely identified by its topic, denoted as a_i (ranging from 1 to n), and its difficulty, represented by b_i (also ranging from 1 to n).

Monocarp aims to choose exactly 3 problems from these n problems to form a problemset. The selection must meet at least one of the following criteria:

1. The topics of all three selected problems are distinct.
2. The difficulties of all

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
multi-gen-prompt:
 Monocarp, the coach of the Berland State University programming teams, has n problems, each with a unique topic a_i and difficulty b_i. He needs to select 3 problems for a training session, ensuring that at least one of the following conditions is met: the topics of all three selected problems are different, or the difficulties of all three selected problems are different. Determine the number of ways to select these problems.

Input

The first line contains a single integer t (1 ≤ t ≤ 50000) — the number of testcases.

The first line of each testcase contains an integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of problems that Monocarp have.

In the i-th of the following n lines, there are two integers a_i and b_i (1 ≤ a_i, b_i ≤ n) — the topic and the difficulty of the i-th problem.

It is guaranteed that there are no two problems that have the same topic and difficulty at the same time.

The sum of n over all testcases doesn't exceed 2 ⋅ 10^5.

Output

Print the number of ways to select three training problems that meet either of the requirements described in the statement.

Example

Input


2
4
2 4
3 4
2 1
1 3
5
1 5
2 4
3 3
4 2
5 1


Output


3
10

Note

In the first example, you can take the following sets of three problems:

  * problems 1, 2, 4; 
  * problems 1, 3, 4; 
  * problems 2, 3, 4. 



Thus, the number of ways is equal to three.
generating with deepseek-coder
----------
['def count_combinations(n, problems):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]) or \\\n                   (problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]):\n                    count += 1\n    return count\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        problems = []\n        for _ in range(n):\n            topic = int(data[index])\n            difficulty = int(data[index + 1])\n            problems.append((topic, difficulty))\n            index += 2\n        results.append(count_combinations(n, problems))\n    \n    for result in results:\n        print(result)', 'def count_problem_sets(n, problems):\n    count = 0\n    for i in range(len(problems)):\n        for j in range(i + 1, len(problems)):\n            for k in range(j + 1, len(problems)):\n                if (problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]) or \\\n                   (problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]):\n                    count += 1\n    return count\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        problems = []\n        for i in range(1, n + 1):\n            topic = int(data[index + i])\n            difficulty = int(data[index + n + i])\n            problems.append((topic, difficulty))\n        results.append(count_problem_sets(n, problems))\n        index += 2 * n + 1\n    \n    for result in results:\n        print(result)', 'from itertools import combinations\n\ndef count_valid_combinations(n, problems):\n    valid_combinations = 0\n    for comb in combinations(problems, 3):\n        topics = {problem[0] for problem in comb}\n        difficulties = {problem[1] for problem in comb}\n        if len(topics) == 3 or len(difficulties) == 3:\n            valid_combinations += 1\n    return valid_combinations\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        problems = [tuple(map(int, input().split())) for _ in range(n)]\n        results.append(count_valid_combinations(n, problems))\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def count_problem_sets(test_cases):\n    results = []\n    for problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n        for topic, difficulty in problems:\n            topic_count[topic] = topic_count.get(topic, 0) + 1\n            difficulty_count[difficulty] = difficulty_count.get(difficulty, 0) + 1\n        \n        count = 0\n        # Check for distinct topics\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                for k in range(j + 1, len(problems)):\n                    if problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]:\n                        count += 1\n        \n        # Check for distinct difficulties\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                for k in range(j + 1, len(problems)):\n                    if problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]:\n                        count += 1\n        \n        results.append(count)\n    return results\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        problems = []\n        for i in range(1, n + 1):\n            topic = int(data[index + i * 2 - 1])\n            difficulty = int(data[index + i * 2])\n            problems.append((topic, difficulty))\n        test_cases.append(problems)\n        index += n * 2 + 1\n    \n    results = count_problem_sets(test_cases)\n    for result in results:\n        print(result)', 'def count_valid_triplets(n, problems):\n    count = 0\n    for i in range(len(problems)):\n        for j in range(i + 1, len(problems)):\n            for k in range(j + 1, len(problems)):\n                if (problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]) or \\\n                   (problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]):\n                    count += 1\n    return count\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        problems = []\n        for _ in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            problems.append((a, b))\n            index += 2\n        results.append(count_valid_triplets(n, problems))\n    \n    for result in results:\n        print(result)', 'def count_problem_sets(test_cases):\n    results = []\n    for problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n        for topic, difficulty in problems:\n            topic_count[topic] = topic_count.get(topic, 0) + 1\n            difficulty_count[difficulty] = difficulty_count.get(difficulty, 0) + 1\n        \n        count = 0\n        # Check for distinct topics\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                for k in range(j + 1, len(problems)):\n                    if problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]:\n                        count += 1\n        \n        # Check for distinct difficulties\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                for k in range(j + 1, len(problems)):\n                    if problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]:\n                        count += 1\n        \n        results.append(count)\n    return results\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        problems = []\n        for i in range(1, n + 1):\n            topic = int(data[index + i * 2 - 1])\n            difficulty = int(data[index + i * 2])\n            problems.append((topic, difficulty))\n        test_cases.append(problems)\n        index += n * 2 + 1\n    \n    results = count_problem_sets(test_cases)\n    for result in results:\n        print(result)', 'def count_problem_sets(test_cases):\n    results = []\n    for problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n        for topic, difficulty in problems:\n            topic_count[topic] = topic_count.get(topic, 0) + 1\n            difficulty_count[difficulty] = difficulty_count.get(difficulty, 0) + 1\n        \n        count = 0\n        # Check for distinct topics\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                for k in range(j + 1, len(problems)):\n                    if problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]:\n                        count += 1\n        \n        # Check for distinct difficulties\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                for k in range(j + 1, len(problems)):\n                    if problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]:\n                        count += 1\n        \n        results.append(count)\n    return results\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        problems = []\n        for i in range(1, n + 1):\n            topic = int(data[index + i * 2 - 1])\n            difficulty = int(data[index + i * 2])\n            problems.append((topic, difficulty))\n        test_cases.append(problems)\n        index += n * 2 + 1\n    \n    results = count_problem_sets(test_cases)\n    for result in results:\n        print(result)', 'def count_problem_sets(test_cases):\n    results = []\n    for problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n        for topic, difficulty in problems:\n            topic_count[topic] = topic_count.get(topic, 0) + 1\n            difficulty_count[difficulty] = difficulty_count.get(difficulty, 0) + 1\n        \n        count = 0\n        # Check for distinct topics\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                for k in range(j + 1, len(problems)):\n                    if problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]:\n                        count += 1\n        \n        # Check for distinct difficulties\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                for k in range(j + 1, len(problems)):\n                    if problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]:\n                        count += 1\n        \n        results.append(count)\n    return results\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        problems = []\n        for i in range(1, n + 1):\n            topic = int(data[index + i * 2 - 1])\n            difficulty = int(data[index + i * 2])\n            problems.append((topic, difficulty))\n        test_cases.append(problems)\n        index += n * 2 + 1\n    \n    results = count_problem_sets(test_cases)\n    for result in results:\n        print(result)', 'def count_problem_sets(test_cases):\n    results = []\n    for problems in test_cases:\n        topic_count = {}\n        difficulty_count = {}\n        for topic, difficulty in problems:\n            topic_count[topic] = topic_count.get(topic, 0) + 1\n            difficulty_count[difficulty] = difficulty_count.get(difficulty, 0) + 1\n        \n        count = 0\n        # Check for distinct topics\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                for k in range(j + 1, len(problems)):\n                    if problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]:\n                        count += 1\n        \n        # Check for distinct difficulties\n        for i in range(len(problems)):\n            for j in range(i + 1, len(problems)):\n                for k in range(j + 1, len(problems)):\n                    if problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]:\n                        count += 1\n        \n        results.append(count)\n    return results\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        problems = []\n        for i in range(1, n + 1):\n            topic = int(data[index + i * 2 - 1])\n            difficulty = int(data[index + i * 2])\n            problems.append((topic, difficulty))\n        test_cases.append(problems)\n        index += n * 2 + 1\n    \n    results = count_problem_sets(test_cases)\n    for result in results:\n        print(result)', 'def count_problem_sets(n, problems):\n    count = 0\n    for i in range(len(problems)):\n        for j in range(i + 1, len(problems)):\n            for k in range(j + 1, len(problems)):\n                if (problems[i][0] != problems[j][0] and problems[j][0] != problems[k][0] and problems[i][0] != problems[k][0]) or \\\n                   (problems[i][1] != problems[j][1] and problems[j][1] != problems[k][1] and problems[i][1] != problems[k][1]):\n                    count += 1\n    return count\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        problems = []\n        for i in range(1, n + 1):\n            topic = int(data[index + i])\n            difficulty = int(data[index + n + i])\n            problems.append((topic, difficulty))\n        results.append(count_problem_sets(n, problems))\n        index += 2 * n + 1\n    \n    for result in results:\n        print(result)']
----------
["- name: \nCounting Combinations Using Brute Force\n\n- content: \nTo solve this problem, we can use a brute force approach to count the number of ways to select three problems that meet either of the two conditions. For each test case, we will iterate through all possible combinations of three problems and check if they satisfy the given conditions.\n\nFor each combination (i, j, k):\n1. Check if the topics of the three problems are different.\n2. Check if the difficulties of the three problems are different.\n3. If either condition is satisfied, increment the count.\n\nThis approach ensures that we consider all possible combinations and count only those that meet the criteria.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'combinations': means selecting three problems from a set of n problems, considering all possible ways to satisfy at least one of two conditions.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially for each test case. For each combination of three problems, check both conditions and increment the count if either condition is met.\n\n# [edge case] \n    For a small test case with n = 4:\n    - Input: [[2, 4], [3, 4], [2, 1], [1, 3]]\n    - Explanation: The possible combinations are:\n        - [1, 2, 4] (topics: different)\n        - [1, 3, 4] (topics: different)\n        - [2, 3, 4] (topics: different)\n    - Expected output: 3\n\n    For a larger test case with n = 5:\n    - Input: [[1, 5], [2, 4], [3, 3], [4, 2], [5, 1]]\n    - Explanation: The possible combinations are:\n        - [1, 2, 3] (difficulties: different)\n        - [1, 2, 4] (difficulties: different)\n        - [1, 2, 5] (difficulties: different)\n        - [1, 3, 4] (difficulties: different)\n        - [1, 3, 5] (difficulties: different)\n        - [1, 4, 5] (difficulties: different)\n        - [2, 3, 4] (difficulties: different)\n        - [2, 3, 5] (difficulties: different)\n        - [2, 4, 5] (difficulties: different)\n        - [3, 4, 5] (difficulties: different)\n    - Expected output: 10\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute force approach inherently checks all combinations and counts only those that meet the criteria.", "- name: \nBrute Force with Constraints\n\n- content: \n- Use three nested loops to iterate through all possible combinations of three problems.\n- Check for each triplet if it meets the condition of having different topics or different difficulties.\n- Sum up the counts of valid triplets found.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'combinations': means selecting three problems from n problems\n    'different topics or different difficulties': means the selection should meet at least one of the two conditions\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate through all possible combinations of three problems and check if they meet the condition of having different topics or different difficulties.\n\n# [edge case] \n    Edge case 1:\n    n = 3\n    problems = [[1, 2], [2, 3], [3, 1]]\n    Explanation:\n    There are only 3 problems, so the only possible combination is [1, 2, 3]. All topics and difficulties are different, so the number of ways is 1.\n    Edge case 2:\n    n = 4\n    problems = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    Explanation:\n    There are 4 problems, and we need to find all combinations of 3 problems that have different topics or different difficulties. The valid combinations are:\n    - [1, 2, 3]\n    - [1, 2, 4]\n    - [1, 3, 4]\n    - [2, 3, 4]\n    There are 4 valid combinations, so the number of ways is 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for small values of n. However, for larger values of n, the brute force approach may not be efficient, and we would need to optimize the solution.", "- name: \nBrute Force Combination\n\n- content: \n- Iterate through all possible combinations of 3 problems from the given set of n problems.\n- For each combination, check if it meets at least one of the two conditions:\n  - The topics of all three selected problems are different.\n  - The difficulties of all three selected problems are different.\n- Count and return the number of valid combinations found.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'combinations': means selecting 3 problems from n problems without regard to order.\n    'conditions': means the problems must either have different topics or different difficulties.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship specifically mentioned.\n\n# [degree adverb] \n    No degree adverb specifically mentioned.\n\n# [code logic]\n    The plan suggests iterating through all possible combinations of 3 problems and checking if they meet the conditions. This can be done using nested loops to generate all combinations and then checking each one.\n\n# [edge case]\n    Edge case 1:\n    n = 4\n    problems = [(2, 4), (3, 4), (2, 1), (1, 3)]\n    Expected output: 3\n    Explanation: The valid combinations are (1, 2, 4), (1, 3, 4), and (2, 3, 4).\n\n    Edge case 2:\n    n = 5\n    problems = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]\n    Expected output: 10\n    Explanation: The valid combinations are those where the topics or difficulties are different for each set of three problems.\n\n# [extra code for edge case]\n    No extra code is needed for the edge cases as the brute force approach will handle them naturally. The main logic will generate all combinations and check the conditions.", "- name: \nMathematical Combinatorics\n\n- content: \nWe can use combinatorial mathematics to directly calculate the number of valid sets of three problems without having to iterate through all combinations. This approach is highly efficient for large inputs.\n\n**Steps:**\n1. For each test case, read the number of problems `n` and the list of problems with their topics and difficulties.\n2. Use combinatorial formulas to calculate the number of ways to select three problems with distinct topics and distinct difficulties.\n3. Output the calculated number of valid sets for each test case.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct topics': means that all three selected problems have different topics.\n    'distinct difficulties': means that all three selected problems have different difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means that we need to select three problems from the given list.\n\n# [degree adverb] \n    'largest': means that we need to find the largest number of ways to select three problems that meet either of the requirements.\n\n# [code logic]\n    The steps should be implemented simultaneously to calculate the number of ways to select three problems with distinct topics and distinct difficulties.\n\n# [edge case] \n    For a small test case with n = 4:\n    edge_case1 = [1, 2, 3, 4]\n    Explanation:\n        - All topics and difficulties are distinct.\n        - The number of ways to select three problems with distinct topics and distinct difficulties is calculated using combinatorial mathematics.\n        - Expected output: 4 (since there are 4 ways to choose 3 problems out of 4 with distinct topics and distinct difficulties).\n\n    For a larger test case with n = 5:\n    edge_case2 = [1, 2, 3, 4, 5]\n    Explanation:\n        - All topics and difficulties are distinct.\n        - The number of ways to select three problems with distinct topics and distinct difficulties is calculated using combinatorial mathematics.\n        - Expected output: 10 (since there are 10 ways to choose 3 problems out of 5 with distinct topics and distinct difficulties).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The combinatorial formula can be directly applied to calculate the number of ways.", "- name: \nBrute Force Counting\n\n- content: \nFor each test case, we will iterate through all possible triplets of problems and check if they meet at least one of the conditions. This can be done using three nested loops to generate all possible combinations of three problems. For each combination, we will check if the topics are all different or if the difficulties are all different. We will use sets to ensure that the uniqueness of topics and difficulties is maintained. Finally, we will count and return the number of valid triplets.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'unique problems': each problem has a unique topic and difficulty\n    'valid triplets': the problems must either have different topics or different difficulties\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship\n\n# [degree adverb] \n    No specific degree adverb\n\n# [code logic]\n    The plan suggests using three nested loops to iterate through all possible combinations of three problems. For each combination, we will check if the topics are all different or if the difficulties are all different. This can be efficiently done using sets to ensure the uniqueness of topics and difficulties.\n\n# [edge case] \n    Edge case 1:\n    n = 4\n    problems = [(2, 4), (3, 4), (2, 1), (1, 3)]\n    expected output: 3\n    Explanation: The valid triplets are (1, 2, 4), (1, 3, 4), and (2, 3, 4).\n\n    Edge case 2:\n    n = 5\n    problems = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]\n    expected output: 10\n    Explanation: There are 10 valid triplets: (1, 2, 3), (1, 2, 4), (1, 2, 5), (1, 3, 4), (1, 3, 5), (1, 4, 5), (2, 3, 4), (2, 3, 5), (2, 4, 5), and (3, 4, 5).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the brute force approach will work efficiently for the given constraints.", "- name: \nMathematical Combinatorics\n\n- content: \nWe can use combinatorial mathematics to directly calculate the number of valid sets of three problems without having to iterate through all combinations. This approach is highly efficient for large inputs.\n\n**Steps:**\n1. For each test case, read the number of problems `n` and the list of problems with their topics and difficulties.\n2. Use combinatorial formulas to calculate the number of ways to select three problems with distinct topics and distinct difficulties.\n3. Output the calculated number of valid sets for each test case.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct topics': means that all three selected problems have different topics.\n    'distinct difficulties': means that all three selected problems have different difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means that we need to select three problems from the given list.\n\n# [degree adverb] \n    'largest': means that we need to find the largest number of ways to select three problems that meet either of the requirements.\n\n# [code logic]\n    The steps should be implemented simultaneously to calculate the number of ways to select three problems with distinct topics and distinct difficulties.\n\n# [edge case] \n    For a small test case with n = 4:\n    edge_case1 = [1, 2, 3, 4]\n    Explanation:\n        - All topics and difficulties are distinct.\n        - The number of ways to select three problems with distinct topics and distinct difficulties is calculated using combinatorial mathematics.\n        - Expected output: 4 (since there are 4 ways to choose 3 problems out of 4 with distinct topics and distinct difficulties).\n\n    For a larger test case with n = 5:\n    edge_case2 = [1, 2, 3, 4, 5]\n    Explanation:\n        - All topics and difficulties are distinct.\n        - The number of ways to select three problems with distinct topics and distinct difficulties is calculated using combinatorial mathematics.\n        - Expected output: 10 (since there are 10 ways to choose 3 problems out of 5 with distinct topics and distinct difficulties).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The combinatorial formula can be directly applied to calculate the number of ways.", "- name: \nMathematical Combinatorics\n\n- content: \nWe can use combinatorial mathematics to directly calculate the number of valid sets of three problems without having to iterate through all combinations. This approach is highly efficient for large inputs.\n\n**Steps:**\n1. For each test case, read the number of problems `n` and the list of problems with their topics and difficulties.\n2. Use combinatorial formulas to calculate the number of ways to select three problems with distinct topics and distinct difficulties.\n3. Output the calculated number of valid sets for each test case.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct topics': means that all three selected problems have different topics.\n    'distinct difficulties': means that all three selected problems have different difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means that we need to select three problems from the given list.\n\n# [degree adverb] \n    'largest': means that we need to find the largest number of ways to select three problems that meet either of the requirements.\n\n# [code logic]\n    The steps should be implemented simultaneously to calculate the number of ways to select three problems with distinct topics and distinct difficulties.\n\n# [edge case] \n    For a small test case with n = 4:\n    edge_case1 = [1, 2, 3, 4]\n    Explanation:\n        - All topics and difficulties are distinct.\n        - The number of ways to select three problems with distinct topics and distinct difficulties is calculated using combinatorial mathematics.\n        - Expected output: 4 (since there are 4 ways to choose 3 problems out of 4 with distinct topics and distinct difficulties).\n\n    For a larger test case with n = 5:\n    edge_case2 = [1, 2, 3, 4, 5]\n    Explanation:\n        - All topics and difficulties are distinct.\n        - The number of ways to select three problems with distinct topics and distinct difficulties is calculated using combinatorial mathematics.\n        - Expected output: 10 (since there are 10 ways to choose 3 problems out of 5 with distinct topics and distinct difficulties).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The combinatorial formula can be directly applied to calculate the number of ways.", "- name: \nMathematical Combinatorics\n\n- content: \nWe can use combinatorial mathematics to directly calculate the number of valid sets of three problems without having to iterate through all combinations. This approach is highly efficient for large inputs.\n\n**Steps:**\n1. For each test case, read the number of problems `n` and the list of problems with their topics and difficulties.\n2. Use combinatorial formulas to calculate the number of ways to select three problems with distinct topics and distinct difficulties.\n3. Output the calculated number of valid sets for each test case.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct topics': means that all three selected problems have different topics.\n    'distinct difficulties': means that all three selected problems have different difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means that we need to select three problems from the given list.\n\n# [degree adverb] \n    'largest': means that we need to find the largest number of ways to select three problems that meet either of the requirements.\n\n# [code logic]\n    The steps should be implemented simultaneously to calculate the number of ways to select three problems with distinct topics and distinct difficulties.\n\n# [edge case] \n    For a small test case with n = 4:\n    edge_case1 = [1, 2, 3, 4]\n    Explanation:\n        - All topics and difficulties are distinct.\n        - The number of ways to select three problems with distinct topics and distinct difficulties is calculated using combinatorial mathematics.\n        - Expected output: 4 (since there are 4 ways to choose 3 problems out of 4 with distinct topics and distinct difficulties).\n\n    For a larger test case with n = 5:\n    edge_case2 = [1, 2, 3, 4, 5]\n    Explanation:\n        - All topics and difficulties are distinct.\n        - The number of ways to select three problems with distinct topics and distinct difficulties is calculated using combinatorial mathematics.\n        - Expected output: 10 (since there are 10 ways to choose 3 problems out of 5 with distinct topics and distinct difficulties).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The combinatorial formula can be directly applied to calculate the number of ways.", "- name: \nMathematical Combinatorics\n\n- content: \nWe can use combinatorial mathematics to directly calculate the number of valid sets of three problems without having to iterate through all combinations. This approach is highly efficient for large inputs.\n\n**Steps:**\n1. For each test case, read the number of problems `n` and the list of problems with their topics and difficulties.\n2. Use combinatorial formulas to calculate the number of ways to select three problems with distinct topics and distinct difficulties.\n3. Output the calculated number of valid sets for each test case.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'distinct topics': means that all three selected problems have different topics.\n    'distinct difficulties': means that all three selected problems have different difficulties.\n\n# [phrase showing quantity relationship]\n    'exactly 3 problems': means that we need to select three problems from the given list.\n\n# [degree adverb] \n    'largest': means that we need to find the largest number of ways to select three problems that meet either of the requirements.\n\n# [code logic]\n    The steps should be implemented simultaneously to calculate the number of ways to select three problems with distinct topics and distinct difficulties.\n\n# [edge case] \n    For a small test case with n = 4:\n    edge_case1 = [1, 2, 3, 4]\n    Explanation:\n        - All topics and difficulties are distinct.\n        - The number of ways to select three problems with distinct topics and distinct difficulties is calculated using combinatorial mathematics.\n        - Expected output: 4 (since there are 4 ways to choose 3 problems out of 4 with distinct topics and distinct difficulties).\n\n    For a larger test case with n = 5:\n    edge_case2 = [1, 2, 3, 4, 5]\n    Explanation:\n        - All topics and difficulties are distinct.\n        - The number of ways to select three problems with distinct topics and distinct difficulties is calculated using combinatorial mathematics.\n        - Expected output: 10 (since there are 10 ways to choose 3 problems out of 5 with distinct topics and distinct difficulties).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The combinatorial formula can be directly applied to calculate the number of ways.", "- name: \nBrute Force with Constraints\n\n- content: \n- Use three nested loops to iterate through all possible combinations of three problems.\n- Check for each triplet if it meets the condition of having different topics or different difficulties.\n- Sum up the counts of valid triplets found.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'combinations': means selecting three problems from n problems\n    'different topics or different difficulties': means the selection should meet at least one of the two conditions\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate through all possible combinations of three problems and check if they meet the condition of having different topics or different difficulties.\n\n# [edge case] \n    Edge case 1:\n    n = 3\n    problems = [[1, 2], [2, 3], [3, 1]]\n    Explanation:\n    There are only 3 problems, so the only possible combination is [1, 2, 3]. All topics and difficulties are different, so the number of ways is 1.\n    Edge case 2:\n    n = 4\n    problems = [[1, 2], [2, 3], [3, 4], [4, 1]]\n    Explanation:\n    There are 4 problems, and we need to find all combinations of 3 problems that have different topics or different difficulties. The valid combinations are:\n    - [1, 2, 3]\n    - [1, 2, 4]\n    - [1, 3, 4]\n    - [2, 3, 4]\n    There are 4 valid combinations, so the number of ways is 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to solve the problem for small values of n. However, for larger values of n, the brute force approach may not be efficient, and we would need to optimize the solution."]
----------
True
----------
3
multi-gen-prompt:
 Shohag has a sequence of integers a_1, a_2, …, a_n. He can perform the operation multiple times, where in each operation, he selects a positive integer k and inserts it at any position in the sequence, which could be at the beginning, end, or between elements. This operation changes the sequence, and the next operation is performed on the updated sequence.

Shohag wants the sequence to meet a specific condition: for every 1 ≤ i ≤ |a|, a_i ≤ i. Here, |a| represents the size of the sequence.


Input

The first line contains a single integer t (1 ≤ t ≤ 200) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the initial length of the sequence.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9) — the elements of the sequence.

Output

For each test case, print a single integer — the minimum number of operations needed to perform to achieve the goal mentioned in the statement.

Example

Input


4
3
1 3 4
5
1 2 5 7 4
1
1
3
69 6969 696969


Output


1
3
0
696966

Note

In the first test case, we have to perform at least one operation, as a_2=3>2. We can perform the operation [1, 3, 4] → [1, \underline{2}, 3, 4] (the newly inserted element is underlined), now the condition is satisfied.

In the second test case, Shohag can perform the following operations:

[1, 2, 5, 7, 4] → [1, 2, \underline{3}, 5, 7, 4] → [1, 2, 3, \underline{4}, 5, 7, 4] → [1, 2, 3, 4, 5, \underline{3}, 7, 4].

In the third test case, the sequence already satisfies the condition.
multi-gen-prompt:
 Shohag has an integer sequence a_1, a_2, …, a_n. He can perform the following operation any number of times (possibly, zero): select any positive integer k (it can be different in different operations) and choose any position in the sequence to insert k, changing the sequence a. Shohag wants the sequence to satisfy a_i ≤ i for each 1 ≤ i ≤ |a|. Help him find the minimum number of operations to achieve this goal.

Input

The first line contains a single integer t (1 ≤ t ≤ 200) — the number of test cases.

The first line of each test case contains a single integer n (1 ≤ n ≤ 100) — the initial length of the sequence.

The second line of each test case contains n integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^9) — the elements of the sequence.

Output

For each test case, print a single integer — the minimum number of operations needed to perform to achieve the goal mentioned in the statement.

Example

Input


4
3
1 3 4
5
1 2 5 7 4
1
1
3
69 6969 696969


Output


1
3
0
696966

Note

In the first test case, we have to perform at least one operation, as a_2=3>2. We can perform the operation [1, 3, 4] → [1, \underline{2}, 3, 4] (the newly inserted element is underlined), now the condition is satisfied.

In the second test case, Shohag can perform the following operations:

[1, 2, 5, 7, 4] → [1, 2, \underline{3}, 5, 7, 4] → [1, 2, 3, \underline{4}, 5, 7, 4] → [1, 2, 3, 4, 5, \underline{3}, 7, 4].

In the third test case, the sequence already satisfies the condition.
generating with deepseek-coder
----------
['def f1(n, sequence):\n    operations = 0\n    for i in range(n):\n        if sequence[i] > i + 1:\n            operations += sequence[i] - (i + 1)\n    return operations\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        sequence = list(map(int, input().split()))\n        print(f1(n, sequence))', 'def f1(n, sequence):\n    operations = 0\n    for i in range(n):\n        if sequence[i] > i + 1:\n            operations += sequence[i] - (i + 1)\n    return operations\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        sequence = list(map(int, input().split()))\n        print(f1(n, sequence))', 'def f1(n, sequence):\n    operations = 0\n    for i in range(n):\n        if sequence[i] > i + 1:\n            operations += sequence[i] - (i + 1)\n    return operations\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        sequence = list(map(int, input().split()))\n        print(f1(n, sequence))', 'def f1(n, sequence):\n    operations = 0\n    for i in range(n):\n        if sequence[i] > i + 1:\n            operations += sequence[i] - (i + 1)\n    return operations\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        sequence = list(map(int, input().split()))\n        print(f1(n, sequence))', 'def f1(n, sequence):\n    operations = 0\n    for i in range(n):\n        if sequence[i] > i + 1:\n            operations += sequence[i] - (i + 1)\n    return operations\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        sequence = list(map(int, input().split()))\n        print(f1(n, sequence))', 'def f1(n, sequence):\n    operations = 0\n    for i in range(n):\n        if sequence[i] > i + 1:\n            operations += sequence[i] - (i + 1)\n    return operations\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        sequence = list(map(int, input().split()))\n        print(f1(n, sequence))', 'def f1(n, sequence):\n    operations = 0\n    for i in range(n):\n        if sequence[i] > i + 1:\n            operations += sequence[i] - (i + 1)\n    return operations\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        sequence = list(map(int, input().split()))\n        print(f1(n, sequence))', 'def f1(n, sequence):\n    operations = 0\n    for i in range(n):\n        if sequence[i] > i + 1:\n            operations += sequence[i] - (i + 1)\n    return operations\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        sequence = list(map(int, input().split()))\n        print(f1(n, sequence))', 'def f1(n, sequence):\n    operations = 0\n    for i in range(n):\n        if sequence[i] > i + 1:\n            operations += sequence[i] - (i + 1)\n    return operations\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        sequence = list(map(int, input().split()))\n        print(f1(n, sequence))', 'def f1(n, sequence):\n    operations = 0\n    for i in range(n):\n        if sequence[i] > i + 1:\n            operations += sequence[i] - (i + 1)\n    return operations\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        sequence = list(map(int, input().split()))\n        print(f1(n, sequence))']
----------
["- name: \nGreedy Insertion Strategy\n\n- content: \nFor each test case, start by checking if the sequence already satisfies the condition. If not, find the first element that does not satisfy the condition (a_i > i). Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence. Count the number of insertions performed.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Insertion Strategy': This involves inserting elements at appropriate positions to ensure the sequence meets a specific condition, in this case, ensuring that for every 1 ≤ i ≤ |a|, a_i ≤ i.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the steps should be implemented sequentially:\n    1. Check if the sequence already satisfies the condition.\n    2. If not, find the first element that does not satisfy the condition (a_i > i).\n    3. Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition.\n    4. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence.\n    5. Count the number of insertions performed.\n\n# [edge case] \n    Test Case:\n    1\n    3\n    1 3 4\n    \n    Expected Output: 1\n    Explanation: The sequence [1, 3, 4] does not satisfy the condition since a_2 = 3 > 2. By inserting 2 at the beginning, we get [2, 1, 3, 4], which satisfies the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the insertion process.", "- name: \nGreedy Insertion Strategy\n\n- content: \nFor each test case, start by checking if the sequence already satisfies the condition. If not, find the first element that does not satisfy the condition (a_i > i). Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence. Count the number of insertions performed.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Insertion Strategy': This involves inserting elements at appropriate positions to ensure the sequence meets a specific condition, in this case, ensuring that for every 1 ≤ i ≤ |a|, a_i ≤ i.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the steps should be implemented sequentially:\n    1. Check if the sequence already satisfies the condition.\n    2. If not, find the first element that does not satisfy the condition (a_i > i).\n    3. Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition.\n    4. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence.\n    5. Count the number of insertions performed.\n\n# [edge case] \n    Test Case:\n    1\n    3\n    1 3 4\n    \n    Expected Output: 1\n    Explanation: The sequence [1, 3, 4] does not satisfy the condition since a_2 = 3 > 2. By inserting 2 at the beginning, we get [2, 1, 3, 4], which satisfies the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the insertion process.", "- name: \nGreedy Insertion Strategy\n\n- content: \nFor each test case, start by checking if the sequence already satisfies the condition. If not, find the first element that does not satisfy the condition (a_i > i). Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence. Count the number of insertions performed.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Insertion Strategy': This involves inserting elements at appropriate positions to ensure the sequence meets a specific condition, in this case, ensuring that for every 1 ≤ i ≤ |a|, a_i ≤ i.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the steps should be implemented sequentially:\n    1. Check if the sequence already satisfies the condition.\n    2. If not, find the first element that does not satisfy the condition (a_i > i).\n    3. Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition.\n    4. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence.\n    5. Count the number of insertions performed.\n\n# [edge case] \n    Test Case:\n    1\n    3\n    1 3 4\n    \n    Expected Output: 1\n    Explanation: The sequence [1, 3, 4] does not satisfy the condition since a_2 = 3 > 2. By inserting 2 at the beginning, we get [2, 1, 3, 4], which satisfies the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the insertion process.", "- name: \nGreedy Insertion Strategy\n\n- content: \nFor each test case, start by checking if the sequence already satisfies the condition. If not, find the first element that does not satisfy the condition (a_i > i). Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence. Count the number of insertions performed.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Insertion Strategy': This involves inserting elements at appropriate positions to ensure the sequence meets a specific condition, in this case, ensuring that for every 1 ≤ i ≤ |a|, a_i ≤ i.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the steps should be implemented sequentially:\n    1. Check if the sequence already satisfies the condition.\n    2. If not, find the first element that does not satisfy the condition (a_i > i).\n    3. Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition.\n    4. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence.\n    5. Count the number of insertions performed.\n\n# [edge case] \n    Test Case:\n    1\n    3\n    1 3 4\n    \n    Expected Output: 1\n    Explanation: The sequence [1, 3, 4] does not satisfy the condition since a_2 = 3 > 2. By inserting 2 at the beginning, we get [2, 1, 3, 4], which satisfies the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the insertion process.", "- name: \nGreedy Insertion Strategy\n\n- content: \nFor each test case, start by checking if the sequence already satisfies the condition. If not, find the first element that does not satisfy the condition (a_i > i). Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence. Count the number of insertions performed.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Insertion Strategy': This involves inserting elements at appropriate positions to ensure the sequence meets a specific condition, in this case, ensuring that for every 1 ≤ i ≤ |a|, a_i ≤ i.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the steps should be implemented sequentially:\n    1. Check if the sequence already satisfies the condition.\n    2. If not, find the first element that does not satisfy the condition (a_i > i).\n    3. Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition.\n    4. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence.\n    5. Count the number of insertions performed.\n\n# [edge case] \n    Test Case:\n    1\n    3\n    1 3 4\n    \n    Expected Output: 1\n    Explanation: The sequence [1, 3, 4] does not satisfy the condition since a_2 = 3 > 2. By inserting 2 at the beginning, we get [2, 1, 3, 4], which satisfies the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the insertion process.", "- name: \nGreedy Insertion Strategy\n\n- content: \nFor each test case, start by checking if the sequence already satisfies the condition. If not, find the first element that does not satisfy the condition (a_i > i). Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence. Count the number of insertions performed.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Insertion Strategy': This involves inserting elements at appropriate positions to ensure the sequence meets a specific condition, in this case, ensuring that for every 1 ≤ i ≤ |a|, a_i ≤ i.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the steps should be implemented sequentially:\n    1. Check if the sequence already satisfies the condition.\n    2. If not, find the first element that does not satisfy the condition (a_i > i).\n    3. Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition.\n    4. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence.\n    5. Count the number of insertions performed.\n\n# [edge case] \n    Test Case:\n    1\n    3\n    1 3 4\n    \n    Expected Output: 1\n    Explanation: The sequence [1, 3, 4] does not satisfy the condition since a_2 = 3 > 2. By inserting 2 at the beginning, we get [2, 1, 3, 4], which satisfies the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the insertion process.", "- name: \nGreedy Insertion Strategy\n\n- content: \nFor each test case, start by checking if the sequence already satisfies the condition. If not, find the first element that does not satisfy the condition (a_i > i). Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence. Count the number of insertions performed.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Insertion Strategy': This involves inserting elements at appropriate positions to ensure the sequence meets a specific condition, in this case, ensuring that for every 1 ≤ i ≤ |a|, a_i ≤ i.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the steps should be implemented sequentially:\n    1. Check if the sequence already satisfies the condition.\n    2. If not, find the first element that does not satisfy the condition (a_i > i).\n    3. Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition.\n    4. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence.\n    5. Count the number of insertions performed.\n\n# [edge case] \n    Test Case:\n    1\n    3\n    1 3 4\n    \n    Expected Output: 1\n    Explanation: The sequence [1, 3, 4] does not satisfy the condition since a_2 = 3 > 2. By inserting 2 at the beginning, we get [2, 1, 3, 4], which satisfies the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the insertion process.", "- name: \nGreedy Insertion Strategy\n\n- content: \nFor each test case, start by checking if the sequence already satisfies the condition. If not, find the first element that does not satisfy the condition (a_i > i). Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence. Count the number of insertions performed.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Insertion Strategy': This involves inserting elements at appropriate positions to ensure the sequence meets a specific condition, in this case, ensuring that for every 1 ≤ i ≤ |a|, a_i ≤ i.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the steps should be implemented sequentially:\n    1. Check if the sequence already satisfies the condition.\n    2. If not, find the first element that does not satisfy the condition (a_i > i).\n    3. Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition.\n    4. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence.\n    5. Count the number of insertions performed.\n\n# [edge case] \n    Test Case:\n    1\n    3\n    1 3 4\n    \n    Expected Output: 1\n    Explanation: The sequence [1, 3, 4] does not satisfy the condition since a_2 = 3 > 2. By inserting 2 at the beginning, we get [2, 1, 3, 4], which satisfies the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the insertion process.", "- name: \nGreedy Insertion Strategy\n\n- content: \nFor each test case, start by checking if the sequence already satisfies the condition. If not, find the first element that does not satisfy the condition (a_i > i). Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence. Count the number of insertions performed.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Insertion Strategy': This involves inserting elements at appropriate positions to ensure the sequence meets a specific condition, in this case, ensuring that for every 1 ≤ i ≤ |a|, a_i ≤ i.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the steps should be implemented sequentially:\n    1. Check if the sequence already satisfies the condition.\n    2. If not, find the first element that does not satisfy the condition (a_i > i).\n    3. Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition.\n    4. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence.\n    5. Count the number of insertions performed.\n\n# [edge case] \n    Test Case:\n    1\n    3\n    1 3 4\n    \n    Expected Output: 1\n    Explanation: The sequence [1, 3, 4] does not satisfy the condition since a_2 = 3 > 2. By inserting 2 at the beginning, we get [2, 1, 3, 4], which satisfies the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the insertion process.", "- name: \nGreedy Insertion Strategy\n\n- content: \nFor each test case, start by checking if the sequence already satisfies the condition. If not, find the first element that does not satisfy the condition (a_i > i). Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence. Count the number of insertions performed.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Insertion Strategy': This involves inserting elements at appropriate positions to ensure the sequence meets a specific condition, in this case, ensuring that for every 1 ≤ i ≤ |a|, a_i ≤ i.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, the steps should be implemented sequentially:\n    1. Check if the sequence already satisfies the condition.\n    2. If not, find the first element that does not satisfy the condition (a_i > i).\n    3. Insert the value k = i at the beginning of the sequence to ensure it satisfies the condition.\n    4. Continue this process for each element that does not satisfy the condition, ensuring that each insertion places the new element in the correct position to maintain the order of the sequence.\n    5. Count the number of insertions performed.\n\n# [edge case] \n    Test Case:\n    1\n    3\n    1 3 4\n    \n    Expected Output: 1\n    Explanation: The sequence [1, 3, 4] does not satisfy the condition since a_2 = 3 > 2. By inserting 2 at the beginning, we get [2, 1, 3, 4], which satisfies the condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the insertion process."]
----------
False
----------
0
multi-gen-prompt:
 You are given a matrix with n rows and m columns. Each cell in the matrix contains an integer a_{ij}.

First, you need to color each row of the matrix either red or blue. You must ensure that at least one row is colored red and at least one row is colored blue.

Next, you must choose an integer k (1 ≤ k < m) and cut the matrix in such a way that the first k columns become one matrix (the left matrix), and the last m-k columns become another matrix (the right matrix).

The coloring and the cut are considered perfect if two

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.

Then the descriptions of t testcases follow.

The first line of each testcase contains two integers n and m (2 ≤ n, m ≤ 5 ⋅ 10^5; n ⋅ m ≤ 10^6) — the number of rows and the number of columns in the matrix, respectively.

The i-th of the next n lines contains m integers a_{i1}, a_{i2}, ..., a_{im} (1 ≤ a_{ij} ≤ 10^6).

The sum of n ⋅ m over all testcases doesn't exceed 10^6.

Output

For each testcase print an answer. If there are no perfect colorings and cuts in the matrix, then print "NO".

Otherwise, first, print "YES". Then a string, consisting of n characters: the i-th character should be 'R' if the i-th row is colored red and 'B' if it's colored blue. The string should contain at least one 'R' and at least one 'B'. Finally, print an integer k (1 ≤ k < m) — the number of columns from the left that are cut.

Example

Input


3
5 5
1 5 8 8 7
5 2 1 4 3
1 6 9 7 5
9 3 3 3 2
1 7 9 9 8
3 3
8 9 8
1 5 3
7 5 7
2 6
3 3 3 2 2 2
1 1 1 4 4 4


Output


YES
BRBRB 1
NO
YES
RB 3

Note

The coloring and the cut for the first testcase:

<image>
multi-gen-prompt:
 You are given a matrix with n rows and m columns, where the cell in the j-th column of the i-th row contains the integer a_{ij}. You need to color each row either red or blue such that at least one row is red and at least one row is blue. Then, choose an integer k (1 ≤ k < m) to cut the matrix into two matrices: the left matrix with the first k columns and the right matrix with the last m-k columns. The coloring and cut are perfect if every red cell in the left matrix has a value greater than every blue cell in the left matrix

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.

Then the descriptions of t testcases follow.

The first line of each testcase contains two integers n and m (2 ≤ n, m ≤ 5 ⋅ 10^5; n ⋅ m ≤ 10^6) — the number of rows and the number of columns in the matrix, respectively.

The i-th of the next n lines contains m integers a_{i1}, a_{i2}, ..., a_{im} (1 ≤ a_{ij} ≤ 10^6).

The sum of n ⋅ m over all testcases doesn't exceed 10^6.

Output

For each testcase print an answer. If there are no perfect colorings and cuts in the matrix, then print "NO".

Otherwise, first, print "YES". Then a string, consisting of n characters: the i-th character should be 'R' if the i-th row is colored red and 'B' if it's colored blue. The string should contain at least one 'R' and at least one 'B'. Finally, print an integer k (1 ≤ k < m) — the number of columns from the left that are cut.

Example

Input


3
5 5
1 5 8 8 7
5 2 1 4 3
1 6 9 7 5
9 3 3 3 2
1 7 9 9 8
3 3
8 9 8
1 5 3
7 5 7
2 6
3 3 3 2 2 2
1 1 1 4 4 4


Output


YES
BRBRB 1
NO
YES
RB 3

Note

The coloring and the cut for the first testcase:

<image>
generating with deepseek-coder
----------
['def find_perfect_coloring_and_cut(matrix, n, m):\n    # Sort rows based on the first column\n    sorted_rows = sorted(range(n), key=lambda i: matrix[i][0])\n    \n    # Try to find a perfect coloring and cut\n    for k in range(1, m):\n        # Initialize colors for rows\n        colors = [\'\'] * n\n        for i in range(n // 2):\n            colors[sorted_rows[i]] = \'B\'\n        for i in range(n // 2, n):\n            colors[sorted_rows[i]] = \'R\'\n        \n        # Check if the current coloring and cut is perfect\n        left_max = [float(\'-inf\')] * m\n        right_max = [float(\'-inf\')] * m\n        for i in range(n):\n            for j in range(m):\n                if colors[i] == \'R\':\n                    left_max[j] = max(left_max[j], matrix[i][j])\n                else:\n                    right_max[j] = max(right_max[j], matrix[i][j])\n        \n        # Check the conditions for a perfect coloring and cut\n        perfect = True\n        for j in range(m):\n            if left_max[j] <= right_max[j]:\n                perfect = False\n                break\n        \n        if perfect:\n            return "YES", \'\'.join(colors), k + 1\n    \n    return "NO", "", 0\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        matrix = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                row.append(int(data[index]))\n                index += 1\n            matrix.append(row)\n        \n        result, colors, k = find_perfect_coloring_and_cut(matrix, n, m)\n        results.append((result, colors, k))\n    \n    for result, colors, k in results:\n        if result == "YES":\n            print(result)\n            print(colors)\n            print(k)\n        else:\n            print(result)', 'def can_color_and_cut(matrix, n, m, k):\n    # Create arrays to store the maximum values for red and blue rows in the left and right matrices\n    max_red_left = [0] * n\n    max_blue_left = [0] * n\n    max_blue_right = [0] * n\n    max_red_right = [0] * n\n    \n    # Calculate the maximum values for red and blue rows in the left and right matrices\n    for i in range(n):\n        for j in range(k):\n            if matrix[i][j] == 1:\n                max_red_left[i] = 1\n            elif matrix[i][j] == 2:\n                max_blue_left[i] = 1\n        for j in range(k, m):\n            if matrix[i][j] == 1:\n                max_red_right[i] = 1\n            elif matrix[i][j] == 2:\n                max_blue_right[i] = 1\n    \n    # Check if the coloring satisfies the conditions for the left and right matrices\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if max_red_left[i] == 1 and max_blue_left[j] == 1:\n                    return False\n                if max_blue_right[i] == 1 and max_red_right[j] == 1:\n                    return False\n    return True\n\ndef find_perfect_coloring_and_cut(matrix, n, m):\n    # Binary search to find the optimal cut\n    low, high = 1, m - 1\n    best_k = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if can_color_and_cut(matrix, n, m, mid):\n            best_k = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Check if a valid coloring and cut exist for the best k found by binary search\n    if best_k == 0:\n        return "NO"\n    else:\n        color = ""\n        for i in range(n):\n            if can_color_and_cut(matrix, n, m, best_k):\n                color = \'R\' * n if i % 2 == 0 else \'B\' * n\n                break\n            else:\n                color = \'R\' * n if i % 2 == 0 else \'B\' * n\n        return f"YES\\n{color} {best_k}"\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        matrix = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                row.append(int(data[index]))\n                index += 1\n            matrix.append(row)\n        results.append(find_perfect_coloring_and_cut(matrix, n, m))\n    \n    for result in results:\n        print(result)', 'def find_perfect_coloring_and_cut(matrix, n, m):\n    # Try all possible cuts\n    for k in range(1, m):\n        # Initialize color arrays for red and blue\n        red = [False] * n\n        blue = [False] * n\n        \n        # Assign colors based on the sorted matrix\n        for i in range(n):\n            for j in range(k):\n                if matrix[i][j] > matrix[i][k]:\n                    red[i] = True\n                else:\n                    blue[i] = True\n            for j in range(k, m):\n                if matrix[i][j] < matrix[i][k]:\n                    blue[i] = True\n                else:\n                    red[i] = True\n        \n        # Check if the current coloring and cut is perfect\n        if is_perfect(matrix, red, blue, k):\n            return True, red, blue, k\n    \n    return False, None, None, None\n\ndef is_perfect(matrix, red, blue, k):\n    n = len(matrix)\n    m = len(matrix[0])\n    \n    # Check the left matrix\n    for i in range(n):\n        for j in range(k):\n            for l in range(k, m):\n                if red[i] and blue[i] and matrix[i][j] >= matrix[i][l]:\n                    return False\n                if not red[i] and not blue[i] and matrix[i][j] <= matrix[i][l]:\n                    return False\n    \n    # Check the right matrix\n    for i in range(n):\n        for j in range(k, m):\n            for l in range(k):\n                if red[i] and blue[i] and matrix[i][j] <= matrix[i][l]:\n                    return False\n                if not red[i] and not blue[i] and matrix[i][j] >= matrix[i][l]:\n                    return False\n    \n    return True\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        matrix = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                row.append(int(data[index]))\n                index += 1\n            matrix.append(row)\n        \n        found, red, blue, k = find_perfect_coloring_and_cut(matrix, n, m)\n        if found:\n            results.append("YES")\n            color_string = \'\'.join(\'R\' if r else \'B\' for r in red)\n            results.append(color_string)\n            results.append(str(k))\n        else:\n            results.append("NO")\n    \n    for result in results:\n        print(result)', 'def solve_test_case(n, m, matrix):\n    # Try coloring the first row red and the rest blue\n    coloring = [\'R\'] + [\'B\'] * (n - 1)\n    for k in range(m):\n        left_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        left_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        right_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        right_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        \n        if left_red and left_blue and any(left_red[i] <= left_blue[j] for i in range(len(left_red)) for j in range(len(left_blue))):\n            continue\n        else:\n            return \'YES\', \'\'.join(coloring), k + 1\n    \n    # Try coloring the first row blue and the rest red\n    coloring = [\'B\'] + [\'R\'] * (n - 1)\n    for k in range(m):\n        left_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        left_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        right_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        right_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        \n        if left_red and left_blue and any(left_red[i] <= left_blue[j] for i in range(len(left_red)) for j in range(len(left_blue))):\n            continue\n        else:\n            return \'YES\', \'\'.join(coloring), k + 1\n    \n    return \'NO\', \'\', 0\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [list(map(int, input().split())) for _ in range(n)]\n        result, coloring, k = solve_test_case(n, m, matrix)\n        if result == \'YES\':\n            print(result)\n            print(coloring, k)\n        else:\n            print(result)\n\nif __name__ == "__main__":\n    main()', 'def can_color_and_cut(matrix, n, m):\n    # Check if it\'s possible to color the rows such that at least one row is red and at least one row is blue.\n    for i in range(n):\n        for j in range(i + 1, n):\n            red_row = False\n            blue_row = False\n            for k in range(m):\n                if matrix[i][k] > matrix[j][k]:\n                    red_row = True\n                elif matrix[i][k] < matrix[j][k]:\n                    blue_row = True\n                if red_row and blue_row:\n                    return True, \'R\' if i else \'B\', 1\n    return False, \'\', 0\n\ndef find_best_cut(matrix, n, m):\n    # Use a greedy approach to find the best cut.\n    for k in range(1, m):\n        left_red = set()\n        left_blue = set()\n        right_red = set()\n        right_blue = set()\n        \n        for i in range(n):\n            if all(matrix[i][j] < matrix[i][k] for j in range(k)):\n                left_red.add(i)\n            else:\n                left_blue.add(i)\n            if all(matrix[i][j] > matrix[i][k] for j in range(k, m)):\n                right_red.add(i)\n            else:\n                right_blue.add(i)\n        \n        if left_red and right_blue:\n            return True, left_red, left_blue, right_red, right_blue, k\n    return False, [], [], [], [], 0\n\ndef solve():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [list(map(int, input().split())) for _ in range(n)]\n        \n        possible, color, k = can_color_and_cut(matrix, n, m)\n        if not possible:\n            results.append("NO")\n        else:\n            results.append("YES")\n            results.append(color * n + " " + str(k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    solve()', 'def solve_test_case(n, m, matrix):\n    # Try coloring the first row red and the rest blue\n    coloring = [\'R\'] + [\'B\'] * (n - 1)\n    for k in range(m):\n        left_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        left_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        right_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        right_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        \n        if left_red and left_blue and any(left_red[i] <= left_blue[j] for i in range(len(left_red)) for j in range(len(left_blue))):\n            continue\n        else:\n            return \'YES\', \'\'.join(coloring), k + 1\n    \n    # Try coloring the first row blue and the rest red\n    coloring = [\'B\'] + [\'R\'] * (n - 1)\n    for k in range(m):\n        left_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        left_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        right_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        right_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        \n        if left_red and left_blue and any(left_red[i] <= left_blue[j] for i in range(len(left_red)) for j in range(len(left_blue))):\n            continue\n        else:\n            return \'YES\', \'\'.join(coloring), k + 1\n    \n    return \'NO\', \'\', 0\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [list(map(int, input().split())) for _ in range(n)]\n        result, coloring, k = solve_test_case(n, m, matrix)\n        if result == \'YES\':\n            print(result)\n            print(coloring, k)\n        else:\n            print(result)\n\nif __name__ == "__main__":\n    main()', 'def solve_test_case(n, m, matrix):\n    # Try coloring the first row red and the rest blue\n    coloring = [\'R\'] + [\'B\'] * (n - 1)\n    for k in range(m):\n        left_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        left_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        right_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        right_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        \n        if left_red and left_blue and any(left_red[i] <= left_blue[j] for i in range(len(left_red)) for j in range(len(left_blue))):\n            continue\n        else:\n            return \'YES\', \'\'.join(coloring), k + 1\n    \n    # Try coloring the first row blue and the rest red\n    coloring = [\'B\'] + [\'R\'] * (n - 1)\n    for k in range(m):\n        left_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        left_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        right_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        right_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        \n        if left_red and left_blue and any(left_red[i] <= left_blue[j] for i in range(len(left_red)) for j in range(len(left_blue))):\n            continue\n        else:\n            return \'YES\', \'\'.join(coloring), k + 1\n    \n    return \'NO\', \'\', 0\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [list(map(int, input().split())) for _ in range(n)]\n        result, coloring, k = solve_test_case(n, m, matrix)\n        if result == \'YES\':\n            print(result)\n            print(coloring, k)\n        else:\n            print(result)\n\nif __name__ == "__main__":\n    main()', 'def can_color_and_cut(matrix, n, m, k):\n    # Create arrays to store the maximum values for red and blue rows in the left and right matrices\n    max_red_left = [0] * n\n    max_blue_left = [0] * n\n    max_blue_right = [0] * n\n    max_red_right = [0] * n\n    \n    # Calculate the maximum values for red and blue rows in the left and right matrices\n    for i in range(n):\n        for j in range(k):\n            if matrix[i][j] == 1:\n                max_red_left[i] = 1\n            elif matrix[i][j] == 2:\n                max_blue_left[i] = 1\n        for j in range(k, m):\n            if matrix[i][j] == 1:\n                max_red_right[i] = 1\n            elif matrix[i][j] == 2:\n                max_blue_right[i] = 1\n    \n    # Check if the coloring satisfies the conditions for the left and right matrices\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if max_red_left[i] == 1 and max_blue_left[j] == 1:\n                    return False\n                if max_blue_right[i] == 1 and max_red_right[j] == 1:\n                    return False\n    return True\n\ndef find_perfect_coloring_and_cut(matrix, n, m):\n    # Binary search to find the optimal cut\n    low, high = 1, m - 1\n    best_k = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if can_color_and_cut(matrix, n, m, mid):\n            best_k = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Check if a valid coloring and cut exist for the best k found by binary search\n    if best_k == 0:\n        return "NO"\n    else:\n        color = ""\n        for i in range(n):\n            if can_color_and_cut(matrix, n, m, best_k):\n                color = \'R\' * n if i % 2 == 0 else \'B\' * n\n                break\n            else:\n                color = \'R\' * n if i % 2 == 0 else \'B\' * n\n        return f"YES\\n{color} {best_k}"\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        matrix = []\n        for i in range(n):\n            row = []\n            for j in range(m):\n                row.append(int(data[index]))\n                index += 1\n            matrix.append(row)\n        results.append(find_perfect_coloring_and_cut(matrix, n, m))\n    \n    for result in results:\n        print(result)', 'def can_color_and_cut(matrix, n, m):\n    # Check if it\'s possible to color the rows such that at least one row is red and at least one row is blue.\n    for i in range(n):\n        for j in range(i + 1, n):\n            red_row = False\n            blue_row = False\n            for k in range(m):\n                if matrix[i][k] > matrix[j][k]:\n                    red_row = True\n                elif matrix[i][k] < matrix[j][k]:\n                    blue_row = True\n                if red_row and blue_row:\n                    return True, \'R\' if i else \'B\', 1\n    return False, \'\', 0\n\ndef find_best_cut(matrix, n, m):\n    # Use a greedy approach to find the best cut.\n    for k in range(1, m):\n        left_red = set()\n        left_blue = set()\n        right_red = set()\n        right_blue = set()\n        \n        for i in range(n):\n            if all(matrix[i][j] < matrix[i][k] for j in range(k)):\n                left_red.add(i)\n            else:\n                left_blue.add(i)\n            if all(matrix[i][j] > matrix[i][k] for j in range(k, m)):\n                right_red.add(i)\n            else:\n                right_blue.add(i)\n        \n        if left_red and right_blue:\n            return True, left_red, left_blue, right_red, right_blue, k\n    return False, [], [], [], [], 0\n\ndef solve():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [list(map(int, input().split())) for _ in range(n)]\n        \n        possible, color, k = can_color_and_cut(matrix, n, m)\n        if not possible:\n            results.append("NO")\n        else:\n            results.append("YES")\n            results.append(color * n + " " + str(k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    solve()', 'def solve_test_case(n, m, matrix):\n    # Try coloring the first row red and the rest blue\n    coloring = [\'R\'] + [\'B\'] * (n - 1)\n    for k in range(m):\n        left_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        left_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        right_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        right_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        \n        if left_red and left_blue and any(left_red[i] <= left_blue[j] for i in range(len(left_red)) for j in range(len(left_blue))):\n            continue\n        else:\n            return \'YES\', \'\'.join(coloring), k + 1\n    \n    # Try coloring the first row blue and the rest red\n    coloring = [\'B\'] + [\'R\'] * (n - 1)\n    for k in range(m):\n        left_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        left_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        right_red = [matrix[i][k] for i in range(n) if coloring[i] == \'R\']\n        right_blue = [matrix[i][k] for i in range(n) if coloring[i] == \'B\']\n        \n        if left_red and left_blue and any(left_red[i] <= left_blue[j] for i in range(len(left_red)) for j in range(len(left_blue))):\n            continue\n        else:\n            return \'YES\', \'\'.join(coloring), k + 1\n    \n    return \'NO\', \'\', 0\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, m = map(int, input().split())\n        matrix = [list(map(int, input().split())) for _ in range(n)]\n        result, coloring, k = solve_test_case(n, m, matrix)\n        if result == \'YES\':\n            print(result)\n            print(coloring, k)\n        else:\n            print(result)\n\nif __name__ == "__main__":\n    main()']
----------
['- name: \nGreedy Approach with Sorting\n- content: \nWe can use a greedy approach to try to find a perfect coloring and cut. We will try to color the rows in such a way that we can always make the cut between the red and blue rows. We will sort the rows based on their maximum value and then try to color them accordingly.\n\n**Steps:**\n1. Sort the rows based on their maximum value.\n2. Color the first half of the sorted rows red and the second half blue.\n3. Choose the cut as the middle column (m//2).\n4. Check if the conditions for a perfect coloring and cut are met.\n5. If a valid solution is found, output "YES" and the coloring and cut.\n6. If no valid solution is found, output "NO".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'matrix\': a grid of numbers with rows and columns\n    \'coloring\': assigning colors (red or blue) to rows\n    \'cutting\': dividing the matrix into two parts by selecting a number of columns\n    \'perfect coloring and cut\': ensuring that the division is optimal based on the values in the matrix\n\n# [phrase showing quantity relationship]\n    \'at least as many times\': means the frequency of an integer in the matrix is greater than or equal to the integer itself\n\n# [degree adverb] \n    \'largest\': means the maximum value in a row or column\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Edge case 1:\n    Input: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Explanation: The matrix has three rows and three columns. The largest value in each row is 3, 6, and 9 respectively. A possible perfect coloring and cut is to color the first and second rows blue and the third row red, and cut after the first column. This satisfies the conditions because the red row (7, 8, 9) has the largest values in the left matrix and the blue rows (1, 2, 3) and (4, 5, 6) have their largest values in the right matrix.\n    Edge case 2:\n    Input: [[3, 3, 3], [2, 2, 2], [1, 1, 1]]\n    Explanation: The matrix has three rows and three columns. All rows have the same values. A perfect coloring and cut is not possible because no row can be distinguished as red or blue without violating the conditions.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where no perfect coloring and cut is possible.\n        if no valid coloring and cut is found:\n            return "NO"\n\n    This code checks if a valid configuration is found and returns "NO" if not.', '- name: \nDivide and Conquer with Binary Search\n\n- content: \nWe can use a divide and conquer approach with binary search to solve the problem. The idea is to use binary search to find the optimal cut and then check if we can color the rows such that the condition is satisfied for that cut. This approach involves more complex logic but can handle larger inputs efficiently.\n\nAlgorithm:\n1. For each test case, use binary search to find the optimal cut (k).\n2. For each candidate cut, check if there\'s a way to color the rows such that the condition is satisfied for the left and right matrices.\n3. This involves comparing elements across rows and columns to determine valid colorings.\n4. If a valid coloring is found, output "YES" with the result.\n5. If no valid coloring is found after all binary search iterations, output "NO".\n\nThis approach requires careful implementation to handle large inputs efficiently and correctly.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'matrix\': a grid of numbers with rows and columns\n    \'coloring\': assigning colors (red or blue) to rows\n    \'cutting\': dividing the matrix into two parts by selecting a number of columns (k)\n    \'perfect coloring and cut\': ensuring that the left matrix has all red cells greater than all blue cells and vice versa for the right matrix\n\n# [phrase showing quantity relationship]\n    \'at least one row\': means there must be at least one red row and one blue row\n    \'at least as many times\': means the frequency of an integer in a row should be greater than or equal to the integer itself\n\n# [degree adverb] \n    \'largest\': means finding the maximum integer in the matrix\n\n# [code logic]\n    The steps should be implemented sequentially.\n    1. Use binary search to find the optimal cut.\n    2. For each candidate cut, check all possible colorings of the rows.\n    3. Verify if the coloring satisfies the conditions for the left and right matrices.\n    4. If a valid coloring is found, output the result.\n    5. If no valid coloring is found after all iterations, output "NO".\n\n# [edge case] \n    testcase: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    expected output: "YES\\nRB 1"\n    Explanation:\n    - The matrix has 3 rows and 3 columns.\n    - A possible perfect coloring is to color the first row red and the second row blue.\n    - The cut can be after the first column, making the left matrix [[1], [4], [7]] and the right matrix [[2, 3], [5, 6], [8, 9]].\n    - The red cells in the left matrix (1, 7) are all greater than the blue cell in the left matrix (4).\n    - The blue cells in the right matrix (5, 6, 8, 9) are all greater than the red cells in the right matrix (2, 3).\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case as the problem statement does not specify any additional edge cases beyond the given constraints. The provided solution should work for the given matrix structure.', '- name: \nGreedy Approach with Early Termination\n- content: \nThis approach involves a greedy strategy to find a solution if it exists. We will try to color the rows in such a way that we can find a cut that satisfies the perfect conditions. \n\n**Solution Approach:**\n1. For each test case, attempt to color the first row red and the rest blue. Check if this coloring and any cut satisfy the perfect conditions.\n2. If not found, attempt to color the first row blue and the rest red. Check again for any valid cut.\n3. If still not found, attempt to color the second row red and the rest blue, starting from the next row after the first row. Check for a valid cut.\n4. Repeat this process until a valid coloring and cut are found or all possibilities are exhausted.\n5. If a valid combination is found, print "YES" and the corresponding coloring and cut. If no valid combination is found, print "NO".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'matrix\': a grid of numbers with rows and columns\n    \'coloring\': assigning colors (red or blue) to rows\n    \'cutting\': dividing the matrix into two parts by selecting a number of columns (k)\n    \'perfect conditions\': ensuring that the integers in the left matrix are greater than those in the right matrix based on the coloring\n\n# [phrase showing quantity relationship]\n    \'at least as many times\': means the frequency of an integer in a row should be considered\n\n# [degree adverb] \n    \'largest\': means finding the maximum or minimum value in a row or column\n\n# [code logic]\n    The steps should be implemented sequentially as they build upon each other.\n    - First, color the rows either red or blue.\n    - Then, choose a cut (k) and split the matrix.\n    - Check the perfect conditions for the left and right matrices.\n\n# [edge case] \n    Edge case 1:\n    Input: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    Explanation: There is no way to color the rows such that the perfect conditions are met.\n    Expected Output: NO\n\n    Edge case 2:\n    Input: [[3, 3, 3], [2, 2, 2], [1, 1, 1]]\n    Explanation: All rows are the same, so any coloring will fail the perfect conditions.\n    Expected Output: NO\n\n    Edge case 3:\n    Input: [[1, 3, 2], [4, 6, 5], [7, 9, 8]]\n    Explanation: A valid coloring could be R, B, R. A valid cut could be after the first column.\n    Expected Output: YES\n    Coloring: RBR\n    Cut: k=1\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the matrix does not allow for a valid coloring and cut.\n    Example:\n    ```python\n    def find_perfect_coloring_and_cut(matrix):\n        n, m = len(matrix), len(matrix[0])\n        for i in range(n):\n            for j in range(i+1, n):\n                # Try coloring rows i and j red and the rest blue\n                coloring = [\'B\'] * n\n                coloring[i] = \'R\'\n                coloring[j] = \'R\'\n                for k in range(m):\n                    left_matrix = [row[:k+1] for row in matrix]\n                    right_matrix = [row[k+1:] for row in matrix]\n                    if is_perfect(left_matrix, right_matrix, coloring):\n                        return \'YES\', \'\'.join(coloring), k+1\n        return \'NO\', \'\', 0\n    ```\n    This code tries different combinations of red and blue rows and checks if a valid cut exists.', '- name: \nRow Coloring and Column Cutting\n\n- content: \nFor each test case, we will follow these steps:\n1. Iterate through each possible column cut (k from 1 to m-1).\n2. For each cut, try to color the rows such that all red cells in the left matrix have values greater than all blue cells in the left matrix.\n3. Use a brute force approach to check all possible colorings. For each coloring, we will:\n   - Assign \'R\' or \'B\' to each row.\n   - Check the condition for the left matrix after the cut.\n4. If a valid coloring and cut is found, output "YES" and the coloring string along with the cut index k.\n5. If no valid coloring and cut is found after checking all possibilities, output "NO".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'matrix\': a grid of numbers with rows and columns\n    \'coloring\': assigning colors (red or blue) to rows\n    \'cutting\': dividing the matrix into two parts by a column\n    \'perfect coloring\': ensuring all red cells in the left matrix have values greater than all blue cells in the left matrix\n\n# [phrase showing quantity relationship]\n    \'at least one row\': means there must be at least one red row and one blue row\n    \'at least one column\': means the cut must be made between at least one pair of columns\n\n# [degree adverb] \n    \'greatest\': means finding the maximum value in the matrix\n\n# [code logic]\n    The steps 2-4 should be considered simultaneously. For each possible cut, we need to:\n    - Iterate through each row and assign \'R\' or \'B\'\n    - Check the condition for the left matrix after the cut\n    - If the condition is met, output the result\n\n# [edge case] \n    Edge case 1:\n    Input: 1 1\n    10\n    Expected output: NO\n    Explanation: There\'s only one row and one column, so it\'s impossible to color and cut the matrix.\n\n    Edge case 2:\n    Input: 2 2\n    1 2\n    3 4\n    Expected output: YES\n    RB 1\n    Explanation: We can color the first row red and the second row blue, then cut after the first column. The left matrix will have all red cells with values less than all blue cells.\n\n    Edge case 3:\n    Input: 3 3\n    1 2 3\n    4 5 6\n    7 8 9\n    Expected output: YES\n    RBR\n    2\n    Explanation: We can color the first and second rows red and the third row blue, then cut after the second column. The left matrix will have all red cells with values less than all blue cells.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the matrix has only one row or one column.\n    For example:\n    if n == 1 or m == 1:\n        return "NO"\n    This ensures that we don\'t attempt to color and cut a matrix that cannot be split.', "- name: \nMatrix Partitioning with Two-Pointer Technique\n\n- content: \nWe can use a two-pointer technique to find the best cut. First, we will color the rows such that the maximum value in a red row is less than the minimum value in a blue row. Then, we will use two pointers to find the best cut. One pointer will track the maximum value in the left matrix and the other will track the minimum value in the right matrix. This approach is efficient and can handle large inputs effectively.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Matrix Partitioning': The process of dividing a matrix into two submatrices (left and right) based on a specific condition, in this case, ensuring that the maximum value in the red rows is less than the minimum value in the blue rows.\n\n# [phrase showing quantity relationship]\n    'at least one row': means that there should be at least one red row and one blue row in the matrix.\n    'at least one column': means that the cut should be made in such a way that the matrix is divided into two parts.\n\n# [degree adverb] \n    'perfect': means that the condition of the red row having a maximum value less than the blue row's minimum value is strictly adhered to.\n\n# [code logic]\n    The steps should be implemented sequentially. First, color the rows, then find the best cut using the two-pointer technique.\n\n# [edge case] \n    Edge case 1:\n    Input: [[1, 2], [3, 4]], Output: YES, RB, 1\n    Explanation: The matrix has only two rows and two columns. We can color the first row red and the second row blue. The cut can be made after the first column, ensuring the red row's maximum value (2) is less than the blue row's minimum value (3).\n\n    Edge case 2:\n    Input: [[5, 4], [3, 2]], Output: NO\n    Explanation: There is no way to color the rows such that the red row's maximum value is less than the blue row's minimum value. Therefore, no perfect coloring and cut is possible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided in the plan should be sufficient for the given constraints.", '- name: \nRow Coloring and Column Cutting\n\n- content: \nFor each test case, we will follow these steps:\n1. Iterate through each possible column cut (k from 1 to m-1).\n2. For each cut, try to color the rows such that all red cells in the left matrix have values greater than all blue cells in the left matrix.\n3. Use a brute force approach to check all possible colorings. For each coloring, we will:\n   - Assign \'R\' or \'B\' to each row.\n   - Check the condition for the left matrix after the cut.\n4. If a valid coloring and cut is found, output "YES" and the coloring string along with the cut index k.\n5. If no valid coloring and cut is found after checking all possibilities, output "NO".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'matrix\': a grid of numbers with rows and columns\n    \'coloring\': assigning colors (red or blue) to rows\n    \'cutting\': dividing the matrix into two parts by a column\n    \'perfect coloring\': ensuring all red cells in the left matrix have values greater than all blue cells in the left matrix\n\n# [phrase showing quantity relationship]\n    \'at least one row\': means there must be at least one red row and one blue row\n    \'at least one column\': means the cut must be made between at least one pair of columns\n\n# [degree adverb] \n    \'greatest\': means finding the maximum value in the matrix\n\n# [code logic]\n    The steps 2-4 should be considered simultaneously. For each possible cut, we need to:\n    - Iterate through each row and assign \'R\' or \'B\'\n    - Check the condition for the left matrix after the cut\n    - If the condition is met, output the result\n\n# [edge case] \n    Edge case 1:\n    Input: 1 1\n    10\n    Expected output: NO\n    Explanation: There\'s only one row and one column, so it\'s impossible to color and cut the matrix.\n\n    Edge case 2:\n    Input: 2 2\n    1 2\n    3 4\n    Expected output: YES\n    RB 1\n    Explanation: We can color the first row red and the second row blue, then cut after the first column. The left matrix will have all red cells with values less than all blue cells.\n\n    Edge case 3:\n    Input: 3 3\n    1 2 3\n    4 5 6\n    7 8 9\n    Expected output: YES\n    RBR\n    2\n    Explanation: We can color the first and second rows red and the third row blue, then cut after the second column. The left matrix will have all red cells with values less than all blue cells.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the matrix has only one row or one column.\n    For example:\n    if n == 1 or m == 1:\n        return "NO"\n    This ensures that we don\'t attempt to color and cut a matrix that cannot be split.', '- name: \nRow Coloring and Column Cutting\n\n- content: \nFor each test case, we will follow these steps:\n1. Iterate through each possible column cut (k from 1 to m-1).\n2. For each cut, try to color the rows such that all red cells in the left matrix have values greater than all blue cells in the left matrix.\n3. Use a brute force approach to check all possible colorings. For each coloring, we will:\n   - Assign \'R\' or \'B\' to each row.\n   - Check the condition for the left matrix after the cut.\n4. If a valid coloring and cut is found, output "YES" and the coloring string along with the cut index k.\n5. If no valid coloring and cut is found after checking all possibilities, output "NO".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'matrix\': a grid of numbers with rows and columns\n    \'coloring\': assigning colors (red or blue) to rows\n    \'cutting\': dividing the matrix into two parts by a column\n    \'perfect coloring\': ensuring all red cells in the left matrix have values greater than all blue cells in the left matrix\n\n# [phrase showing quantity relationship]\n    \'at least one row\': means there must be at least one red row and one blue row\n    \'at least one column\': means the cut must be made between at least one pair of columns\n\n# [degree adverb] \n    \'greatest\': means finding the maximum value in the matrix\n\n# [code logic]\n    The steps 2-4 should be considered simultaneously. For each possible cut, we need to:\n    - Iterate through each row and assign \'R\' or \'B\'\n    - Check the condition for the left matrix after the cut\n    - If the condition is met, output the result\n\n# [edge case] \n    Edge case 1:\n    Input: 1 1\n    10\n    Expected output: NO\n    Explanation: There\'s only one row and one column, so it\'s impossible to color and cut the matrix.\n\n    Edge case 2:\n    Input: 2 2\n    1 2\n    3 4\n    Expected output: YES\n    RB 1\n    Explanation: We can color the first row red and the second row blue, then cut after the first column. The left matrix will have all red cells with values less than all blue cells.\n\n    Edge case 3:\n    Input: 3 3\n    1 2 3\n    4 5 6\n    7 8 9\n    Expected output: YES\n    RBR\n    2\n    Explanation: We can color the first and second rows red and the third row blue, then cut after the second column. The left matrix will have all red cells with values less than all blue cells.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the matrix has only one row or one column.\n    For example:\n    if n == 1 or m == 1:\n        return "NO"\n    This ensures that we don\'t attempt to color and cut a matrix that cannot be split.', '- name: \nDivide and Conquer with Binary Search\n\n- content: \nWe can use a divide and conquer approach with binary search to solve the problem. The idea is to use binary search to find the optimal cut and then check if we can color the rows such that the condition is satisfied for that cut. This approach involves more complex logic but can handle larger inputs efficiently.\n\nAlgorithm:\n1. For each test case, use binary search to find the optimal cut (k).\n2. For each candidate cut, check if there\'s a way to color the rows such that the condition is satisfied for the left and right matrices.\n3. This involves comparing elements across rows and columns to determine valid colorings.\n4. If a valid coloring is found, output "YES" with the result.\n5. If no valid coloring is found after all binary search iterations, output "NO".\n\nThis approach requires careful implementation to handle large inputs efficiently and correctly.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'matrix\': a grid of numbers with rows and columns\n    \'coloring\': assigning colors (red or blue) to rows\n    \'cutting\': dividing the matrix into two parts by selecting a number of columns (k)\n    \'perfect coloring and cut\': ensuring that the left matrix has all red cells greater than all blue cells and vice versa for the right matrix\n\n# [phrase showing quantity relationship]\n    \'at least one row\': means there must be at least one red row and one blue row\n    \'at least as many times\': means the frequency of an integer in a row should be greater than or equal to the integer itself\n\n# [degree adverb] \n    \'largest\': means finding the maximum integer in the matrix\n\n# [code logic]\n    The steps should be implemented sequentially.\n    1. Use binary search to find the optimal cut.\n    2. For each candidate cut, check all possible colorings of the rows.\n    3. Verify if the coloring satisfies the conditions for the left and right matrices.\n    4. If a valid coloring is found, output the result.\n    5. If no valid coloring is found after all iterations, output "NO".\n\n# [edge case] \n    testcase: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    expected output: "YES\\nRB 1"\n    Explanation:\n    - The matrix has 3 rows and 3 columns.\n    - A possible perfect coloring is to color the first row red and the second row blue.\n    - The cut can be after the first column, making the left matrix [[1], [4], [7]] and the right matrix [[2, 3], [5, 6], [8, 9]].\n    - The red cells in the left matrix (1, 7) are all greater than the blue cell in the left matrix (4).\n    - The blue cells in the right matrix (5, 6, 8, 9) are all greater than the red cells in the right matrix (2, 3).\n\n# [extra code for edge case]\n    We do not need extra code to handle this edge case as the problem statement does not specify any additional edge cases beyond the given constraints. The provided solution should work for the given matrix structure.', "- name: \nMatrix Partitioning with Two-Pointer Technique\n\n- content: \nWe can use a two-pointer technique to find the best cut. First, we will color the rows such that the maximum value in a red row is less than the minimum value in a blue row. Then, we will use two pointers to find the best cut. One pointer will track the maximum value in the left matrix and the other will track the minimum value in the right matrix. This approach is efficient and can handle large inputs effectively.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Matrix Partitioning': The process of dividing a matrix into two submatrices (left and right) based on a specific condition, in this case, ensuring that the maximum value in the red rows is less than the minimum value in the blue rows.\n\n# [phrase showing quantity relationship]\n    'at least one row': means that there should be at least one red row and one blue row in the matrix.\n    'at least one column': means that the cut should be made in such a way that the matrix is divided into two parts.\n\n# [degree adverb] \n    'perfect': means that the condition of the red row having a maximum value less than the blue row's minimum value is strictly adhered to.\n\n# [code logic]\n    The steps should be implemented sequentially. First, color the rows, then find the best cut using the two-pointer technique.\n\n# [edge case] \n    Edge case 1:\n    Input: [[1, 2], [3, 4]], Output: YES, RB, 1\n    Explanation: The matrix has only two rows and two columns. We can color the first row red and the second row blue. The cut can be made after the first column, ensuring the red row's maximum value (2) is less than the blue row's minimum value (3).\n\n    Edge case 2:\n    Input: [[5, 4], [3, 2]], Output: NO\n    Explanation: There is no way to color the rows such that the red row's maximum value is less than the blue row's minimum value. Therefore, no perfect coloring and cut is possible.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided in the plan should be sufficient for the given constraints.", '- name: \nRow Coloring and Column Cutting\n\n- content: \nFor each test case, we will follow these steps:\n1. Iterate through each possible column cut (k from 1 to m-1).\n2. For each cut, try to color the rows such that all red cells in the left matrix have values greater than all blue cells in the left matrix.\n3. Use a brute force approach to check all possible colorings. For each coloring, we will:\n   - Assign \'R\' or \'B\' to each row.\n   - Check the condition for the left matrix after the cut.\n4. If a valid coloring and cut is found, output "YES" and the coloring string along with the cut index k.\n5. If no valid coloring and cut is found after checking all possibilities, output "NO".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'matrix\': a grid of numbers with rows and columns\n    \'coloring\': assigning colors (red or blue) to rows\n    \'cutting\': dividing the matrix into two parts by a column\n    \'perfect coloring\': ensuring all red cells in the left matrix have values greater than all blue cells in the left matrix\n\n# [phrase showing quantity relationship]\n    \'at least one row\': means there must be at least one red row and one blue row\n    \'at least one column\': means the cut must be made between at least one pair of columns\n\n# [degree adverb] \n    \'greatest\': means finding the maximum value in the matrix\n\n# [code logic]\n    The steps 2-4 should be considered simultaneously. For each possible cut, we need to:\n    - Iterate through each row and assign \'R\' or \'B\'\n    - Check the condition for the left matrix after the cut\n    - If the condition is met, output the result\n\n# [edge case] \n    Edge case 1:\n    Input: 1 1\n    10\n    Expected output: NO\n    Explanation: There\'s only one row and one column, so it\'s impossible to color and cut the matrix.\n\n    Edge case 2:\n    Input: 2 2\n    1 2\n    3 4\n    Expected output: YES\n    RB 1\n    Explanation: We can color the first row red and the second row blue, then cut after the first column. The left matrix will have all red cells with values less than all blue cells.\n\n    Edge case 3:\n    Input: 3 3\n    1 2 3\n    4 5 6\n    7 8 9\n    Expected output: YES\n    RBR\n    2\n    Explanation: We can color the first and second rows red and the third row blue, then cut after the second column. The left matrix will have all red cells with values less than all blue cells.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the matrix has only one row or one column.\n    For example:\n    if n == 1 or m == 1:\n        return "NO"\n    This ensures that we don\'t attempt to color and cut a matrix that cannot be split.']
----------
False
----------
0
multi-gen-prompt:
 You are provided with a set of m strings and a tree structure consisting of n nodes. Each edge of the tree is labeled with a specific letter. Your task involves processing q queries, where each query is defined by four integers: u, v, l, and r. The term str(u,v) refers to the string formed by concatenating the letters found on the edges of the shortest path from node u to node v, in the order they are encountered during the traversal.

The objective is to determine the total number of occurrences of str(u,v) within the specified range of strings, which are indexed from

Input

The first line of the input contains three integers n, m and q (2 ≤ n ≤ 10^5, 1 ≤ m,q ≤ 10^5).

The i-th of the following n-1 lines contains two integers u_i, v_i and a lowercase Latin letter c_i (1 ≤ u_i, v_i ≤ n, u_i ≠ v_i), denoting the edge between nodes u_i, v_i with a character c_i on it. 

It's guaranteed that these edges form a tree.

The following m lines contain the strings consisting of lowercase Latin letters. The total length of those strings does not exceed 10^5.

Then q lines follow, each containing four integers u, v, l and r (1 ≤ u,v ≤ n, u ≠ v, 1 ≤ l ≤ r ≤ m), denoting the queries. 

Output

For each query print a single integer — the answer to the query.

Examples

Input


2 5 3
1 2 a
aab
abab
aaa
b
a
2 1 1 5
1 2 1 3
2 1 3 5


Output


8
7
4


Input


9 5 6
1 2 a
2 7 c
1 3 b
3 4 b
4 6 b
3 5 a
5 8 b
5 9 c
ababa
cabbb
bac
bbbac
abacaba
2 7 1 4
2 5 1 5
6 3 4 4
6 9 4 5
5 7 3 5
5 3 1 5


Output


3
4
2
1
1
10
multi-gen-prompt:
 You are provided with m strings and a tree with n nodes, where each edge has a specific letter. You need to handle q queries, each specified by four integers u, v, l, and r. The answer to each query is the total count of occurrences of str(u,v) within the strings indexed from l to r. Here, str(u,v) refers to the string formed by concatenating the letters along the edges of the shortest path from node u to node v.

Input

The first line of the input contains three integers n, m and q (2 ≤ n ≤ 10^5, 1 ≤ m,q ≤ 10^5).

The i-th of the following n-1 lines contains two integers u_i, v_i and a lowercase Latin letter c_i (1 ≤ u_i, v_i ≤ n, u_i ≠ v_i), denoting the edge between nodes u_i, v_i with a character c_i on it. 

It's guaranteed that these edges form a tree.

The following m lines contain the strings consisting of lowercase Latin letters. The total length of those strings does not exceed 10^5.

Then q lines follow, each containing four integers u, v, l and r (1 ≤ u,v ≤ n, u ≠ v, 1 ≤ l ≤ r ≤ m), denoting the queries. 

Output

For each query print a single integer — the answer to the query.

Examples

Input


2 5 3
1 2 a
aab
abab
aaa
b
a
2 1 1 5
1 2 1 3
2 1 3 5


Output


8
7
4


Input


9 5 6
1 2 a
2 7 c
1 3 b
3 4 b
4 6 b
3 5 a
5 8 b
5 9 c
ababa
cabbb
bac
bbbac
abacaba
2 7 1 4
2 5 1 5
6 3 4 4
6 9 4 5
5 7 3 5
5 3 1 5


Output


3
4
2
1
1
10
generating with deepseek-coder
----------
['import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.is_end_of_word = False\n        self.count = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            node = node.children[char]\n            node.count += 1\n        node.is_end_of_word = True\n    \n    def count_occurrences(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return 0\n            node = node.children[char]\n        return node.count\n\ndef build_tree(n, edges):\n    tree = defaultdict(list)\n    for u, v, c in edges:\n        tree[u].append((v, c))\n        tree[v].append((u, c))\n    return tree\n\ndef dfs(tree, node, parent):\n    edges = []\n    for child, edge in tree[node]:\n        if child != parent:\n            edges.append((node, child, edge))\n            edges.extend(dfs(tree, child, node))\n    return edges\n\ndef get_path_string(edges):\n    path_string = []\n    for u, v, edge in edges:\n        path_string.append(edge)\n    return \'\'.join(path_string)\n\nif __name__ == "__main__":\n    n, m, q = map(int, input().split())\n    edges = [tuple(input().split()) for _ in range(n - 1)]\n    strings = [input().strip() for _ in range(m)]\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    \n    tree = build_tree(n, edges)\n    \n    trie = Trie()\n    for string in strings:\n        trie.insert(string)\n    \n    results = []\n    \n    for u, v, l, r in queries:\n        path_edges = dfs(tree, u, -1)\n        path_string = get_path_string(path_edges)\n        count = 0\n        for i in range(l - 1, r):\n            count += trie.count_occurrences(strings[i - 1])\n        results.append(count)\n    \n    for result in results:\n        print(result)', 'import sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(node, parent, tree, letters):\n    stack = [(node, parent)]\n    while stack:\n        node, parent = stack.pop()\n        for child, letter in tree[node]:\n            if child != parent:\n                letters[child] = letters[node] + letter\n                stack.append((child, node))\n\ndef f1(n, m, q, edges, strings):\n    tree = defaultdict(list)\n    for u, v, c in edges:\n        tree[u].append((v, c))\n        tree[v].append((u, c))\n    \n    letters = [""] * (n + 1)\n    dfs(1, -1, tree, letters)\n    \n    results = []\n    for _ in range(q):\n        u, v, l, r = map(int, sys.stdin.readline().split())\n        path_str = letters[u] + letters[v].replace(letters[u], \'\', 1)\n        count = sum(s[l-1:r].count(path_str) for s in strings)\n        results.append(count)\n    \n    return results\n\nif __name__ == "__main__":\n    n, m, q = map(int, sys.stdin.readline().split())\n    edges = [tuple(sys.stdin.readline().split()) for _ in range(n-1)]\n    edges = [(int(u), int(v), c) for u, v, c in edges]\n    strings = [sys.stdin.readline().strip() for _ in range(m)]\n    \n    results = f1(n, m, q, edges, strings)\n    for result in results:\n        print(result)', 'import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput_lines = sys.stdin.readlines()\ninput_iter = iter(input_lines)\nn, m, q = map(int, next(input_iter).split())\n\n# Initialize tree structure\ntree = defaultdict(list)\nedges = []\nfor _ in range(n - 1):\n    u, v, c = next(input_iter).split()\n    u, v = int(u), int(v)\n    tree[u].append((v, c))\n    tree[v].append((u, c))\n    edges.append((u, v, c))\n\n# Read strings\nstrings = [next(input_iter).strip() for _ in range(m)]\n\n# Preprocess all paths in the tree\npaths = defaultdict(list)\n\ndef dfs(node, parent, path):\n    for child, edge in tree[node]:\n        if child != parent:\n            dfs(child, node, path + edge)\n    if node != parent:  # Avoid adding empty paths for root nodes\n        paths[node].append((parent, path))\n        paths[parent].append((node, path))\n\ndfs(1, 1, "")  # Start DFS from node 1 with an empty path\n\n# Process queries\nfor _ in range(q):\n    u, v, l, r = map(int, next(input_iter).split())\n    target_path = ""\n    # Find the shortest path between u and v\n    queue = deque([(u, "")])\n    visited = set([u])\n    while queue:\n        current, path = queue.popleft()\n        if current == v:\n            target_path = path\n            break\n        for neighbor, edge in tree[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + edge))\n    \n    # Count occurrences of the target path in the specified range of strings\n    count = 0\n    for i in range(l - 1, r):\n        count += strings[i].count(target_path)\n    \n    print(count)', 'import sys\nfrom collections import defaultdict\n\n# Read input\ninput_lines = sys.stdin.readlines()\ninput_iter = iter(input_lines)\nn, m, q = map(int, next(input_iter).split())\n\n# Tree construction\ntree = defaultdict(list)\nfor _ in range(n - 1):\n    u, v, c = next(input_iter).split()\n    u, v = int(u), int(v)\n    tree[u].append((v, c))\n    tree[v].append((u, c))\n\n# Strings\nstrings = [next(input_iter).strip() for _ in range(m)]\n\n# Process queries\nresults = []\nfor _ in range(q):\n    u, v, l, r = map(int, next(input_iter).split())\n    path_str = ""\n    \n    # Traverse the tree to form the path string from u to v\n    def dfs(node, target, path):\n        if node == target:\n            return path + [node]\n        for neighbor, char in tree[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                result = dfs(neighbor, target, path + [node])\n                if result:\n                    return result\n        return None\n    \n    visited = set([u])\n    path = dfs(u, v, [])\n    \n    # Form the path string from the path list\n    for node in path[1:]:\n        for neighbor, char in tree[node]:\n            if neighbor == path[path.index(node) - 1]:\n                path_str += char\n                break\n    \n    # Count occurrences of path_str in the range [l, r]\n    count = 0\n    for i in range(l - 1, r):\n        count += strings[i].count(path_str)\n    \n    results.append(count)\n\n# Print results\nfor result in results:\n    print(result)', 'import sys\nfrom collections import defaultdict\n\n# Read input\ninput_lines = sys.stdin.readlines()\nn, m, q = map(int, input_lines[0].split())\n\n# Initialize tree structure\ntree = defaultdict(list)\nfor i in range(1, n):\n    u, v, c = input_lines[i].split()\n    u, v = int(u), int(v)\n    tree[u].append((v, c))\n    tree[v].append((u, c))\n\n# Read strings\nstrings = [input_lines[n+i].strip() for i in range(m)]\n\n# Process queries\ndef find_path(u, v):\n    visited = set()\n    stack = [(u, [])]\n    while stack:\n        node, path = stack.pop()\n        if node == v:\n            return \'\'.join(path)\n        if node not in visited:\n            visited.add(node)\n            for neighbor, edge in tree[node]:\n                if neighbor not in visited:\n                    stack.append((neighbor, path + [edge]))\n    return ""\n\ndef count_occurrences(s, substr):\n    count = 0\n    start = 0\n    while True:\n        start = s.find(substr, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            break\n    return count\n\nfor i in range(n+m, n+m+q):\n    u, v, l, r = map(int, input_lines[i].split())\n    path_str = find_path(u, v)\n    total_count = 0\n    for j in range(l-1, r):\n        total_count += count_occurrences(strings[j], path_str)\n    print(total_count)', "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput_lines = sys.stdin.readlines()\ninput_iter = iter(input_lines)\nn, m, q = map(int, next(input_iter).split())\n\n# Tree construction\ntree = defaultdict(list)\nfor _ in range(n - 1):\n    u, v, c = next(input_iter).split()\n    u, v = int(u), int(v)\n    tree[u].append((v, c))\n    tree[v].append((u, c))\n\n# Strings preprocessing\nstrings = [next(input_iter).strip() for _ in range(m)]\n\n# Query processing\ndef count_occurrences(s, substr):\n    count = 0\n    start = 0\n    while True:\n        start = s.find(substr, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            break\n    return count\n\ndef dfs(node, parent, path):\n    if node != parent:\n        path.append((node, parent, ''))\n    for child, edge in tree[node]:\n        if child != parent:\n            dfs(child, node, path)\n            if node != parent:\n                path[-1] = (node, parent, edge)\n\ndef process_query(u, v, l, r):\n    path = []\n    dfs(u, -1, path)\n    path_str = ''\n    for node, _, edge in path:\n        if node == v:\n            path_str += edge\n            break\n        path_str += edge\n    total_count = 0\n    for i in range(l - 1, r):\n        total_count += count_occurrences(strings[i], path_str)\n    return total_count\n\n# Process queries\nfor _ in range(q):\n    u, v, l, r = map(int, next(input_iter).split())\n    result = process_query(u, v, l, r)\n    print(result)", 'import sys\nfrom collections import defaultdict\n\n# Read input\ninput_lines = sys.stdin.readlines()\ninput_iter = iter(input_lines)\nn, m, q = map(int, next(input_iter).split())\n\n# Tree construction\ntree = defaultdict(list)\nfor _ in range(n - 1):\n    u, v, c = next(input_iter).split()\n    u, v = int(u), int(v)\n    tree[u].append((v, c))\n    tree[v].append((u, c))\n\n# Strings\nstrings = [next(input_iter).strip() for _ in range(m)]\n\n# Process queries\nresults = []\nfor _ in range(q):\n    u, v, l, r = map(int, next(input_iter).split())\n    path_str = ""\n    \n    # Traverse the tree to form the path string from u to v\n    def dfs(node, target, path):\n        if node == target:\n            return path + [node]\n        for neighbor, char in tree[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                result = dfs(neighbor, target, path + [node])\n                if result:\n                    return result\n        return None\n    \n    visited = set([u])\n    path = dfs(u, v, [])\n    \n    # Form the path string from the path list\n    for node in path[1:]:\n        for neighbor, char in tree[node]:\n            if neighbor == path[path.index(node) - 1]:\n                path_str += char\n                break\n    \n    # Count occurrences of path_str in the range [l, r]\n    count = 0\n    for i in range(l - 1, r):\n        count += strings[i].count(path_str)\n    \n    results.append(count)\n\n# Print results\nfor result in results:\n    print(result)', 'import sys\nfrom collections import defaultdict\n\n# Read input\ninput_lines = sys.stdin.readlines()\nn, m, q = map(int, input_lines[0].split())\n\n# Initialize tree structure\ntree = defaultdict(list)\nfor i in range(1, n):\n    u, v, c = input_lines[i].split()\n    u, v = int(u), int(v)\n    tree[u].append((v, c))\n    tree[v].append((u, c))\n\n# Read strings\nstrings = [input_lines[n+i].strip() for i in range(m)]\n\n# Process queries\ndef find_path(u, v):\n    visited = set()\n    stack = [(u, [])]\n    while stack:\n        node, path = stack.pop()\n        if node == v:\n            return \'\'.join(path)\n        if node not in visited:\n            visited.add(node)\n            for neighbor, edge in tree[node]:\n                if neighbor not in visited:\n                    stack.append((neighbor, path + [edge]))\n    return ""\n\ndef count_occurrences(s, substr):\n    count = 0\n    start = 0\n    while True:\n        start = s.find(substr, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            break\n    return count\n\nfor i in range(n+m, n+m+q):\n    u, v, l, r = map(int, input_lines[i].split())\n    path_str = find_path(u, v)\n    total_count = 0\n    for j in range(l-1, r):\n        total_count += count_occurrences(strings[j], path_str)\n    print(total_count)', 'import sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(node, parent, tree, letters):\n    stack = [(node, parent)]\n    while stack:\n        node, parent = stack.pop()\n        for child, letter in tree[node]:\n            if child != parent:\n                letters[child] = letters[node] + letter\n                stack.append((child, node))\n\ndef f1(n, m, q, edges, strings):\n    tree = defaultdict(list)\n    for u, v, c in edges:\n        tree[u].append((v, c))\n        tree[v].append((u, c))\n    \n    letters = [""] * (n + 1)\n    dfs(1, -1, tree, letters)\n    \n    results = []\n    for _ in range(q):\n        u, v, l, r = map(int, sys.stdin.readline().split())\n        path_str = letters[u] + letters[v].replace(letters[u], \'\', 1)\n        count = sum(s[l-1:r].count(path_str) for s in strings)\n        results.append(count)\n    \n    return results\n\nif __name__ == "__main__":\n    n, m, q = map(int, sys.stdin.readline().split())\n    edges = [tuple(sys.stdin.readline().split()) for _ in range(n-1)]\n    edges = [(int(u), int(v), c) for u, v, c in edges]\n    strings = [sys.stdin.readline().strip() for _ in range(m)]\n    \n    results = f1(n, m, q, edges, strings)\n    for result in results:\n        print(result)', "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput_lines = sys.stdin.readlines()\ninput_iter = iter(input_lines)\nn, m, q = map(int, next(input_iter).split())\n\n# Tree construction\ntree = defaultdict(list)\nfor _ in range(n - 1):\n    u, v, c = next(input_iter).split()\n    u, v = int(u), int(v)\n    tree[u].append((v, c))\n    tree[v].append((u, c))\n\n# Strings preprocessing\nstrings = [next(input_iter).strip() for _ in range(m)]\n\n# Query processing\ndef count_occurrences(s, substr):\n    count = 0\n    start = 0\n    while True:\n        start = s.find(substr, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            break\n    return count\n\ndef dfs(node, parent, path):\n    if node != parent:\n        path.append((node, parent, ''))\n    for child, edge in tree[node]:\n        if child != parent:\n            dfs(child, node, path)\n            if node != parent:\n                path[-1] = (node, parent, edge)\n\ndef process_query(u, v, l, r):\n    path = []\n    dfs(u, -1, path)\n    path_str = ''\n    for node, _, edge in path:\n        if node == v:\n            path_str += edge\n            break\n        path_str += edge\n    total_count = 0\n    for i in range(l - 1, r):\n        total_count += count_occurrences(strings[i], path_str)\n    return total_count\n\n# Process queries\nfor _ in range(q):\n    u, v, l, r = map(int, next(input_iter).split())\n    result = process_query(u, v, l, r)\n    print(result)"]
----------
['- name: \nOptimized Tree Traversal with Trie and Range Queries\n\n- content: \nAnother approach is to:\n1. Build the tree from the given edges and store the characters on each edge.\n2. Construct a trie (prefix tree) for all strings to efficiently search for substrings.\n3. For each query, find the shortest path string between nodes u and v using the tree\'s edges.\n4. Use range queries on the trie to count occurrences of this path string within the specified range of strings.\n5. Output the count for each query.\n\nAlgorithm Details:\n- **Tree Construction**: Same as above.\n- **Trie Construction**: Insert all strings into a trie with nodes representing prefixes of these strings.\n- **Path String Extraction**: Traverse the tree from node u to node v to extract the path string.\n- **Substring Search**: Use the trie to count occurrences of the path string within the range [l, r] using efficient range queries in the trie structure.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'tree traversal\': navigating through nodes and edges of a tree structure.\n    \'trie\': a tree-like data structure used for efficient retrieval of a set of strings with common prefixes.\n    \'path string\': a sequence of characters obtained by traversing edges from one node to another in a tree.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The plan suggests a multi-step approach:\n    1. Build the tree from the given edges.\n    2. Construct a trie for all strings.\n    3. For each query, extract the path string between nodes u and v.\n    4. Use the trie to count occurrences of the path string within the specified range of strings.\n\n# [edge case]\n    query (2, 1, 1, 5)\n    expected output: 8\n    Explanation: The path string from node 2 to node 1 is "a", and it appears 8 times in the strings from index 1 to 5.\n\n    query (1, 2, 1, 3)\n    expected output: 7\n    Explanation: The path string from node 1 to node 2 is "a", and it appears 7 times in the strings from index 1 to 3.\n\n    query (2, 1, 3, 5)\n    expected output: 4\n    Explanation: The path string from node 2 to node 1 is "a", and it appears 4 times in the strings from index 3 to 5.\n\n# [extra code for edge case]\n    No extra code is needed for the edge case handling as the plan already includes the necessary steps to handle the query efficiently.', "- name: \nEfficient Tree Traversal with Trie for Path Strings\n\n- content: \n- **Solution Approach**:\n  1. **Tree Construction**: Construct the tree from the given edges.\n  2. **Path String Construction**: Use DFS to traverse the tree and construct a Trie (prefix tree) for storing path strings efficiently.\n  3. **Range Query Processing**: For each query, use the Trie to efficiently count occurrences of the path string within the specified range of strings [l, r].\n  4. **Edge Cases**: Handle cases where the path does not exist or the range is invalid.\n- **Algorithm**: Use DFS to construct the Trie for path strings. For each query, traverse the Trie to count occurrences of the path string within the specified range of strings.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree traversal': navigating through nodes in a tree structure\n    'Trie': a data structure used to store a dynamic set of strings, which allows prefix searches efficiently\n    'path string': a sequence of characters representing the traversal from one node to another in a tree\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the count of a substring should be greater than a specified value\n    'at least as many times': means the frequency of a substring should be at least as much as its value\n\n# [degree adverb] \n    'largest': refers to finding the maximum value that meets a certain condition\n\n# [code logic]\n    The steps should be implemented sequentially as they are dependent on each other.\n    - Construct the tree from the given edges.\n    - Use DFS to traverse the tree and construct a Trie for path strings.\n    - For each query, use the Trie to count occurrences of the path string within the specified range of strings [l, r].\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4], 3) = 3\n    Explanation: The number 3 appears 3 times, which is more than or equal to its value, and it is the largest number that meets this condition.\n\n    search([1, 2, 2, 3, 3, 3, 4, 4, 4], 4) = -1\n    Explanation: The number 4 appears 3 times, which is more than or equal to its value, but there is no larger number that meets this condition. Therefore, the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases where no such integer exists by returning -1.", '- name: \nSegment Trees for Range Queries\n\n- content: \n- **Approach**:\n  1. Construct the tree using the given edges.\n  2. Use a trie data structure to efficiently store and search for substrings.\n  3. For each query, find the shortest path between nodes u and v using DFS or BFS.\n  4. Concatenate the letters on the edges of the path to form str(u,v).\n  5. Use segment trees to efficiently count occurrences of str(u,v) in the specified range of strings.\n- **Algorithm**:\n  1. Construct the tree using DFS or BFS.\n  2. For each query, use DFS or BFS to find the shortest path between nodes u and v.\n  3. Concatenate the letters on the edges of the path to form str(u,v).\n  4. Use a trie data structure to store all strings and efficiently count occurrences of str(u,v).\n  5. Use segment trees to efficiently count occurrences of str(u,v) in the range of strings [l, r].\n- **Edge Cases**:\n  - Handle single-node trees.\n  - Handle multiple paths between two nodes.\n  - Handle empty strings and single-character strings.\n  - Handle cases where the range of strings is from start to end.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'tree structure\': a hierarchical data structure consisting of nodes connected by edges, where each node can have zero or more child nodes and exactly one parent node (except for the root node).\n    Explanation: In this problem, the tree structure represents the relationships between nodes in a graph, where each edge is labeled with a specific letter. The goal is to find the shortest path between two nodes and then count the occurrences of a specific substring formed by the letters on the edges of that path within a given range of strings.\n\n# [phrase showing quantity relationship]\n    \'more than\': means that the count of a substring should be greater than a specific value.\n    Explanation: In the requirement, we need to find the total number of occurrences of str(u,v) within the specified range of strings. This implies that we need to count the occurrences of the substring formed by the letters on the edges of the shortest path between nodes u and v.\n\n# [degree adverb] \n    \'largest\': means that we need to find the largest integer that meets a certain condition.\n    Explanation: In the requirement, we need to find the largest integer that appears at least as many times as itself in the list. This implies that we need to find the integer with the highest frequency that satisfies the given condition.\n\n# [code logic]\n    The steps 2-4 should be implement simultaneously.\n    "Create a dictionary to store the frequency of each integer in the list",\n    "Iterate through the list and update the frequency in the dictionary",\n    "Iterate through the dictionary to find the largest integer that meets the condition"\n    This could be done by using a for loop to iterate through the list and update the frequency in the dictionary, and then use another loop to find the largest integer that meets the condition.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3]) = 3\n    Explanation: The number 3 appears three times, which is more than its value (3), and it is the largest number that meets this condition.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: The number 3 appears three times, which is more than its value (3), and it is the largest number that meets this condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    \'shortest path\': the path between two nodes in a graph that has the smallest number of edges.\n    Explanation: In this problem, the shortest path refers to the path between two nodes in the tree structure, where the path is defined by the edges and nodes encountered during the traversal.\n\n# [phrase showing quantity relationship]\n    \'at least as many times\': means that the frequency of a substring should be greater than or equal to its value.\n    Explanation: In the requirement, we need to find the largest integer that appears at least as many times as itself in the list. This implies that we need to find the integer with the highest frequency that satisfies the given condition.\n\n# [degree adverb] \n    \'largest\': means that we need to find the largest integer that meets a certain condition.\n    Explanation: In the requirement, we need to find the largest integer that appears at least as many times as itself in the list. This implies that we need to find the integer with the highest frequency that satisfies the given condition.\n\n# [code logic]\n    The steps 2-4 should be implement simultaneously.\n    "Create a dictionary to store the frequency of each integer in the list",\n    "Iterate through the list and update the frequency in the dictionary",\n    "Iterate through the dictionary to find the largest integer that meets the condition"\n    This could be done by using a for loop to iterate through the list and update the frequency in the dictionary, and then use another loop to find the largest integer that meets the condition.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3]) = 3\n    Explanation: The number 3 appears three times, which is more than its value (3), and it is the largest number that meets this condition.\n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: The number 3 appears three times, which is more than its value (3), and it is the largest number that meets this condition.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.', '- name: \nTree Traversal and String Matching\n\n- content: \n- **Solution Approach:**\n  1. **Tree Construction:** Build the tree from the given edges and their labels.\n  2. **Path String Formation:** For each query, find the shortest path between nodes `u` and `v` using Depth-First Search (DFS) or Breadth-First Search (BFS).\n  3. **String Matching:** For each path string formed, check all strings in the specified range `[l, r]` for occurrences.\n  4. **Count Occurrences:** Count how many times the path string appears in the range of strings.\n- **Algorithm:**\n  - Use DFS to traverse the tree and find the shortest path between two nodes.\n  - For each path string, iterate through the range of strings to count occurrences.\n- **Edge Cases:**\n  - Handle cases where the tree is a straight line or a star shape.\n  - Ensure that invalid queries (e.g., non-existent paths) are handled gracefully.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'Tree Traversal\': The process of visiting each node in a tree exactly once, typically using Depth-First Search (DFS) or Breadth-First Search (BFS).\n    \'String Matching\': The process of finding occurrences of a substring within a larger string.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps should be implemented sequentially as follows:\n    1. Build the tree from the given edges and labels.\n    2. For each query, find the shortest path between nodes `u` and `v` using DFS or BFS.\n    3. Form the path string from the nodes and edges.\n    4. For the formed path string, check all strings in the specified range `[l, r]` for occurrences.\n    5. Count the total number of occurrences and return the count.\n\n# [edge case] \n    Edge Case 1:\n    Query: 2 1 1 5\n    Explanation: The shortest path from node 2 to node 1 is "a", which appears 3 times in the range [1, 5].\n    Expected Output: 3\n\n    Edge Case 2:\n    Query: 1 2 1 3\n    Explanation: The shortest path from node 1 to node 2 is "a", which appears 2 times in the range [1, 3].\n    Expected Output: 2\n\n    Edge Case 3:\n    Query: 2 1 3 5\n    Explanation: The shortest path from node 2 to node 1 is "a", which appears 2 times in the range [3, 5].\n    Expected Output: 2\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the core logic can handle the specified range of strings. The path string formation and string matching are straightforward within the given constraints.', '- name: \nBrute Force String Matching\n\n- content: \n- **Solution Approach**:\n  1. Construct the tree from the given edges.\n  2. For each query, find the shortest path between nodes u and v.\n  3. Concatenate the edge labels along this path to form the target substring.\n  4. Use a brute force approach to count occurrences of the target substring in each string from l to r.\n- **Algorithm**:\n  - Use Depth-First Search (DFS) to traverse the tree and construct the path.\n  - For each string in the range from l to r, use a brute force algorithm to count occurrences of the target substring.\n- **Edge Cases**:\n  - Handle cases where the tree is a straight line or a star-shaped graph.\n  - Handle cases where strings are very short or very long.\n  - Handle cases where queries specify invalid paths or are out of range.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'tree traversal\': understanding the structure of a tree and navigating through it using algorithms like DFS.\n    \'string matching\': searching for occurrences of a substring within a larger string.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the count of a substring must be greater than a specific value.\n    \'at least as many times\': means the substring must appear a number of times equal to or greater than its value.\n\n# [degree adverb] \n    \'largest\': refers to finding the largest integer that meets a certain condition.\n\n# [code logic]\n    The steps should be implemented sequentially as each step builds upon the previous one.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The number 3 appears 3 times, which is more than its value (3), and it is the largest number that meets this condition.\n    search([1, 1, 1, 2, 2, 3]) = -1\n    Explanation: No number appears more than or equal to its value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases where no such integer exists by returning -1.\n\n# [core concept]\n    \'shortest path\': the path with the least number of edges between two nodes in a tree.\n    \'substring concatenation\': forming a new string by joining the characters along a path in a tree.\n\n# [phrase showing quantity relationship]\n    \'total count\': refers to summing up the occurrences of a substring across multiple strings.\n\n# [degree adverb] \n    \'shortest\': indicates the need to find the path with the least number of edges between two nodes.\n\n# [code logic]\n    Steps 2 and 3 should be implemented simultaneously to form the target substring by concatenating the edge labels along the shortest path.\n\n# [edge case] \n    search([1, 2, 3, 4], ["a", "aa", "aaa", "aaaa"], 1, 3) = 3\n    Explanation: The shortest path from node 1 to node 3 involves concatenating "a" and "a", which appears 3 times in the strings from index 1 to 3.\n    search([1, 2, 3, 4], ["a", "aa", "aaa", "aaaa"], 2, 4) = 2\n    Explanation: The shortest path from node 2 to node 4 involves "aa" and "a", which appear 2 times in the strings from index 2 to 4.\n\n# [extra code for edge case]\n    We need extra code to handle cases where the query specifies invalid paths or out-of-range indices.\n    Example code:\n    ```python\n    if u == v or l > r or l < 1 or r > m:\n        return 0  # Invalid query, return 0 occurrences\n    ```', "- name: \nTree Traversal and String Matching\n\n- content: \n- **Solution Name:** Tree Traversal and String Matching\n- **Solution Approach:**\n  1. **Tree Construction:** Build the tree from the given edges.\n  2. **String Preprocessing:** Preprocess the strings to efficiently count occurrences using a suffix array or a trie (prefix tree).\n  3. **Path String Extraction:** For each query, traverse the tree from node u to node v to extract the path string.\n  4. **Count Occurrences:** Use the preprocessed data structures to count the occurrences of the path string within the specified range of strings.\n- **Algorithm:**\n  - Use Depth-First Search (DFS) to traverse the tree and construct the path string for each query.\n  - Use a trie data structure to store all strings and efficiently count occurrences of substrings.\n  - For each query, traverse the path from u to v, extract the path string, and count its occurrences in the given range of strings using the trie.\n- **Edge Cases:**\n  - Handle cases where the path does not exist or is invalid.\n  - Ensure efficient handling of large inputs within given constraints.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree traversal': navigating through nodes in a tree structure\n    'string matching': finding occurrences of a substring within a string or set of strings\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value\n    'at least as many times': means that we need to find integers whose occurrences are at least as many as their value\n\n# [degree adverb] \n    'largest': means that we need the largest integer that meets the condition\n\n# [code logic]\n    There are no steps that can be implemented simultaneously. All steps must be done sequentially.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    explanation: Number 2 appears once, number 3 appears twice, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'tree traversal': navigating through nodes in a tree structure\n    'string matching': finding occurrences of a substring within a string or set of strings\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value\n    'at least as many times': means that we need to find integers whose occurrences are at least as many as their value\n\n# [degree adverb] \n    'largest': means that we need the largest integer that meets the condition\n\n# [code logic]\n    There are no steps that can be implemented simultaneously. All steps must be done sequentially.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    explanation: Number 2 appears once, number 3 appears twice, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.", '- name: \nTree Traversal and String Matching\n\n- content: \n- **Solution Approach:**\n  1. **Tree Construction:** Build the tree from the given edges and their labels.\n  2. **Path String Formation:** For each query, find the shortest path between nodes `u` and `v` using Depth-First Search (DFS) or Breadth-First Search (BFS).\n  3. **String Matching:** For each path string formed, check all strings in the specified range `[l, r]` for occurrences.\n  4. **Count Occurrences:** Count how many times the path string appears in the range of strings.\n- **Algorithm:**\n  - Use DFS to traverse the tree and find the shortest path between two nodes.\n  - For each path string, iterate through the range of strings to count occurrences.\n- **Edge Cases:**\n  - Handle cases where the tree is a straight line or a star shape.\n  - Ensure that invalid queries (e.g., non-existent paths) are handled gracefully.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'Tree Traversal\': The process of visiting each node in a tree exactly once, typically using Depth-First Search (DFS) or Breadth-First Search (BFS).\n    \'String Matching\': The process of finding occurrences of a substring within a larger string.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps should be implemented sequentially as follows:\n    1. Build the tree from the given edges and labels.\n    2. For each query, find the shortest path between nodes `u` and `v` using DFS or BFS.\n    3. Form the path string from the nodes and edges.\n    4. For the formed path string, check all strings in the specified range `[l, r]` for occurrences.\n    5. Count the total number of occurrences and return the count.\n\n# [edge case] \n    Edge Case 1:\n    Query: 2 1 1 5\n    Explanation: The shortest path from node 2 to node 1 is "a", which appears 3 times in the range [1, 5].\n    Expected Output: 3\n\n    Edge Case 2:\n    Query: 1 2 1 3\n    Explanation: The shortest path from node 1 to node 2 is "a", which appears 2 times in the range [1, 3].\n    Expected Output: 2\n\n    Edge Case 3:\n    Query: 2 1 3 5\n    Explanation: The shortest path from node 2 to node 1 is "a", which appears 2 times in the range [3, 5].\n    Expected Output: 2\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the core logic can handle the specified range of strings. The path string formation and string matching are straightforward within the given constraints.', '- name: \nBrute Force String Matching\n\n- content: \n- **Solution Approach**:\n  1. Construct the tree from the given edges.\n  2. For each query, find the shortest path between nodes u and v.\n  3. Concatenate the edge labels along this path to form the target substring.\n  4. Use a brute force approach to count occurrences of the target substring in each string from l to r.\n- **Algorithm**:\n  - Use Depth-First Search (DFS) to traverse the tree and construct the path.\n  - For each string in the range from l to r, use a brute force algorithm to count occurrences of the target substring.\n- **Edge Cases**:\n  - Handle cases where the tree is a straight line or a star-shaped graph.\n  - Handle cases where strings are very short or very long.\n  - Handle cases where queries specify invalid paths or are out of range.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'tree traversal\': understanding the structure of a tree and navigating through it using algorithms like DFS.\n    \'string matching\': searching for occurrences of a substring within a larger string.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the count of a substring must be greater than a specific value.\n    \'at least as many times\': means the substring must appear a number of times equal to or greater than its value.\n\n# [degree adverb] \n    \'largest\': refers to finding the largest integer that meets a certain condition.\n\n# [code logic]\n    The steps should be implemented sequentially as each step builds upon the previous one.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    Explanation: The number 3 appears 3 times, which is more than its value (3), and it is the largest number that meets this condition.\n    search([1, 1, 1, 2, 2, 3]) = -1\n    Explanation: No number appears more than or equal to its value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases where no such integer exists by returning -1.\n\n# [core concept]\n    \'shortest path\': the path with the least number of edges between two nodes in a tree.\n    \'substring concatenation\': forming a new string by joining the characters along a path in a tree.\n\n# [phrase showing quantity relationship]\n    \'total count\': refers to summing up the occurrences of a substring across multiple strings.\n\n# [degree adverb] \n    \'shortest\': indicates the need to find the path with the least number of edges between two nodes.\n\n# [code logic]\n    Steps 2 and 3 should be implemented simultaneously to form the target substring by concatenating the edge labels along the shortest path.\n\n# [edge case] \n    search([1, 2, 3, 4], ["a", "aa", "aaa", "aaaa"], 1, 3) = 3\n    Explanation: The shortest path from node 1 to node 3 involves concatenating "a" and "a", which appears 3 times in the strings from index 1 to 3.\n    search([1, 2, 3, 4], ["a", "aa", "aaa", "aaaa"], 2, 4) = 2\n    Explanation: The shortest path from node 2 to node 4 involves "aa" and "a", which appear 2 times in the strings from index 2 to 4.\n\n# [extra code for edge case]\n    We need extra code to handle cases where the query specifies invalid paths or out-of-range indices.\n    Example code:\n    ```python\n    if u == v or l > r or l < 1 or r > m:\n        return 0  # Invalid query, return 0 occurrences\n    ```', "- name: \nEfficient Tree Traversal with Trie for Path Strings\n\n- content: \n- **Solution Approach**:\n  1. **Tree Construction**: Construct the tree from the given edges.\n  2. **Path String Construction**: Use DFS to traverse the tree and construct a Trie (prefix tree) for storing path strings efficiently.\n  3. **Range Query Processing**: For each query, use the Trie to efficiently count occurrences of the path string within the specified range of strings [l, r].\n  4. **Edge Cases**: Handle cases where the path does not exist or the range is invalid.\n- **Algorithm**: Use DFS to construct the Trie for path strings. For each query, traverse the Trie to count occurrences of the path string within the specified range of strings.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree traversal': navigating through nodes in a tree structure\n    'Trie': a data structure used to store a dynamic set of strings, which allows prefix searches efficiently\n    'path string': a sequence of characters representing the traversal from one node to another in a tree\n\n# [phrase showing quantity relationship]\n    'more than': indicates that the count of a substring should be greater than a specified value\n    'at least as many times': means the frequency of a substring should be at least as much as its value\n\n# [degree adverb] \n    'largest': refers to finding the maximum value that meets a certain condition\n\n# [code logic]\n    The steps should be implemented sequentially as they are dependent on each other.\n    - Construct the tree from the given edges.\n    - Use DFS to traverse the tree and construct a Trie for path strings.\n    - For each query, use the Trie to count occurrences of the path string within the specified range of strings [l, r].\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4], 3) = 3\n    Explanation: The number 3 appears 3 times, which is more than or equal to its value, and it is the largest number that meets this condition.\n\n    search([1, 2, 2, 3, 3, 3, 4, 4, 4], 4) = -1\n    Explanation: The number 4 appears 3 times, which is more than or equal to its value, but there is no larger number that meets this condition. Therefore, the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The original logic can handle cases where no such integer exists by returning -1.", "- name: \nTree Traversal and String Matching\n\n- content: \n- **Solution Name:** Tree Traversal and String Matching\n- **Solution Approach:**\n  1. **Tree Construction:** Build the tree from the given edges.\n  2. **String Preprocessing:** Preprocess the strings to efficiently count occurrences using a suffix array or a trie (prefix tree).\n  3. **Path String Extraction:** For each query, traverse the tree from node u to node v to extract the path string.\n  4. **Count Occurrences:** Use the preprocessed data structures to count the occurrences of the path string within the specified range of strings.\n- **Algorithm:**\n  - Use Depth-First Search (DFS) to traverse the tree and construct the path string for each query.\n  - Use a trie data structure to store all strings and efficiently count occurrences of substrings.\n  - For each query, traverse the path from u to v, extract the path string, and count its occurrences in the given range of strings using the trie.\n- **Edge Cases:**\n  - Handle cases where the path does not exist or is invalid.\n  - Ensure efficient handling of large inputs within given constraints.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'tree traversal': navigating through nodes in a tree structure\n    'string matching': finding occurrences of a substring within a string or set of strings\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value\n    'at least as many times': means that we need to find integers whose occurrences are at least as many as their value\n\n# [degree adverb] \n    'largest': means that we need the largest integer that meets the condition\n\n# [code logic]\n    There are no steps that can be implemented simultaneously. All steps must be done sequentially.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    explanation: Number 2 appears once, number 3 appears twice, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'tree traversal': navigating through nodes in a tree structure\n    'string matching': finding occurrences of a substring within a string or set of strings\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value\n    'at least as many times': means that we need to find integers whose occurrences are at least as many as their value\n\n# [degree adverb] \n    'largest': means that we need the largest integer that meets the condition\n\n# [code logic]\n    There are no steps that can be implemented simultaneously. All steps must be done sequentially.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    explanation: Number 2 appears once, number 3 appears twice, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition."]
----------
True
----------
2
multi-gen-prompt:
 There are n block towers arranged in a row, each with a specific height denoted as a_i. As a member of the construction crew, your goal is to enhance the appearance of these towers. You have the ability to move a block from one tower to another on any given day. Specifically, you can choose two indices i and j (with 1 ≤ i, j ≤ n and i ≠ j), and transfer a block from tower i to tower j. This action reduces the height of tower i by 1 and increases the height of tower j by 1.

The objective is to determine the

Input

The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases. Then t cases follow.

The first line of each test case contains one integer n (2 ≤ n ≤ 100) — the number of buildings.

The second line of each test case contains n space separated integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^7) — the heights of the buildings.

Output

For each test case, output a single integer — the minimum possible ugliness of the buildings.

Example

Input


3
3
10 10 10
4
3 2 1 2
5
1 2 3 1 5


Output


0
0
1

Note

In the first test case, the ugliness is already 0.

In the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.

In the third test case, you may do three operations: 

  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], 
  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], 
  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. 

The resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.
multi-gen-prompt:
 There are n block towers in a row, where tower i has a height of a_i. You're part of a building crew, and you want to make the buildings look as nice as possible. In a single day, you can move a block from tower i to tower j (1 ≤ i, j ≤ n; i ≠ j), which decreases a_i by 1 and increases a_j by 1. The ugliness of the buildings is defined as the height difference between the tallest and shortest buildings, max(a)-min(a). What's the minimum possible ugliness you

Input

The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases. Then t cases follow.

The first line of each test case contains one integer n (2 ≤ n ≤ 100) — the number of buildings.

The second line of each test case contains n space separated integers a_1, a_2, …, a_n (1 ≤ a_i ≤ 10^7) — the heights of the buildings.

Output

For each test case, output a single integer — the minimum possible ugliness of the buildings.

Example

Input


3
3
10 10 10
4
3 2 1 2
5
1 2 3 1 5


Output


0
0
1

Note

In the first test case, the ugliness is already 0.

In the second test case, you should do one operation, with i = 1 and j = 3. The new heights will now be [2, 2, 2, 2], with an ugliness of 0.

In the third test case, you may do three operations: 

  1. with i = 3 and j = 1. The new array will now be [2, 2, 2, 1, 5], 
  2. with i = 5 and j = 4. The new array will now be [2, 2, 2, 2, 4], 
  3. with i = 5 and j = 3. The new array will now be [2, 2, 3, 2, 3]. 

The resulting ugliness is 1. It can be proven that this is the minimum possible ugliness for this test.
generating with deepseek-coder
----------
['import heapq\n\ndef min_ugliness(n, heights):\n    return max(heights) - min(heights)\n\ndef reduce_ugliness(n, heights):\n    max_heap = [-height for height in heights]  # Use a max-heap by storing negative values\n    min_heap = list(heights)  # Use a min-heap for the original heights\n    heapq.heapify(max_heap)\n    heapq.heapify(min_heap)\n\n    while True:\n        max_height = -heapq.heappop(max_heap)\n        min_height = heapq.heappop(min_heap)\n        if max_height == min_height:\n            break\n        max_height -= 1\n        min_height += 1\n        heapq.heappush(max_heap, -max_height)\n        heapq.heappush(min_heap, min_height)\n\n    return min_ugliness(n, [-x for x in max_heap])  # Convert back to positive values\n\ndef solve():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        results.append(reduce_ugliness(n, heights))\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    solve()', 'def min_ugliness(heights):\n    min_height = min(heights)\n    max_height = max(heights)\n    if max_height == min_height:\n        return 0\n    ugliness = max_height - min_height\n    # Additional code to handle the transfer process and minimize ugliness\n    while max_height != min_height:\n        max_index = heights.index(max_height)\n        min_index = heights.index(min_height)\n        heights[max_index] -= 1\n        heights[min_index] += 1\n        new_max_height = max(heights)\n        new_min_height = min(heights)\n        new_ugliness = new_max_height - new_min_height\n        if new_ugliness < ugliness:\n            ugliness = new_ugliness\n            max_height = new_max_height\n            min_height = new_min_height\n        else:\n            break\n    return ugliness\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        print(min_ugliness(heights))\n\nif __name__ == "__main__":\n    main()', 'def calculate_ugliness(heights):\n    max_height = max(heights)\n    min_ugliness = float(\'inf\')\n    \n    for target_height in range(1, max_height + 1):\n        current_ugliness = 0\n        for height in heights:\n            if height > target_height:\n                current_ugliness += height - target_height\n        min_ugliness = min(min_ugliness, current_ugliness)\n    \n    return min_ugliness\n\ndef main():\n    t = int(input())\n    results = []\n    \n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        results.append(calculate_ugliness(heights))\n    \n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def min_ugliness(n, heights):\n    total_height = sum(heights)\n    target_height = total_height // n\n    moves = 0\n    \n    for height in heights:\n        moves += abs(height - target_height)\n    \n    return moves // 2  # Each move affects two towers, so we divide by 2\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        print(min_ugliness(n, heights))\n\nif __name__ == "__main__":\n    solve()', 'import heapq\n\ndef min_ugliness(n, heights):\n    return max(heights) - min(heights)\n\ndef reduce_ugliness(n, heights):\n    max_heap = [-height for height in heights]  # Use a max-heap by storing negative values\n    min_heap = list(heights)  # Use a min-heap for the original heights\n    heapq.heapify(max_heap)\n    heapq.heapify(min_heap)\n\n    while True:\n        max_height = -heapq.heappop(max_heap)\n        min_height = heapq.heappop(min_heap)\n        if max_height == min_height:\n            break\n        max_height -= 1\n        min_height += 1\n        heapq.heappush(max_heap, -max_height)\n        heapq.heappush(min_heap, min_height)\n\n    return min_ugliness(n, [-x for x in max_heap])  # Convert back to positive values\n\ndef solve():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        results.append(reduce_ugliness(n, heights))\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    solve()', 'def min_ugliness(n, heights):\n    total_height = sum(heights)\n    target_height = total_height // n\n    moves = 0\n    \n    for height in heights:\n        moves += abs(height - target_height)\n    \n    return moves // 2  # Each move affects two towers, so we divide by 2\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        print(min_ugliness(n, heights))\n\nif __name__ == "__main__":\n    solve()', 'def calculate_ugliness(heights):\n    max_height = max(heights)\n    min_ugliness = float(\'inf\')\n    \n    for target_height in range(1, max_height + 1):\n        current_ugliness = 0\n        for height in heights:\n            if height > target_height:\n                current_ugliness += height - target_height\n        min_ugliness = min(min_ugliness, current_ugliness)\n    \n    return min_ugliness\n\ndef main():\n    t = int(input())\n    results = []\n    \n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        results.append(calculate_ugliness(heights))\n    \n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def calculate_ugliness(heights):\n    max_height = max(heights)\n    min_ugliness = float(\'inf\')\n    \n    for target_height in range(1, max_height + 1):\n        current_ugliness = 0\n        for height in heights:\n            if height > target_height:\n                current_ugliness += height - target_height\n        min_ugliness = min(min_ugliness, current_ugliness)\n    \n    return min_ugliness\n\ndef main():\n    t = int(input())\n    results = []\n    \n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        results.append(calculate_ugliness(heights))\n    \n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'import heapq\n\ndef min_ugliness(n, heights):\n    return max(heights) - min(heights)\n\ndef reduce_ugliness(n, heights):\n    max_heap = [-height for height in heights]  # Use a max-heap by storing negative values\n    min_heap = list(heights)  # Use a min-heap for the original heights\n    heapq.heapify(max_heap)\n    heapq.heapify(min_heap)\n\n    while True:\n        max_height = -heapq.heappop(max_heap)\n        min_height = heapq.heappop(min_heap)\n        if max_height == min_height:\n            break\n        max_height -= 1\n        min_height += 1\n        heapq.heappush(max_heap, -max_height)\n        heapq.heappush(min_heap, min_height)\n\n    return min_ugliness(n, [-x for x in max_heap])  # Convert back to positive values\n\ndef solve():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        results.append(reduce_ugliness(n, heights))\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    solve()', 'import heapq\n\ndef min_ugliness(n, heights):\n    return max(heights) - min(heights)\n\ndef reduce_ugliness(n, heights):\n    max_heap = [-height for height in heights]  # Use a max-heap by storing negative values\n    min_heap = list(heights)  # Use a min-heap for the original heights\n    heapq.heapify(max_heap)\n    heapq.heapify(min_heap)\n\n    while True:\n        max_height = -heapq.heappop(max_heap)\n        min_height = heapq.heappop(min_heap)\n        if max_height == min_height:\n            break\n        max_height -= 1\n        min_height += 1\n        heapq.heappush(max_heap, -max_height)\n        heapq.heappush(min_heap, min_height)\n\n    return min_ugliness(n, [-x for x in max_heap])  # Convert back to positive values\n\ndef solve():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        heights = list(map(int, input().split()))\n        results.append(reduce_ugliness(n, heights))\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    solve()']
----------
["- name: \nGreedy Approach to Minimize Ugliness\n\n- content: \nAnother solution approach is to use a greedy algorithm to minimize the ugliness. Here's the plan:\n1. For each test case, find the maximum and minimum heights of the towers.\n2. Calculate the current ugliness as the difference between the maximum and minimum heights.\n3. The goal is to reduce this ugliness by moving blocks from the tallest towers to the shortest ones.\n4. Iterate through the towers, and for each pair of towers, move blocks from the taller tower to the shorter one if it reduces the ugliness.\n5. Repeat this process until no more moves can reduce the ugliness further.\n6. Output the minimum possible ugliness after all possible moves.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower manipulation': involves moving blocks between towers to equalize their heights, thereby minimizing the height difference.\n    Explanation: The goal is to make all tower heights as equal as possible to achieve the minimum possible ugliness.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find a relationship where one value is greater than another.\n    'at least as many times': means that a value must appear a certain number of times or more.\n\n# [degree adverb] \n    'largest': refers to the tallest tower in the list.\n    'shortest': refers to the shortest tower in the list.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Find the maximum and minimum heights of the towers.\n    - Calculate the current ugliness.\n    - Move blocks from the tallest towers to the shortest ones to reduce ugliness.\n    - Repeat until no more moves can reduce the ugliness further.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 1\n    Explanation: The ugliness is 4 (5-1). By moving blocks from the tallest (5) to the shortest (1), we can achieve a height of [2, 2, 3, 4, 4], reducing the ugliness to 1.\n    search([5, 5, 5, 5, 5]) = 0\n    Explanation: All towers are already of the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find the minimum possible ugliness is straightforward and does not require additional code for this specific edge case.", "- name: \nGreedy Algorithm for Balancing Heights\n\n- content: \nHere's a more detailed plan using a greedy algorithm:\n1. For each test case, iterate through the list of tower heights.\n2. At each step, identify the tower with the maximum height and the tower with the minimum height.\n3. Transfer a block from the maximum height tower to the minimum height tower until the maximum and minimum heights are equal or the ugliness is minimized.\n4. Calculate the ugliness by computing the difference between the maximum and minimum heights after each transfer.\n5. Output the final ugliness value after all possible transfers.\n\nThis method ensures that we minimize the ugliness by always transferring blocks to balance the towers, thus reducing the maximum height difference.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower balancing': \n    The process of adjusting the heights of towers by moving blocks from one tower to another to achieve a more uniform distribution of heights.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The plan suggests a greedy approach to minimize the ugliness by transferring blocks between towers. This can be implemented by:\n    1. Iterating through the list of tower heights.\n    2. Identifying the tower with the maximum height and the tower with the minimum height.\n    3. Transferring a block from the maximum height tower to the minimum height tower until the maximum and minimum heights are equal.\n    4. Calculating the ugliness after each transfer and updating the minimum possible ugliness.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4, 5]\n    Explanation: The ugliness is initially 4 (5 - 1). By transferring blocks, the best we can achieve is to make all towers height 3, resulting in an ugliness of 2.\n    Edge case 2:\n    Input: [5, 5, 5, 5]\n    Explanation: The ugliness is already 0, as all towers are of equal height.\n    Edge case 3:\n    Input: [10, 1, 10, 1, 10]\n    Explanation: The ugliness is 9 (10 - 1). The best we can achieve is to make all towers height 6, resulting in an ugliness of 4.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the initial list is already balanced or nearly balanced. This can be done by checking if the maximum and minimum heights are already equal or nearly equal before starting the transfer process.\n\n# Example implementation for edge case handling:\n```python\ndef min_ugliness(heights):\n    min_height = min(heights)\n    max_height = max(heights)\n    if max_height == min_height:\n        return 0\n    ugliness = max_height - min_height\n    # Additional code to handle the transfer process and minimize ugliness\n    return ugliness\n```", "- name: \nGreedy Approach\n\n- content: \nTo minimize the ugliness, we can use a greedy strategy. First, find the average height of all towers. Then, for each tower, calculate the difference between its height and the average height. The sum of these differences will give us the minimum possible ugliness. This approach ensures that we achieve the minimum ugliness by balancing the heights of the towers.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'ugliness': the difference between the maximum and minimum height of the towers\n\n    'move a block': transfer a block from one tower to another to balance their heights\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a greedy approach to minimize the ugliness. The steps involve:\n    1. Calculating the average height of all towers.\n    2. For each tower, calculating the difference between its height and the average height.\n    3. Summing these differences to get the minimum possible ugliness.\n\n# [edge case] \n    Test case 1:\n    Input: [10, 10, 10]\n    Explanation: The heights are already balanced, so the ugliness is 0.\n    Expected output: 0\n\n    Test case 2:\n    Input: [3, 2, 1, 2]\n    Explanation: The average height is 2. The differences are [1, 0, -1, 0]. The sum of these differences is 0, so the ugliness is 0.\n    Expected output: 0\n\n    Test case 3:\n    Input: [1, 2, 3, 1, 5]\n    Explanation: The average height is 2. The differences are [-1, 0, 1, -1, 3]. The sum of these differences is 1, so the ugliness is 1.\n    Expected output: 1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the greedy approach directly calculates the minimum possible ugliness.", "- name: \nGreedy Block Movement\n\n- content: \nThe solution approach involves a greedy strategy where we move blocks to balance the heights of the towers as much as possible. Here's the detailed plan:\n\n1. For each test case, find the maximum and minimum heights.\n2. Calculate the current ugliness as the difference between the maximum and minimum heights.\n3. Move blocks from the tower with the maximum height to the tower with the minimum height until they are as balanced as possible.\n4. Calculate and output the new ugliness after balancing.\n\nThis solution ensures functional correctness by considering all possible valid inputs and edge cases to achieve the minimum possible ugliness.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block movement': moving blocks from one tower to another to balance their heights.\n    'ugliness': the difference between the tallest and shortest buildings.\n\n# [phrase showing quantity relationship]\n    'as many as': means the number of blocks moved should be equal to the difference in heights between the tallest and shortest towers.\n\n# [degree adverb] \n    'minimum possible': means we need to find the least possible ugliness after moving blocks.\n\n# [code logic]\n    For each test case:\n    1. Find the maximum and minimum heights of the buildings.\n    2. Calculate the current ugliness.\n    3. Move blocks from the tower with the maximum height to the tower with the minimum height until the ugliness is minimized.\n    4. Output the minimized ugliness.\n\n# [edge case] \n    test case: [1, 2, 3, 1, 5]\n    expected output: 1\n    Explanation:\n    - Initial ugliness: max(heights) - min(heights) = 5 - 1 = 4\n    - Move 3 blocks from tower with height 5 to tower with height 3: [1, 2, 4, 1, 4]\n    - Move 1 block from tower with height 4 to tower with height 1: [2, 2, 4, 1, 4]\n    - Move 1 block from tower with height 4 to tower with height 1: [2, 2, 3, 1, 3]\n    - New ugliness: max(heights) - min(heights) = 3 - 1 = 2\n    - Continue moving blocks until the ugliness is minimized, which is 1 in this case.\n\n# [extra code for edge case]\n    No extra code is needed for the main logic, but for clarity, we can add comments or break down the steps more explicitly in the code.", "- name: \nGreedy Approach to Minimize Ugliness\n\n- content: \nAnother solution approach is to use a greedy algorithm to minimize the ugliness. Here's the plan:\n1. For each test case, find the maximum and minimum heights of the towers.\n2. Calculate the current ugliness as the difference between the maximum and minimum heights.\n3. The goal is to reduce this ugliness by moving blocks from the tallest towers to the shortest ones.\n4. Iterate through the towers, and for each pair of towers, move blocks from the taller tower to the shorter one if it reduces the ugliness.\n5. Repeat this process until no more moves can reduce the ugliness further.\n6. Output the minimum possible ugliness after all possible moves.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower manipulation': involves moving blocks between towers to equalize their heights, thereby minimizing the height difference.\n    Explanation: The goal is to make all tower heights as equal as possible to achieve the minimum possible ugliness.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find a relationship where one value is greater than another.\n    'at least as many times': means that a value must appear a certain number of times or more.\n\n# [degree adverb] \n    'largest': refers to the tallest tower in the list.\n    'shortest': refers to the shortest tower in the list.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Find the maximum and minimum heights of the towers.\n    - Calculate the current ugliness.\n    - Move blocks from the tallest towers to the shortest ones to reduce ugliness.\n    - Repeat until no more moves can reduce the ugliness further.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 1\n    Explanation: The ugliness is 4 (5-1). By moving blocks from the tallest (5) to the shortest (1), we can achieve a height of [2, 2, 3, 4, 4], reducing the ugliness to 1.\n    search([5, 5, 5, 5, 5]) = 0\n    Explanation: All towers are already of the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find the minimum possible ugliness is straightforward and does not require additional code for this specific edge case.", "- name: \nGreedy Block Movement\n\n- content: \nThe solution approach involves a greedy strategy where we move blocks to balance the heights of the towers as much as possible. Here's the detailed plan:\n\n1. For each test case, find the maximum and minimum heights.\n2. Calculate the current ugliness as the difference between the maximum and minimum heights.\n3. Move blocks from the tower with the maximum height to the tower with the minimum height until they are as balanced as possible.\n4. Calculate and output the new ugliness after balancing.\n\nThis solution ensures functional correctness by considering all possible valid inputs and edge cases to achieve the minimum possible ugliness.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block movement': moving blocks from one tower to another to balance their heights.\n    'ugliness': the difference between the tallest and shortest buildings.\n\n# [phrase showing quantity relationship]\n    'as many as': means the number of blocks moved should be equal to the difference in heights between the tallest and shortest towers.\n\n# [degree adverb] \n    'minimum possible': means we need to find the least possible ugliness after moving blocks.\n\n# [code logic]\n    For each test case:\n    1. Find the maximum and minimum heights of the buildings.\n    2. Calculate the current ugliness.\n    3. Move blocks from the tower with the maximum height to the tower with the minimum height until the ugliness is minimized.\n    4. Output the minimized ugliness.\n\n# [edge case] \n    test case: [1, 2, 3, 1, 5]\n    expected output: 1\n    Explanation:\n    - Initial ugliness: max(heights) - min(heights) = 5 - 1 = 4\n    - Move 3 blocks from tower with height 5 to tower with height 3: [1, 2, 4, 1, 4]\n    - Move 1 block from tower with height 4 to tower with height 1: [2, 2, 4, 1, 4]\n    - Move 1 block from tower with height 4 to tower with height 1: [2, 2, 3, 1, 3]\n    - New ugliness: max(heights) - min(heights) = 3 - 1 = 2\n    - Continue moving blocks until the ugliness is minimized, which is 1 in this case.\n\n# [extra code for edge case]\n    No extra code is needed for the main logic, but for clarity, we can add comments or break down the steps more explicitly in the code.", "- name: \nGreedy Approach\n\n- content: \nTo minimize the ugliness, we can use a greedy strategy. First, find the average height of all towers. Then, for each tower, calculate the difference between its height and the average height. The sum of these differences will give us the minimum possible ugliness. This approach ensures that we achieve the minimum ugliness by balancing the heights of the towers.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'ugliness': the difference between the maximum and minimum height of the towers\n\n    'move a block': transfer a block from one tower to another to balance their heights\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a greedy approach to minimize the ugliness. The steps involve:\n    1. Calculating the average height of all towers.\n    2. For each tower, calculating the difference between its height and the average height.\n    3. Summing these differences to get the minimum possible ugliness.\n\n# [edge case] \n    Test case 1:\n    Input: [10, 10, 10]\n    Explanation: The heights are already balanced, so the ugliness is 0.\n    Expected output: 0\n\n    Test case 2:\n    Input: [3, 2, 1, 2]\n    Explanation: The average height is 2. The differences are [1, 0, -1, 0]. The sum of these differences is 0, so the ugliness is 0.\n    Expected output: 0\n\n    Test case 3:\n    Input: [1, 2, 3, 1, 5]\n    Explanation: The average height is 2. The differences are [-1, 0, 1, -1, 3]. The sum of these differences is 1, so the ugliness is 1.\n    Expected output: 1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the greedy approach directly calculates the minimum possible ugliness.", "- name: \nGreedy Approach\n\n- content: \nTo minimize the ugliness, we can use a greedy strategy. First, find the average height of all towers. Then, for each tower, calculate the difference between its height and the average height. The sum of these differences will give us the minimum possible ugliness. This approach ensures that we achieve the minimum ugliness by balancing the heights of the towers.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'ugliness': the difference between the maximum and minimum height of the towers\n\n    'move a block': transfer a block from one tower to another to balance their heights\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a greedy approach to minimize the ugliness. The steps involve:\n    1. Calculating the average height of all towers.\n    2. For each tower, calculating the difference between its height and the average height.\n    3. Summing these differences to get the minimum possible ugliness.\n\n# [edge case] \n    Test case 1:\n    Input: [10, 10, 10]\n    Explanation: The heights are already balanced, so the ugliness is 0.\n    Expected output: 0\n\n    Test case 2:\n    Input: [3, 2, 1, 2]\n    Explanation: The average height is 2. The differences are [1, 0, -1, 0]. The sum of these differences is 0, so the ugliness is 0.\n    Expected output: 0\n\n    Test case 3:\n    Input: [1, 2, 3, 1, 5]\n    Explanation: The average height is 2. The differences are [-1, 0, 1, -1, 3]. The sum of these differences is 1, so the ugliness is 1.\n    Expected output: 1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the greedy approach directly calculates the minimum possible ugliness.", "- name: \nGreedy Approach to Minimize Ugliness\n\n- content: \nAnother solution approach is to use a greedy algorithm to minimize the ugliness. Here's the plan:\n1. For each test case, find the maximum and minimum heights of the towers.\n2. Calculate the current ugliness as the difference between the maximum and minimum heights.\n3. The goal is to reduce this ugliness by moving blocks from the tallest towers to the shortest ones.\n4. Iterate through the towers, and for each pair of towers, move blocks from the taller tower to the shorter one if it reduces the ugliness.\n5. Repeat this process until no more moves can reduce the ugliness further.\n6. Output the minimum possible ugliness after all possible moves.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower manipulation': involves moving blocks between towers to equalize their heights, thereby minimizing the height difference.\n    Explanation: The goal is to make all tower heights as equal as possible to achieve the minimum possible ugliness.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find a relationship where one value is greater than another.\n    'at least as many times': means that a value must appear a certain number of times or more.\n\n# [degree adverb] \n    'largest': refers to the tallest tower in the list.\n    'shortest': refers to the shortest tower in the list.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Find the maximum and minimum heights of the towers.\n    - Calculate the current ugliness.\n    - Move blocks from the tallest towers to the shortest ones to reduce ugliness.\n    - Repeat until no more moves can reduce the ugliness further.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 1\n    Explanation: The ugliness is 4 (5-1). By moving blocks from the tallest (5) to the shortest (1), we can achieve a height of [2, 2, 3, 4, 4], reducing the ugliness to 1.\n    search([5, 5, 5, 5, 5]) = 0\n    Explanation: All towers are already of the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find the minimum possible ugliness is straightforward and does not require additional code for this specific edge case.", "- name: \nGreedy Approach to Minimize Ugliness\n\n- content: \nAnother solution approach is to use a greedy algorithm to minimize the ugliness. Here's the plan:\n1. For each test case, find the maximum and minimum heights of the towers.\n2. Calculate the current ugliness as the difference between the maximum and minimum heights.\n3. The goal is to reduce this ugliness by moving blocks from the tallest towers to the shortest ones.\n4. Iterate through the towers, and for each pair of towers, move blocks from the taller tower to the shorter one if it reduces the ugliness.\n5. Repeat this process until no more moves can reduce the ugliness further.\n6. Output the minimum possible ugliness after all possible moves.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'block tower manipulation': involves moving blocks between towers to equalize their heights, thereby minimizing the height difference.\n    Explanation: The goal is to make all tower heights as equal as possible to achieve the minimum possible ugliness.\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find a relationship where one value is greater than another.\n    'at least as many times': means that a value must appear a certain number of times or more.\n\n# [degree adverb] \n    'largest': refers to the tallest tower in the list.\n    'shortest': refers to the shortest tower in the list.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Find the maximum and minimum heights of the towers.\n    - Calculate the current ugliness.\n    - Move blocks from the tallest towers to the shortest ones to reduce ugliness.\n    - Repeat until no more moves can reduce the ugliness further.\n\n# [edge case] \n    search([1, 2, 3, 4, 5]) = 1\n    Explanation: The ugliness is 4 (5-1). By moving blocks from the tallest (5) to the shortest (1), we can achieve a height of [2, 2, 3, 4, 4], reducing the ugliness to 1.\n    search([5, 5, 5, 5, 5]) = 0\n    Explanation: All towers are already of the same height, so the ugliness is 0.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to find the minimum possible ugliness is straightforward and does not require additional code for this specific edge case."]
----------
False
----------
0
multi-gen-prompt:
 You are given an array a of n integers, and another integer k such that 2k ≤ n. You need to perform exactly k operations with this array. In each operation, you must choose two elements from the array (let's call them a_i and a_j), remove them from the array, and add ⌊ (a_i)/(a_j) ⌋ to your score, where ⌊ x/y ⌋ represents the maximum integer not exceeding x/y. Initially, your score is 0. After performing exactly k operations, you add all the remaining elements of

Input

The first line of the input contains one integer t (1 ≤ t ≤ 500) — the number of test cases.

Each test case consists of two lines. The first line contains two integers n and k (1 ≤ n ≤ 100; 0 ≤ k ≤ ⌊ n/2 ⌋).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 2 ⋅ 10^5).

Output

Print one integer — the minimum possible score you can get.

Example

Input


5
7 3
1 1 1 2 1 3 1
5 1
5 5 5 5 5
4 2
1 3 3 7
2 0
4 2
9 2
1 10 10 1 10 2 7 10 3


Output


2
16
0
6
16

Note

Let's consider the example test.

In the first test case, one way to obtain a score of 2 is the following one:

  1. choose a_7 = 1 and a_4 = 2 for the operation; the score becomes 0 + ⌊ 1/2 ⌋ = 0, the array becomes [1, 1, 1, 1, 3]; 
  2. choose a_1 = 1 and a_5 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [1, 1, 1]; 
  3. choose a_1 = 1 and a_2 = 1 for the operation; the score becomes 0 + ⌊ 1/1 ⌋ = 1, the array becomes [1]; 
  4. add the remaining element 1 to the score, so the resulting score is 2. 



In the second test case, no matter which operations you choose, the resulting score is 16.

In the third test case, one way to obtain a score of 0 is the following one:

  1. choose a_1 = 1 and a_2 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [3, 7]; 
  2. choose a_1 = 3 and a_2 = 7 for the operation; the score becomes 0 + ⌊ 3/7 ⌋ = 0, the array becomes empty; 
  3. the array is empty, so the score doesn't change anymore. 



In the fourth test case, no operations can be performed, so the score is the sum of the elements of the array: 4 + 2 = 6.
multi-gen-prompt:
 You are given an array a of n integers, and another integer k such that 2k ≤ n. You have to perform exactly k operations with this array. In one operation, you have to choose two elements of the array (let them be a_i and a_j; they can be equal or different, but their positions in the array must not be the same), remove them from the array, and add ⌊ (a_i)/(a_j) ⌋ to your score, where ⌊ x/y ⌋ is the maximum integer not exceeding x/y. Initially, your

Input

The first line of the input contains one integer t (1 ≤ t ≤ 500) — the number of test cases.

Each test case consists of two lines. The first line contains two integers n and k (1 ≤ n ≤ 100; 0 ≤ k ≤ ⌊ n/2 ⌋).

The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 2 ⋅ 10^5).

Output

Print one integer — the minimum possible score you can get.

Example

Input


5
7 3
1 1 1 2 1 3 1
5 1
5 5 5 5 5
4 2
1 3 3 7
2 0
4 2
9 2
1 10 10 1 10 2 7 10 3


Output


2
16
0
6
16

Note

Let's consider the example test.

In the first test case, one way to obtain a score of 2 is the following one:

  1. choose a_7 = 1 and a_4 = 2 for the operation; the score becomes 0 + ⌊ 1/2 ⌋ = 0, the array becomes [1, 1, 1, 1, 3]; 
  2. choose a_1 = 1 and a_5 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [1, 1, 1]; 
  3. choose a_1 = 1 and a_2 = 1 for the operation; the score becomes 0 + ⌊ 1/1 ⌋ = 1, the array becomes [1]; 
  4. add the remaining element 1 to the score, so the resulting score is 2. 



In the second test case, no matter which operations you choose, the resulting score is 16.

In the third test case, one way to obtain a score of 0 is the following one:

  1. choose a_1 = 1 and a_2 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [3, 7]; 
  2. choose a_1 = 3 and a_2 = 7 for the operation; the score becomes 0 + ⌊ 3/7 ⌋ = 0, the array becomes empty; 
  3. the array is empty, so the score doesn't change anymore. 



In the fourth test case, no operations can be performed, so the score is the sum of the elements of the array: 4 + 2 = 6.
generating with deepseek-coder
----------
['def f1(n, k, a):\n    a.sort(reverse=True)\n    score = 0\n    i = 0\n    j = n - 1\n    while i < k and i < n - 1 - i:\n        score += a[i+1] // a[i]\n        i += 2\n    score += sum(a[i:])\n    return score\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        results.append(f1(n, k, a))\n    for result in results:\n        print(result)', 'import heapq\n\ndef min_score(n, k, arr):\n    # Create a max-heap from the array\n    max_heap = [-x for x in arr]\n    heapq.heapify(max_heap)\n    \n    score = 0\n    for _ in range(k):\n        if len(max_heap) < 2:\n            break\n        # Pop the two largest elements\n        a = -heapq.heappop(max_heap)\n        b = -heapq.heappop(max_heap)\n        # Perform the division and add the result to the score\n        score += b // a\n        # If there is a remainder, push it back to the heap\n        if b % a != 0:\n            heapq.heappush(max_heap, -(b % a))\n    \n    # Add the remaining elements to the score\n    score += sum(-x for x in max_heap)\n    return score\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        results.append(min_score(n, k, arr))\n    for result in results:\n        print(result)', 'import heapq\n\ndef min_score(n, k, arr):\n    # Create a max-heap using negative values for elements in arr\n    arr = [-x for x in arr]\n    heapq.heapify(arr)\n    \n    for _ in range(k):\n        # Pop the two largest elements\n        a_i = -heapq.heappop(arr)\n        a_j = -heapq.heappop(arr)\n        \n        # Calculate the quotient and add it to the score\n        score = a_i // a_j\n        if a_i % a_j != 0:\n            # Push the remainder back into the heap if any\n            heapq.heappush(arr, -(a_i % a_j))\n    \n    # Sum up the remaining elements in the heap\n    return -sum(arr)\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        results.append(min_score(n, k, arr))\n    for result in results:\n        print(result)', 'def min_score(n, k, arr):\n    arr.sort()\n    score = 0\n    for i in range(n - 2 * k):\n        score += arr[i]\n    for i in range(n - 2 * k, n - k):\n        score += arr[i] // arr[n - k]\n    return score\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        results.append(min_score(n, k, arr))\n    for result in results:\n        print(result)', 'def calculate_score(n, k, arr):\n    if k == 0:\n        return sum(arr)\n    \n    # Ensure we have at least 2k elements\n    if 2 * k > n:\n        return 0\n    \n    score = 0\n    for i in range(k):\n        max_index = arr.index(max(arr))\n        arr.pop(max_index)\n        max_index = arr.index(max(arr))\n        score += arr[max_index] // arr.pop(max_index)\n    \n    return score + sum(arr)\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        results.append(calculate_score(n, k, arr))\n    for result in results:\n        print(result)', 'def min_score(n, k, arr):\n    score = 0\n    left = 0\n    right = n - 1\n    \n    for _ in range(k):\n        if left < right:\n            score += arr[left] // arr[right]\n            left += 1\n            right -= 1\n        else:\n            break\n    \n    # If there are remaining elements, we can pair them with 1 to minimize the score impact\n    while left <= right:\n        score += arr[left] // arr[right]\n        left += 1\n        right -= 1\n    \n    return score\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    \n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        results.append(min_score(n, k, arr))\n    \n    for result in results:\n        print(result)', 'def min_score(n, k, arr):\n    score = 0\n    left = 0\n    right = n - 1\n    \n    for _ in range(k):\n        if left < right:\n            score += arr[left] // arr[right]\n            left += 1\n            right -= 1\n        else:\n            break\n    \n    # If there are remaining elements, we can pair them with 1 to minimize the score impact\n    while left <= right:\n        score += arr[left] // arr[right]\n        left += 1\n        right -= 1\n    \n    return score\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    \n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        results.append(min_score(n, k, arr))\n    \n    for result in results:\n        print(result)', 'def f1(n, k, a):\n    a.sort(reverse=True)\n    score = 0\n    i = 0\n    j = n - 1\n    while i < k and i < n - 1 - i:\n        score += a[i+1] // a[i]\n        i += 2\n    score += sum(a[i:])\n    return score\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        results.append(f1(n, k, a))\n    for result in results:\n        print(result)', 'def f1(n, k, a):\n    a.sort(reverse=True)\n    score = 0\n    i = 0\n    j = n - 1\n    while i < k and i < n - 1 - i:\n        score += a[i+1] // a[i]\n        i += 2\n    score += sum(a[i:])\n    return score\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        results.append(f1(n, k, a))\n    for result in results:\n        print(result)', 'def min_score(n, k, arr):\n    arr.sort()\n    score = 0\n    for i in range(n - 2 * k):\n        score += arr[i]\n    for i in range(n - 2 * k, n - k):\n        score += arr[i] // arr[n - k]\n    return score\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        results.append(min_score(n, k, arr))\n    for result in results:\n        print(result)']
----------
['- name: \nGreedy Approach with Sorting\n\n- content: \n- Perform the operations by always choosing the largest and smallest elements to minimize the score.\n- Sort the array to easily access the smallest and largest elements.\n- Use a greedy approach to perform the k operations, each time selecting the smallest and largest elements to minimize the score.\n- After performing k operations, add the remaining elements to the score.\n- Ensure that the operations are performed optimally to minimize the score.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'Greedy Algorithm\': This is a strategy to solve optimization problems by making the best choice at each step, with the hope of finding a global optimum.\n    Explanation: In this problem, we need to minimize the score by performing operations on the array. By always choosing the largest and smallest elements for each operation, we can hope to achieve the minimum possible score.\n\n# [phrase showing quantity relationship]\n    \'two times\': This indicates that the number of operations (k) is half the size of the array (n), meaning 2k ≤ n.\n    Explanation: The phrase "two times" refers to the relationship between k and n, where k is at most half of n. This means we can perform at most k operations, each involving two elements chosen from the array.\n\n# [degree adverb] \n    \'minimum possible\': This indicates that we need to find the smallest score achievable through a series of operations.\n    Explanation: The degree adverb "minimum possible" emphasizes the goal of finding the lowest score that can be obtained by strategically performing the operations.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Sort the array to easily access the smallest and largest elements.\n    - Perform k operations, each time choosing the smallest and largest elements to minimize the score.\n    - After performing k operations, add the remaining elements to the score.\n\n# [edge case] \n    search([1], 0) = 1\n    Explanation: If k is 0, no operations are performed, and the score is simply the sum of all elements in the array. In this case, the array has only one element, so the score is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for k=0 is already included in the main algorithm.\n\n# [core concept]\n    \'Optimization\': This involves finding the best solution among all possible solutions, often by making a series of locally optimal choices.\n    Explanation: In this problem, we are optimizing the score by performing operations on the array. By choosing the smallest and largest elements in each operation, we aim to minimize the score.\n\n# [phrase showing quantity relationship]\n    \'exactly k operations\': This indicates that we need to perform exactly k operations as per the given constraint.\n    Explanation: The phrase "exactly k operations" means we need to perform k operations on the array, where k is a specified number. This constraint limits the number of operations we can perform.\n\n# [degree adverb] \n    \'global optimum\': This indicates that we need to find the best possible outcome considering all possible operations.\n    Explanation: The degree adverb "global optimum" refers to the overall best score that can be achieved by performing the operations optimally.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Sort the array to easily access the smallest and largest elements.\n    - Perform exactly k operations, each time choosing the smallest and largest elements to minimize the score.\n    - After performing k operations, add the remaining elements to the score.\n\n# [edge case] \n    search([1, 2, 3], 2) = 3\n    Explanation: If k is 2, we perform two operations. One possible sequence of operations is to choose 1 and 2 first, then 1 and 3, resulting in a score of 0 + 1 + 0 = 1. After two operations, the remaining element is 3, so the final score is 1 + 3 = 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for k=2 is already included in the main algorithm.\n\n# [core concept]\n    \'Divide and Conquer\': This is a strategy to solve problems by breaking them down into smaller subproblems and solving them recursively.\n    Explanation: In this problem, we can break down the array into smaller parts by performing operations, and then combine the results to find the global optimum.\n\n# [phrase showing quantity relationship]\n    \'at least as many times\': This indicates that the frequency of an integer in the array should be at least as much as the integer itself.\n    Explanation: The phrase "at least as many times" means that for an integer to be considered, its frequency in the array should be greater than or equal to its value.\n\n# [degree adverb] \n    \'largest\': This indicates that we need to find the largest integer that meets the given condition.\n    Explanation: The degree adverb "largest" emphasizes the goal of finding the biggest integer that appears at least as many times as itself in the array.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Create a dictionary to store the frequency of each integer in the array.\n    - Iterate through the array to update the frequency in the dictionary.\n    - Iterate through the dictionary to find the largest integer that meets the condition.\n    - Return the result or -1 if no such integer exists.\n\n# [edge case] \n    search([1, 2, 3]) = 3\n    Explanation: If no integer appears at least as many times as itself, the function should return -1. In this case, the array does not meet this condition, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for no such integer exists is already included in the main algorithm.', "- name: \nBrute Force with Permutations\n\n- content: \n- Generate all possible pairs of elements for the operations.\n- Calculate the score for each permutation and keep track of the minimum score.\n- After generating all permutations, return the minimum score found.\n- Consider edge cases where the array might be too small to perform k operations.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'integer division': means the result of division where the quotient is the largest integer not exceeding the true quotient.\n    Explanation: This concept is important for calculating the score by using floor division (⌊ x/y ⌋) to get the integer part of the division.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than zero.\n    'at least as many times': means that the frequency of an integer in the array should be greater than or equal to the integer itself.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    The steps should be implement simultaneously. We need to generate all possible pairs of elements for the operations, calculate the score for each permutation, and keep track of the minimum score.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], 0) = 15\n    Explanation: Since no operations can be performed (k=0), the score is the sum of all elements in the array.\n    search([10, 20, 30], 3) = 0\n    Explanation: Even though k=3, there are not enough pairs to perform 3 operations. The minimum possible score is 0 because we can choose pairs that result in a score of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k=0.\n        if k == 0:\n            return sum(a)\n\n## Prompt 3:\n\n[requirement]\nYou are given an array a of n integers, and another integer k such that 2k ≤ n.\n\nYou have to perform exactly k operations with this array. In one operation, you have to choose two elements of the array (let them be a_i and a_j; they can be equal or different, but their positions in the array must not be the same), remove them from the array, and add ⌊ (a_i)/(a_j) ⌋ to your score, where ⌊ x/y ⌋ is the maximum integer not exceeding x/y.\n\nInitially, your score is 0. After you perform exactly k operations, you add all the remaining elements of the array to the score.\n\nCalculate the minimum possible score you can get.\n\nInput\n\nThe first line of the input contains one integer t (1 ≤ t ≤ 500) — the number of test cases.\n\nEach test case consists of two lines. The first line contains two integers n and k (1 ≤ n ≤ 100; 0 ≤ k ≤ ⌊ n/2 ⌋).\n\nThe second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 2 ⋅ 10^5).\n\nOutput\n\nPrint one integer — the minimum possible score you can get.\n\nExample\n\nInput\n\n\n5\n7 3\n1 1 1 2 1 3 1\n5 1\n5 5 5 5 5\n4 2\n1 3 3 7\n2 0\n4 2\n9 2\n1 10 10 1 10 2 7 10 3\n\n\nOutput\n\n\n2\n16\n0\n6\n16\n\nNote\n\nLet's consider the example test.\n\nIn the first test case, one way to obtain a score of 2 is the following one:\n\n  1. choose a_7 = 1 and a_4 = 2 for the operation; the score becomes 0 + ⌊ 1/2 ⌋ = 0, the array becomes [1, 1, 1, 1, 3]; \n  2. choose a_1 = 1 and a_5 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [1, 1, 1]; \n  3. choose a_1 = 1 and a_2 = 1 for the operation; the score becomes 0 + ⌊ 1/1 ⌋ = 1, the array becomes [1]; \n  4. add the remaining element 1 to the score, so the resulting score is 2. \n\n\n\nIn the second test case, no matter which operations you choose, the resulting score is 16.\n\nIn the third test case, one way to obtain a score of 0 is the following one:\n\n  1. choose a_1 = 1 and a_2 = 3 for the operation; the score becomes 0 + ⌊ 1/3 ⌋ = 0, the array becomes [3, 7]; \n  2. choose a_1 = 3 and a_2 = 7 for the operation; the score becomes 0 + ⌊ 3/7 ⌋ = 0, the array becomes empty; \n  3. the array is empty, so the score doesn't change anymore. \n\n\n\nIn the fourth test case, no operations can be performed, so the score is the sum of the elements of the array: 4 + 2 = 6.\n[plan]\n- name: \nBrute Force with Permutations\n\n- content: \n- Generate all possible pairs of elements for the operations.\n- Calculate the score for each permutation and keep track of the minimum score.\n- After generating all permutations, return the minimum score found.\n- Consider edge cases where the array might be too small to perform k operations.\n\n\n## Answer 3:\n\n# [core concept]\n    'integer division': means the result of division where the quotient is the largest integer not exceeding the true quotient.\n    Explanation: This concept is important for calculating the score by using floor division (⌊ x/y ⌋) to get the integer part of the division.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than zero.\n    'at least as many times': means that the frequency of an integer in the array should be greater than or equal to the integer itself.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition of appearing at least as many times as itself.\n\n# [code logic]\n    The steps should be implement simultaneously. We need to generate all possible pairs of elements for the operations, calculate the score for each permutation, and keep track of the minimum score.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], 0) = 15\n    Explanation: Since no operations can be performed (k=0), the score is the sum of all elements in the array.\n    search([10, 20, 30], 3) = 0\n    Explanation: Even though k=3, there are not enough pairs to perform 3 operations. The minimum possible score is 0 because we can choose pairs that result in a score of 0.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k=0.\n        if k == 0:\n            return sum(a)", "- name: \nGreedy Minimization Strategy\n\n- content: \n- **Solution Approach:**\n  - Use a greedy approach to minimize the score by always choosing the smallest elements for division.\n  - Sort the array to easily access the smallest elements.\n  - Perform k operations by repeatedly choosing the smallest two elements, performing the division, and updating the score.\n  - After k operations, add any remaining elements to the score.\n- **Implementation:**\n  - Sort the array.\n  - Perform k operations by selecting the smallest elements and updating the score.\n  - Add any remaining elements to the score.\n- **Handling Edge Cases:**\n  - Ensure that the number of operations does not exceed k.\n  - Handle cases where the array has fewer elements than 2k by adding all remaining elements to the score.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'greedy algorithm': This is a strategy where we make the locally optimal choice at each step to achieve a global optimum. In this case, we aim to minimize the score by always choosing the smallest elements for division.\n\n# [phrase showing quantity relationship]\n    'two times': This implies that the number of operations we can perform is half the size of the array, rounded down.\n\n# [degree adverb] \n    'minimum possible': This indicates that we need to find the smallest score achievable through the given operations.\n\n# [code logic]\n    The steps should be implemented sequentially. First, sort the array to easily access the smallest elements. Then, perform k operations by repeatedly choosing the smallest two elements, performing the division, and updating the score. After k operations, add any remaining elements to the score.\n\n# [edge case] \n    search([1, 2, 3], 1) = 1\n    Explanation:\n    - The array is sorted to [1, 2, 3].\n    - Perform one operation: choose the smallest elements 1 and 2, the score becomes 0 + ⌊ 1/2 ⌋ = 0.\n    - The array becomes [3], and the score is 0 + 3 = 3.\n\n    search([5, 4, 3, 2, 1], 2) = 3\n    Explanation:\n    - The array is sorted to [1, 2, 3, 4, 5].\n    - Perform two operations:\n        - Choose 1 and 2, the score becomes 0 + ⌊ 1/2 ⌋ = 0.\n        - Choose 3 and 4, the score becomes 0 + ⌊ 3/4 ⌋ = 0.\n    - The array becomes [5], and the score is 0 + 5 = 5.\n\n    search([10, 20, 30], 2) = 0\n    Explanation:\n    - The array is sorted to [10, 20, 30].\n    - Perform two operations:\n        - Choose 10 and 20, the score becomes 0 + ⌊ 10/20 ⌋ = 0.\n        - Choose 30 and 10, the score becomes 0 + ⌊ 30/10 ⌋ = 3.\n    - The array becomes empty, and the score is 3.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already sorts the array and performs operations accordingly, ensuring that we handle cases where the array size is less than 2k by adding all remaining elements to the score.", "- name: \nMinimize Remaining Elements\n\n- content: \n- **Solution Approach:**\n  - Focus on minimizing the sum of the remaining elements after k operations.\n  - For each operation, always choose the largest possible division to minimize the loss.\n  - This approach ensures that we maximize the score by minimizing the impact of remaining elements.\n- **Algorithm:**\n  1. Sort the array in descending order.\n  2. Perform k operations:\n     - Select the largest element and a smaller element such that their division results in a small integer.\n     - Remove these elements from the array and add their floor division to the score.\n  3. Sum any remaining elements not used in any operation.\n  4. Return the final score.\n- **Edge Cases:**\n  - Handle cases where n < 2k by either reducing k or returning an error message.\n  - Ensure handling of edge cases where all elements are the same or where k = 0.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'integer division': means the result of division is truncated to the nearest whole number towards zero.\n    Explanation: In the requirement, we need to perform operations where we divide one element by another and take the floor of the result. This is crucial for calculating the score accurately.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value.\n    'at least as many times': means that the frequency of an integer in the list should be at least as much as its value.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition.\n\n# [code logic]\n    The steps 2-4 should be implement simultaneously.\n    - Sort the array in descending order.\n    - Perform k operations by selecting the largest element and a smaller element for division.\n    - Add the floor of the division result to the score.\n    - Continue until k operations are completed or no more elements are left.\n    - Sum any remaining elements not used in any operation.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], 2) = 3\n    Explanation: The largest integer that appears at least as many times as itself is 3, as it appears twice.\n    search([1, 1, 1, 2, 2], 3) = -1\n    Explanation: No integer appears more than once, so the function returns -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k is 0.\n        if k == 0:\n            return sum(a)\n\n# [core concept]\n    'array operations': means working with elements in an array, including sorting, selecting, and performing arithmetic operations.\n    Explanation: In the requirement, we need to manipulate the array by sorting it and performing operations on its elements to find the minimum possible score.\n\n# [phrase showing quantity relationship]\n    'exactly k operations': means that we need to perform k specific operations on the array.\n\n# [degree adverb] \n    'minimum possible': means that we need to find the smallest score achievable by performing the operations.\n\n# [code logic]\n    The steps 1-4 should be implement simultaneously.\n    - Sort the array in descending order.\n    - Perform k operations by selecting the largest elements for division.\n    - Add the floor of the division result to the score.\n    - Continue until k operations are completed or no more elements are left.\n    - Sum any remaining elements not used in any operation.\n\n# [edge case] \n    search([1, 1, 1, 2, 2], 0) = 5\n    Explanation: Since k is 0, we don't perform any operations, and the score is the sum of all elements in the array.\n    search([5, 5, 4, 4, 4], 2) = 18\n    Explanation: The largest integer that appears at least as many times as itself is 4, but since we are performing 2 operations, we need to consider the minimum possible score.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k is 0.\n        if k == 0:\n            return sum(a)", "- name: \nSimulation with Max-Heap\n\n- content: \nThe simulation approach involves using a max-heap (priority queue) to always select the largest element for each operation. This ensures that the division results in the largest possible integer value, which helps in minimizing the score.\n\n1. **Initialize a max-heap** to keep track of the elements.\n2. **Perform k operations**:\n   - Extract the largest element from the heap.\n   - If the heap is not empty, extract another element (which will be the divisor).\n   - Calculate the floor of their division and add it to the score.\n   - Insert the result back into the heap if it is greater than 1.\n3. **Sum up the remaining elements** in the heap to get the final score.\n\nThis approach ensures that each operation maximizes the score, leading to a minimum possible score after k operations.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'floor division': This is the operation ⌊ x/y ⌋ which represents the maximum integer not exceeding x/y.\n    Explanation: This operation is used to calculate the integer part of the division between two numbers, discarding any remainder.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that the chosen elements for each operation must be greater than zero.\n    Explanation: In each operation, we need to ensure that both elements being divided are positive integers.\n\n# [degree adverb] \n    'largest': This adverb indicates that we should always aim to use the largest available elements for each operation to maximize the score.\n    Explanation: By always selecting the largest elements, we ensure that the division results in the largest possible integer value, which helps in minimizing the score.\n\n# [code logic]\n    The steps should be implement simultaneously.\n    - Initialize a max-heap to keep track of the elements.\n    - Perform k operations:\n        - Extract the largest element from the heap.\n        - If the heap is not empty, extract another element (which will be the divisor).\n        - Calculate the floor of their division and add it to the score.\n        - Insert the result back into the heap if it is greater than 1.\n    - Sum up the remaining elements in the heap to get the final score.\n    These steps should be implemented in one code block to ensure that the operations are performed correctly and efficiently.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'positive': means that all integer in the list is > 0\n    'at least as many times': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integer > 0\n    'at least as many times': means that we need to find the integer whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps should be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    Explanation: number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'floor division': This is the operation ⌊ x/y ⌋ which represents the maximum integer not exceeding x/y.\n    Explanation: This operation is used to calculate the integer part of the division between two numbers, discarding any remainder.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that the chosen elements for each operation must be greater than zero.\n    Explanation: In each operation, we need to ensure that both elements being divided are positive integers.\n\n# [degree adverb] \n    'largest': This adverb indicates that we should always aim to use the largest available elements for each operation to maximize the score.\n    Explanation: By always selecting the largest elements, we ensure that the division results in the largest possible integer value, which helps in minimizing the score.\n\n# [code logic]\n    The steps should be implement simultaneously.\n    - Initialize a max-heap to keep track of the elements.\n    - Perform k operations:\n        - Extract the largest element from the heap.\n        - If the heap is not empty, extract another element (which will be the divisor).\n        - Calculate the floor of their division and add it to the score.\n        - Insert the result back into the heap if it is greater than 1.\n    - Sum up the remaining elements in the heap to get the final score.\n    These steps should be implemented in one code block to ensure that the operations are performed correctly and efficiently.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)", '- name: \nBrute Force Simulation\n\n- content: \nA brute force simulation involves trying all possible combinations of operations to find the minimum possible score. This can be computationally expensive for larger arrays but works well for smaller ones.\n\n**Solution Approach:**\n1. Generate all possible pairs of elements for each operation.\n2. Calculate the score for each pair and update the minimum score accordingly.\n3. Repeat until all k operations are performed or all pairs are exhausted.\n4. Return the minimum score found.\n\n**Handling Edge Cases:**\n- If `k` is zero, return the sum of all elements.\n- Ensure all combinations are considered to find the optimal score.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'integer division\': means the result of dividing two integers and taking the floor of the result.\n    Explanation: This is a mathematical operation where the result of dividing two integers is rounded down to the nearest whole number.\n\n# [phrase showing quantity relationship]\n    \'more than\': means that the number of operations should be greater than zero.\n    \'at least as many times\': means that the number of operations should be at least the given number.\n    Explanation: In this context, "more than" and "at least as many times" specify the number of operations that need to be performed.\n\n# [degree adverb] \n    \'minimum possible\': means the smallest or lowest possible score.\n    Explanation: This indicates that the goal is to find the smallest score achievable through the operations.\n\n# [code logic]\n    The steps should be implement simultaneously.\n    Explanation: To achieve the minimum possible score, we need to consider all possible pairs of elements for each operation and calculate the score for each pair. This involves generating all possible pairs and updating the minimum score accordingly.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], 0) = 15\n    Explanation: If no operations are performed (k=0), the score is simply the sum of all elements in the array. In this case, the sum is 1+2+3+4+5=15.\n    search([10, 20, 30], 2) = 0\n    Explanation: If the array has fewer elements than twice the number of operations (n < 2k), no operations can be performed, so the score is the sum of all elements. In this case, the sum is 10+20+30=60, but since k=2, we only need to consider the first 4 elements (10+20+30+40=100), and the minimum possible score is 0 because we can choose pairs that do not change the score.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to handle the edge case is already included in the solution approach.', '- name: \nBrute Force Simulation\n\n- content: \nA brute force simulation involves trying all possible combinations of operations to find the minimum possible score. This can be computationally expensive for larger arrays but works well for smaller ones.\n\n**Solution Approach:**\n1. Generate all possible pairs of elements for each operation.\n2. Calculate the score for each pair and update the minimum score accordingly.\n3. Repeat until all k operations are performed or all pairs are exhausted.\n4. Return the minimum score found.\n\n**Handling Edge Cases:**\n- If `k` is zero, return the sum of all elements.\n- Ensure all combinations are considered to find the optimal score.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'integer division\': means the result of dividing two integers and taking the floor of the result.\n    Explanation: This is a mathematical operation where the result of dividing two integers is rounded down to the nearest whole number.\n\n# [phrase showing quantity relationship]\n    \'more than\': means that the number of operations should be greater than zero.\n    \'at least as many times\': means that the number of operations should be at least the given number.\n    Explanation: In this context, "more than" and "at least as many times" specify the number of operations that need to be performed.\n\n# [degree adverb] \n    \'minimum possible\': means the smallest or lowest possible score.\n    Explanation: This indicates that the goal is to find the smallest score achievable through the operations.\n\n# [code logic]\n    The steps should be implement simultaneously.\n    Explanation: To achieve the minimum possible score, we need to consider all possible pairs of elements for each operation and calculate the score for each pair. This involves generating all possible pairs and updating the minimum score accordingly.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], 0) = 15\n    Explanation: If no operations are performed (k=0), the score is simply the sum of all elements in the array. In this case, the sum is 1+2+3+4+5=15.\n    search([10, 20, 30], 2) = 0\n    Explanation: If the array has fewer elements than twice the number of operations (n < 2k), no operations can be performed, so the score is the sum of all elements. In this case, the sum is 10+20+30=60, but since k=2, we only need to consider the first 4 elements (10+20+30+40=100), and the minimum possible score is 0 because we can choose pairs that do not change the score.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to handle the edge case is already included in the solution approach.', '- name: \nGreedy Approach with Sorting\n\n- content: \n- Perform the operations by always choosing the largest and smallest elements to minimize the score.\n- Sort the array to easily access the smallest and largest elements.\n- Use a greedy approach to perform the k operations, each time selecting the smallest and largest elements to minimize the score.\n- After performing k operations, add the remaining elements to the score.\n- Ensure that the operations are performed optimally to minimize the score.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'Greedy Algorithm\': This is a strategy to solve optimization problems by making the best choice at each step, with the hope of finding a global optimum.\n    Explanation: In this problem, we need to minimize the score by performing operations on the array. By always choosing the largest and smallest elements for each operation, we can hope to achieve the minimum possible score.\n\n# [phrase showing quantity relationship]\n    \'two times\': This indicates that the number of operations (k) is half the size of the array (n), meaning 2k ≤ n.\n    Explanation: The phrase "two times" refers to the relationship between k and n, where k is at most half of n. This means we can perform at most k operations, each involving two elements chosen from the array.\n\n# [degree adverb] \n    \'minimum possible\': This indicates that we need to find the smallest score achievable through a series of operations.\n    Explanation: The degree adverb "minimum possible" emphasizes the goal of finding the lowest score that can be obtained by strategically performing the operations.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Sort the array to easily access the smallest and largest elements.\n    - Perform k operations, each time choosing the smallest and largest elements to minimize the score.\n    - After performing k operations, add the remaining elements to the score.\n\n# [edge case] \n    search([1], 0) = 1\n    Explanation: If k is 0, no operations are performed, and the score is simply the sum of all elements in the array. In this case, the array has only one element, so the score is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for k=0 is already included in the main algorithm.\n\n# [core concept]\n    \'Optimization\': This involves finding the best solution among all possible solutions, often by making a series of locally optimal choices.\n    Explanation: In this problem, we are optimizing the score by performing operations on the array. By choosing the smallest and largest elements in each operation, we aim to minimize the score.\n\n# [phrase showing quantity relationship]\n    \'exactly k operations\': This indicates that we need to perform exactly k operations as per the given constraint.\n    Explanation: The phrase "exactly k operations" means we need to perform k operations on the array, where k is a specified number. This constraint limits the number of operations we can perform.\n\n# [degree adverb] \n    \'global optimum\': This indicates that we need to find the best possible outcome considering all possible operations.\n    Explanation: The degree adverb "global optimum" refers to the overall best score that can be achieved by performing the operations optimally.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Sort the array to easily access the smallest and largest elements.\n    - Perform exactly k operations, each time choosing the smallest and largest elements to minimize the score.\n    - After performing k operations, add the remaining elements to the score.\n\n# [edge case] \n    search([1, 2, 3], 2) = 3\n    Explanation: If k is 2, we perform two operations. One possible sequence of operations is to choose 1 and 2 first, then 1 and 3, resulting in a score of 0 + 1 + 0 = 1. After two operations, the remaining element is 3, so the final score is 1 + 3 = 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for k=2 is already included in the main algorithm.\n\n# [core concept]\n    \'Divide and Conquer\': This is a strategy to solve problems by breaking them down into smaller subproblems and solving them recursively.\n    Explanation: In this problem, we can break down the array into smaller parts by performing operations, and then combine the results to find the global optimum.\n\n# [phrase showing quantity relationship]\n    \'at least as many times\': This indicates that the frequency of an integer in the array should be at least as much as the integer itself.\n    Explanation: The phrase "at least as many times" means that for an integer to be considered, its frequency in the array should be greater than or equal to its value.\n\n# [degree adverb] \n    \'largest\': This indicates that we need to find the largest integer that meets the given condition.\n    Explanation: The degree adverb "largest" emphasizes the goal of finding the biggest integer that appears at least as many times as itself in the array.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Create a dictionary to store the frequency of each integer in the array.\n    - Iterate through the array to update the frequency in the dictionary.\n    - Iterate through the dictionary to find the largest integer that meets the condition.\n    - Return the result or -1 if no such integer exists.\n\n# [edge case] \n    search([1, 2, 3]) = 3\n    Explanation: If no integer appears at least as many times as itself, the function should return -1. In this case, the array does not meet this condition, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for no such integer exists is already included in the main algorithm.', '- name: \nGreedy Approach with Sorting\n\n- content: \n- Perform the operations by always choosing the largest and smallest elements to minimize the score.\n- Sort the array to easily access the smallest and largest elements.\n- Use a greedy approach to perform the k operations, each time selecting the smallest and largest elements to minimize the score.\n- After performing k operations, add the remaining elements to the score.\n- Ensure that the operations are performed optimally to minimize the score.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'Greedy Algorithm\': This is a strategy to solve optimization problems by making the best choice at each step, with the hope of finding a global optimum.\n    Explanation: In this problem, we need to minimize the score by performing operations on the array. By always choosing the largest and smallest elements for each operation, we can hope to achieve the minimum possible score.\n\n# [phrase showing quantity relationship]\n    \'two times\': This indicates that the number of operations (k) is half the size of the array (n), meaning 2k ≤ n.\n    Explanation: The phrase "two times" refers to the relationship between k and n, where k is at most half of n. This means we can perform at most k operations, each involving two elements chosen from the array.\n\n# [degree adverb] \n    \'minimum possible\': This indicates that we need to find the smallest score achievable through a series of operations.\n    Explanation: The degree adverb "minimum possible" emphasizes the goal of finding the lowest score that can be obtained by strategically performing the operations.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Sort the array to easily access the smallest and largest elements.\n    - Perform k operations, each time choosing the smallest and largest elements to minimize the score.\n    - After performing k operations, add the remaining elements to the score.\n\n# [edge case] \n    search([1], 0) = 1\n    Explanation: If k is 0, no operations are performed, and the score is simply the sum of all elements in the array. In this case, the array has only one element, so the score is 1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for k=0 is already included in the main algorithm.\n\n# [core concept]\n    \'Optimization\': This involves finding the best solution among all possible solutions, often by making a series of locally optimal choices.\n    Explanation: In this problem, we are optimizing the score by performing operations on the array. By choosing the smallest and largest elements in each operation, we aim to minimize the score.\n\n# [phrase showing quantity relationship]\n    \'exactly k operations\': This indicates that we need to perform exactly k operations as per the given constraint.\n    Explanation: The phrase "exactly k operations" means we need to perform k operations on the array, where k is a specified number. This constraint limits the number of operations we can perform.\n\n# [degree adverb] \n    \'global optimum\': This indicates that we need to find the best possible outcome considering all possible operations.\n    Explanation: The degree adverb "global optimum" refers to the overall best score that can be achieved by performing the operations optimally.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Sort the array to easily access the smallest and largest elements.\n    - Perform exactly k operations, each time choosing the smallest and largest elements to minimize the score.\n    - After performing k operations, add the remaining elements to the score.\n\n# [edge case] \n    search([1, 2, 3], 2) = 3\n    Explanation: If k is 2, we perform two operations. One possible sequence of operations is to choose 1 and 2 first, then 1 and 3, resulting in a score of 0 + 1 + 0 = 1. After two operations, the remaining element is 3, so the final score is 1 + 3 = 4.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for k=2 is already included in the main algorithm.\n\n# [core concept]\n    \'Divide and Conquer\': This is a strategy to solve problems by breaking them down into smaller subproblems and solving them recursively.\n    Explanation: In this problem, we can break down the array into smaller parts by performing operations, and then combine the results to find the global optimum.\n\n# [phrase showing quantity relationship]\n    \'at least as many times\': This indicates that the frequency of an integer in the array should be at least as much as the integer itself.\n    Explanation: The phrase "at least as many times" means that for an integer to be considered, its frequency in the array should be greater than or equal to its value.\n\n# [degree adverb] \n    \'largest\': This indicates that we need to find the largest integer that meets the given condition.\n    Explanation: The degree adverb "largest" emphasizes the goal of finding the biggest integer that appears at least as many times as itself in the array.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Create a dictionary to store the frequency of each integer in the array.\n    - Iterate through the array to update the frequency in the dictionary.\n    - Iterate through the dictionary to find the largest integer that meets the condition.\n    - Return the result or -1 if no such integer exists.\n\n# [edge case] \n    search([1, 2, 3]) = 3\n    Explanation: If no integer appears at least as many times as itself, the function should return -1. In this case, the array does not meet this condition, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic for no such integer exists is already included in the main algorithm.', "- name: \nMinimize Remaining Elements\n\n- content: \n- **Solution Approach:**\n  - Focus on minimizing the sum of the remaining elements after k operations.\n  - For each operation, always choose the largest possible division to minimize the loss.\n  - This approach ensures that we maximize the score by minimizing the impact of remaining elements.\n- **Algorithm:**\n  1. Sort the array in descending order.\n  2. Perform k operations:\n     - Select the largest element and a smaller element such that their division results in a small integer.\n     - Remove these elements from the array and add their floor division to the score.\n  3. Sum any remaining elements not used in any operation.\n  4. Return the final score.\n- **Edge Cases:**\n  - Handle cases where n < 2k by either reducing k or returning an error message.\n  - Ensure handling of edge cases where all elements are the same or where k = 0.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'integer division': means the result of division is truncated to the nearest whole number towards zero.\n    Explanation: In the requirement, we need to perform operations where we divide one element by another and take the floor of the result. This is crucial for calculating the score accurately.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value.\n    'at least as many times': means that the frequency of an integer in the list should be at least as much as its value.\n\n# [degree adverb] \n    'largest': means that we need to find the largest integer that meets the condition.\n\n# [code logic]\n    The steps 2-4 should be implement simultaneously.\n    - Sort the array in descending order.\n    - Perform k operations by selecting the largest element and a smaller element for division.\n    - Add the floor of the division result to the score.\n    - Continue until k operations are completed or no more elements are left.\n    - Sum any remaining elements not used in any operation.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], 2) = 3\n    Explanation: The largest integer that appears at least as many times as itself is 3, as it appears twice.\n    search([1, 1, 1, 2, 2], 3) = -1\n    Explanation: No integer appears more than once, so the function returns -1.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k is 0.\n        if k == 0:\n            return sum(a)\n\n# [core concept]\n    'array operations': means working with elements in an array, including sorting, selecting, and performing arithmetic operations.\n    Explanation: In the requirement, we need to manipulate the array by sorting it and performing operations on its elements to find the minimum possible score.\n\n# [phrase showing quantity relationship]\n    'exactly k operations': means that we need to perform k specific operations on the array.\n\n# [degree adverb] \n    'minimum possible': means that we need to find the smallest score achievable by performing the operations.\n\n# [code logic]\n    The steps 1-4 should be implement simultaneously.\n    - Sort the array in descending order.\n    - Perform k operations by selecting the largest elements for division.\n    - Add the floor of the division result to the score.\n    - Continue until k operations are completed or no more elements are left.\n    - Sum any remaining elements not used in any operation.\n\n# [edge case] \n    search([1, 1, 1, 2, 2], 0) = 5\n    Explanation: Since k is 0, we don't perform any operations, and the score is the sum of all elements in the array.\n    search([5, 5, 4, 4, 4], 2) = 18\n    Explanation: The largest integer that appears at least as many times as itself is 4, but since we are performing 2 operations, we need to consider the minimum possible score.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where k is 0.\n        if k == 0:\n            return sum(a)"]
----------
False
----------
0
multi-gen-prompt:
 Tanya is learning to add numbers, but she is having trouble with it. She adds two numbers a and b by following these steps:

1. If one of the numbers is shorter than the other, Tanya adds leading zeros to make both numbers the same length.
2. She starts adding the numbers from the right, or the least significant digits, and works her way to the left.
3. In the first step, she adds the last digit of a to the last digit of b and writes down their sum at the end of the result.
4. For each subsequent step, she adds the corresponding digits

Input

The first line of input data contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

Each test case consists of a single line containing two positive integers a and s (1 ≤ a < s ≤ 10^{18}) separated by a space.

Output

For each test case print the answer on a separate line.

If the solution exists, print a single positive integer b. The answer must be written without leading zeros. If multiple answers exist, print any of them.

If no suitable number b exists, output -1.

Example

Input


6
17236 1106911
1 5
108 112
12345 1023412
1 11
1 20


Output


3465
4
-1
90007
10
-1

Note

The first test case is explained in the main part of the statement.

In the third test case, we cannot choose b that satisfies the problem statement.
multi-gen-prompt:
 Tanya is learning to add numbers incorrectly, adding from right to left with leading zeros if necessary. Given two positive integers a and s, find the number b such that adding a and b in this way results in s, or determine that no suitable b exists.

Input

The first line of input data contains an integer t (1 ≤ t ≤ 10^4) — the number of test cases.

Each test case consists of a single line containing two positive integers a and s (1 ≤ a < s ≤ 10^{18}) separated by a space.

Output

For each test case print the answer on a separate line.

If the solution exists, print a single positive integer b. The answer must be written without leading zeros. If multiple answers exist, print any of them.

If no suitable number b exists, output -1.

Example

Input


6
17236 1106911
1 5
108 112
12345 1023412
1 11
1 20


Output


3465
4
-1
90007
10
-1

Note

The first test case is explained in the main part of the statement.

In the third test case, we cannot choose b that satisfies the problem statement.
generating with deepseek-coder
----------
['def add_numbers(a, s):\n    # Convert numbers to strings to easily manipulate digits\n    a_str = str(a)\n    s_str = str(s)\n    \n    # Add leading zeros to the shorter number\n    if len(a_str) < len(s_str):\n        a_str = a_str.zfill(len(s_str))\n    else:\n        s_str = s_str.zfill(len(a_str))\n    \n    # Initialize the result string\n    result = ""\n    \n    # Iterate over the digits from right to left\n    for i in range(len(a_str) - 1, -1, -1):\n        a_digit = int(a_str[i])\n        s_digit = int(s_str[i])\n        \n        # Check if the sum of the digits is possible\n        if a_digit > s_digit:\n            # If the sum is greater than 9, it\'s impossible to find b\n            return -1\n        \n        # Calculate the digit for b\n        b_digit = s_digit - a_digit\n        \n        # Append the digit to the result string\n        result = str(b_digit) + result\n    \n    # Convert the result string to an integer and return it\n    return int(result)\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        s = int(data[index + 1])\n        index += 2\n        results.append(add_numbers(a, s))\n    \n    for result in results:\n        print(result)', 'def find_b(a, s):\n    # Convert numbers to strings for easier manipulation\n    a_str = str(a)\n    s_str = str(s)\n    \n    # Make both strings the same length by padding with leading zeros\n    max_len = max(len(a_str), len(s_str))\n    a_str = a_str.zfill(max_len)\n    s_str = s_str.zfill(max_len)\n    \n    # Initialize the result string\n    result = []\n    \n    # Start adding from the least significant digit\n    for i in range(max_len - 1, -1, -1):\n        a_digit = int(a_str[i])\n        s_digit = int(s_str[i])\n        \n        # If the sum of the digits exceeds 9, it\'s not possible to find b\n        if a_digit > s_digit:\n            return -1\n        \n        # Calculate the digit in b\n        b_digit = s_digit - a_digit\n        \n        # If b_digit is negative or greater than 9, it\'s not possible to find b\n        if b_digit < 0 or b_digit > 9:\n            return -1\n        \n        # Append the digit to the result\n        result.append(str(b_digit))\n    \n    # Reverse the result to get the correct order and convert to integer\n    b_str = \'\'.join(result[::-1])\n    b = int(b_str)\n    \n    # Check if b matches s (though this should always be true due to construction)\n    if int(s_str) == b + a:\n        return b\n    else:\n        return -1\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        s = int(data[index + 1])\n        index += 2\n        results.append(find_b(a, s))\n    \n    for result in results:\n        print(result)', 'def find_b(a, s):\n    b_str = \'\'\n    while s > 0:\n        last_digit_a = a % 10\n        last_digit_s = s % 10\n        if last_digit_a <= last_digit_s:\n            b_str = str(last_digit_s - last_digit_a) + b_str\n            a //= 10\n        else:\n            s //= 10\n            last_digit_s = s % 10\n            if last_digit_s == 1:\n                b_str = str(last_digit_s - last_digit_a + 10) + b_str\n                a //= 10\n            else:\n                return -1\n        s //= 10\n    if a > 0:\n        return -1\n    return int(b_str) if b_str else 0\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        a, s = map(int, input().split())\n        results.append(find_b(a, s))\n    for result in results:\n        print(result)', 'def find_b(a, s):\n    b = []\n    while s > 0:\n        da = a % 10\n        ds = s % 10\n        if da > ds:\n            # If the current digit of s is less than the corresponding digit of a,\n            # we need to borrow from the next higher place value.\n            s //= 10\n            ds = s % 10\n            if ds != 1:\n                # If the borrowed digit is not 1, it\'s an invalid case.\n                return -1\n            b.append(ds + 10 - da)\n        else:\n            b.append(ds - da)\n        a //= 10\n        s //= 10\n    # If there are remaining digits in a, it\'s an invalid case.\n    if a > 0:\n        return -1\n    # Reverse the list to get the correct order of digits for b.\n    b.reverse()\n    # Remove leading zeros from b.\n    while b and b[0] == 0:\n        b.pop(0)\n    # Construct the final number from the list of digits.\n    return int(\'\'.join(map(str, b)))\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        a, s = map(int, input().split())\n        results.append(find_b(a, s))\n    for result in results:\n        print(result)', 'def find_b(a, s):\n    b = []\n    while s > 0 or a > 0:\n        a_digit = a % 10\n        s_digit = s % 10\n        if a_digit > s_digit:\n            # Check if we need to carry over from the next significant digit\n            if s // 10 % 10 == 0:\n                return -1\n            b_digit = s_digit + 10 - a_digit\n            s //= 10\n        else:\n            b_digit = s_digit - a_digit\n        b.append(b_digit)\n        a //= 10\n        s //= 10\n    b.reverse()\n    return int(\'\'.join(map(str, b)))\n\ndef main():\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        a, s = map(int, input().strip().split())\n        result = find_b(a, s)\n        results.append(result)\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def find_b(a, s):\n    b = []\n    while s > 0 or a > 0:\n        a_digit = a % 10\n        s_digit = s % 10\n        if a_digit > s_digit:\n            # Check if we need to carry over from the next significant digit\n            if s // 10 % 10 == 0:\n                return -1\n            b_digit = s_digit + 10 - a_digit\n            s //= 10\n        else:\n            b_digit = s_digit - a_digit\n        b.append(b_digit)\n        a //= 10\n        s //= 10\n    b.reverse()\n    return int(\'\'.join(map(str, b)))\n\ndef main():\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        a, s = map(int, input().strip().split())\n        result = find_b(a, s)\n        results.append(result)\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def find_b(a, s):\n    b = []\n    while s > 0:\n        da = a % 10\n        ds = s % 10\n        if da > ds:\n            # If the current digit of s is less than the corresponding digit of a,\n            # we need to borrow from the next higher place value.\n            s //= 10\n            ds = s % 10\n            if ds != 1:\n                # If the borrowed digit is not 1, it\'s an invalid case.\n                return -1\n            b.append(ds + 10 - da)\n        else:\n            b.append(ds - da)\n        a //= 10\n        s //= 10\n    # If there are remaining digits in a, it\'s an invalid case.\n    if a > 0:\n        return -1\n    # Reverse the list to get the correct order of digits for b.\n    b.reverse()\n    # Remove leading zeros from b.\n    while b and b[0] == 0:\n        b.pop(0)\n    # Construct the final number from the list of digits.\n    return int(\'\'.join(map(str, b)))\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        a, s = map(int, input().split())\n        results.append(find_b(a, s))\n    for result in results:\n        print(result)', 'def find_b(a, s):\n    b = []\n    while s > 0 or a > 0:\n        a_digit = a % 10\n        s_digit = s % 10\n        if a_digit > s_digit:\n            # Check if we need to carry over from the next significant digit\n            if s // 10 % 10 == 0:\n                return -1\n            b_digit = s_digit + 10 - a_digit\n            s //= 10\n        else:\n            b_digit = s_digit - a_digit\n        b.append(b_digit)\n        a //= 10\n        s //= 10\n    b.reverse()\n    return int(\'\'.join(map(str, b)))\n\ndef main():\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        a, s = map(int, input().strip().split())\n        result = find_b(a, s)\n        results.append(result)\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def find_b(a, s):\n    b = []\n    while s > 0 or a > 0:\n        a_digit = a % 10\n        s_digit = s % 10\n        if a_digit > s_digit:\n            # Check if we need to carry over from the next significant digit\n            if s // 10 % 10 == 0:\n                return -1\n            b_digit = s_digit + 10 - a_digit\n            s //= 10\n        else:\n            b_digit = s_digit - a_digit\n        b.append(b_digit)\n        a //= 10\n        s //= 10\n    b.reverse()\n    return int(\'\'.join(map(str, b)))\n\ndef main():\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        a, s = map(int, input().strip().split())\n        result = find_b(a, s)\n        results.append(result)\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def find_b(a, s):\n    b = []\n    while s > 0:\n        da = a % 10\n        ds = s % 10\n        if da > ds:\n            # If the current digit of s is less than the corresponding digit of a,\n            # we need to borrow from the next higher place value.\n            s //= 10\n            ds = s % 10\n            if ds != 1:\n                # If the borrowed digit is not 1, it\'s an invalid case.\n                return -1\n            b.append(ds + 10 - da)\n        else:\n            b.append(ds - da)\n        a //= 10\n        s //= 10\n    # If there are remaining digits in a, it\'s an invalid case.\n    if a > 0:\n        return -1\n    # Reverse the list to get the correct order of digits for b.\n    b.reverse()\n    # Remove leading zeros from b.\n    while b and b[0] == 0:\n        b.pop(0)\n    # Construct the final number from the list of digits.\n    return int(\'\'.join(map(str, b)))\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        a, s = map(int, input().split())\n        results.append(find_b(a, s))\n    for result in results:\n        print(result)']
----------
['- name: \nBrute Force with Validation\n\n- content: \nThe solution plan involves the following steps:\n1. **Brute Force**: Generate all possible values of `b` by trying all combinations of digits from `0` to `9` that could result in the given `a` and `s`.\n2. **Validation**: For each generated `b`, check if the sum of `a` and `b` matches `s` when both are treated as strings with leading zeros added if necessary.\n3. **Output the First Valid Result**: Return the first valid `b` found, or `-1` if no valid `b` exists.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'leading zeros\': adding zeros at the beginning of a number to make it the same length as another number.\n    Explanation: This is important for aligning the digits of two numbers for addition, especially when one number is shorter than the other.\n\n# [phrase showing quantity relationship]\n    \'shorter\': means the number has fewer digits than the other number.\n    \'same length\': means both numbers have the same number of digits.\n\n# [degree adverb] \n    \'right\': means from the end or least significant digits towards the beginning.\n    Explanation: This indicates the direction in which Tanya adds the numbers, starting with the last digits.\n\n# [code logic]\n    The steps 1 and 2 should be considered simultaneously.\n    "If one of the numbers is shorter than the other, Tanya adds leading zeros to make both numbers the same length."\n    This could be implemented by checking the length of both numbers and padding the shorter one with leading zeros.\n\n# [edge case] \n    search([1, 2, 3], [4, 5, 6]) = [5, 7, 9]\n    Explanation: The numbers are added digit by digit from right to left, and if one number is shorter, leading zeros are added to make both the same length.\n    search([9, 9, 9], [1, 0, 0, 1]) = [1, 1, 0, 0]\n    Explanation: Both numbers are padded with leading zeros to make them the same length, and then added digit by digit.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the numbers cannot be added correctly due to mismatched lengths or invalid digits.\n        (code for handling the edge case)\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the numbers cannot be added correctly due to mismatched lengths or invalid digits.\n        (code for handling the edge case)', "- name: \nMathematical Analysis and Simulation\n\n- content: \nThe solution approach involves the following steps:\n1. Analyze the problem by examining the properties of the digits and their interactions during the addition process.\n2. Use a simulation approach to mimic the addition process from the least significant digit to the most significant digit.\n3. Keep track of any carry-overs and ensure they are correctly handled throughout the addition process.\n4. If at any point the sum of two digits exceeds 9 or if the carry-over cannot be resolved, return -1 indicating no valid b exists.\n5. If the addition is successful, construct the number b from the sums obtained.\n6. Return b if valid, otherwise return -1.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'digit addition': involves adding digits from right to left, handling carry-overs, and ensuring the result does not exceed 9.\n\n# [phrase showing quantity relationship]\n    'shorter': means the number with fewer digits needs to be padded with leading zeros to match the length of the other number.\n\n# [degree adverb] \n    'right': means the addition starts from the least significant digits (rightmost) and moves towards the left.\n\n# [code logic]\n    The steps 1-5 should be considered simultaneously.\n    - Step 1: Ensure both numbers have the same length by adding leading zeros to the shorter one.\n    - Step 2: Start adding from the rightmost digit, keeping track of carry-overs.\n    - Step 3: For each step, add corresponding digits and handle carry-overs.\n    - Step 4: If at any point the sum exceeds 9 or carry-over cannot be resolved, return -1.\n    - Step 5: Construct the result number from the sums obtained.\n\n# [edge case] \n    search([1, 2, 3, 4, 5], [1, 0, 2, 3, 4, 1]) = -1\n    explanation: The lengths of the two numbers are different, and there is no way to make them the same length without changing the value of one of the numbers, which is not allowed.\n    search([1, 2, 3, 4, 5], [1, 0, 2, 3, 4, 1]) = -1\n    explanation: The lengths of the two numbers are different, and there is no way to make them the same length without changing the value of one of the numbers, which is not allowed.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the lengths of the numbers are different.\n        if len(a) > len(b):\n            b = b.zfill(len(a))\n        elif len(b) > len(a):\n            a = a.zfill(len(b))\n        (other code)\n\nPlease note that the edge cases provided in the example are hypothetical and may not directly correspond to the problem statement as given. The edge cases are used to illustrate potential issues that might arise during the implementation of the code.", "- name: \nBrute Force with Constraints\n\n- content: \nWe can use a brute force approach to iterate through all possible values of b and check if adding a and b results in s. Given the constraints, we can limit our search space to ensure efficiency.\n\nAlgorithm:\n1. For each test case, iterate through possible values of b starting from 0 up to a reasonable limit based on the size of s - a.\n2. Check if adding a and b results in s.\n3. If a valid b is found, return it.\n4. If no valid b is found after checking all possibilities, return -1.\n\nThis solution ensures functional correctness by handling all possible valid inputs and edge cases as described in the problem statement.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'leading zeros': means that if the sum of digits exceeds the number of digits in the smaller number, leading zeros are added to the smaller number to match the length of the sum.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate through all possible values of b starting from 0 up to a reasonable limit based on the size of s - a. This can be done by a brute force approach.\n\n# [edge case] \n    search([1, 11]) = 10\n    explanation: The sum of 1 and 10 is 11, and there are no leading zeros added.\n    search([1, 20]) = 19\n    explanation: The sum of 1 and 19 is 20, and there are no leading zeros added.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute force approach will naturally handle cases where the sum of a and b is exactly s without leading zeros.\n\n# [core concept]\n    'Brute Force': means checking all possible values to find a solution, which is suitable for this problem as we need to iterate through all possible values of b.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate through all possible values of b starting from 0 up to a reasonable limit based on the size of s - a. This can be done by a brute force approach.\n\n# [edge case] \n    search([1, 5]) = 4\n    explanation: The sum of 1 and 4 is 5, and there are no leading zeros added.\n    search([108, 112]) = -1\n    explanation: There is no b such that the sum of 108 and b is 112 without leading zeros, as 112 - 108 = 4, which is less than 108 and cannot be represented with leading zeros.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute force approach will naturally handle cases where the sum of a and b is exactly s without leading zeros.\n\n# [core concept]\n    'leading zeros': means that if the sum of digits exceeds the number of digits in the smaller number, leading zeros are added to the smaller number to match the length of the sum.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate through all possible values of b starting from 0 up to a reasonable limit based on the size of s - a. This can be done by a brute force approach.\n\n# [edge case] \n    search([12345, 1023412]) = 90007\n    explanation: The sum of 12345 and 90007 is 1023412, and there are no leading zeros added.\n    search([5, 5]) = 0\n    explanation: The sum of 5 and 0 is 5, and there are no leading zeros added.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute force approach will naturally handle cases where the sum of a and b is exactly s without leading zeros.", "- name: \nGreedy Algorithm with Carry Propagation\n\n- content: \nWe can use a greedy approach to solve the problem by iterating from the least significant digit to the most significant digit, keeping track of any carry that may occur. For each pair of digits from a and s, we determine the corresponding digit in b, ensuring that the sum does not exceed 9. If at any point we encounter a situation where the sum of two digits exceeds 9 and there is no preceding carry, we return -1. This method ensures that we find a valid b if it exists by leveraging the properties of binary addition.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'leading zeros': means that if the sum of two digits exceeds 9, we need to add a digit with a leading zero to the sum to ensure the correct binary addition representation.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate from the least significant digit to the most significant digit, keeping track of any carry that may occur. For each pair of digits from a and s, we determine the corresponding digit in b, ensuring that the sum does not exceed 9.\n\n# [edge case] \n    search([1, 1], 2) = 1\n    explanation: The sum of the digits is 2, which is equal to s, and there is no carry. The corresponding b is 1.\n    search([1, 2], 3) = 2\n    explanation: The sum of the digits is 3, which is equal to s, and there is no carry. The corresponding b is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The given logic already correctly handles the case where the sum of two digits exceeds 9 by adding a leading zero to the sum.\n\n# [core concept]\n    'carry propagation': means that if the sum of two digits exceeds 9, we need to carry over the excess to the next digit, ensuring the correct binary addition representation.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate from the least significant digit to the most significant digit, keeping track of any carry that may occur. For each pair of digits from a and s, we determine the corresponding digit in b, ensuring that the sum does not exceed 9.\n\n# [edge case] \n    search([1, 1], 2) = 1\n    explanation: The sum of the digits is 2, which is equal to s, and there is no carry. The corresponding b is 1.\n    search([1, 2], 3) = 2\n    explanation: The sum of the digits is 3, which is equal to s, and there is no carry. The corresponding b is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The given logic already correctly handles the case where the sum of two digits exceeds 9 by adding a leading zero to the sum.", "- name: \nMathematical Deduction\n\n- content: \nThis solution leverages mathematical properties and deductions to directly compute the value of b without the need for exhaustive iteration. It is more efficient for large numbers.\n\nApproach:\n1. Align a and s with leading zeros if necessary.\n2. Start from the least significant digit and move towards the most significant digit.\n3. For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n4. If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n5. Construct b from the differences and carry overs.\n6. If a valid b is constructed, return it; otherwise, return -1.\n\nThis method ensures functional correctness by correctly handling all valid inputs and edge cases as per the problem description.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'addition': the process of combining two numbers to get a sum.\n    'leading zeros': adding zeros at the beginning of a number to make it the same length as another number.\n    'least significant digit': the rightmost digit of a number.\n    'most significant digit': the leftmost digit of a number.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find a number greater than a given value.\n    'at least as many times': means that the frequency of a number in a list should be greater than or equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition.\n\n# [code logic]\n    The steps 1-6 should be implement simultaneously.\n    Align a and s with leading zeros if necessary.\n    Start from the least significant digit and move towards the most significant digit.\n    For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n    If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n    Construct b from the differences and carry overs.\n    If a valid b is constructed, return it; otherwise, return -1.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'addition': the process of combining two numbers to get a sum.\n    'leading zeros': adding zeros at the beginning of a number to make it the same length as another number.\n    'least significant digit': the rightmost digit of a number.\n    'most significant digit': the leftmost digit of a number.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find a number greater than a given value.\n    'at least as many times': means that the frequency of a number in a list should be greater than or equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition.\n\n# [code logic]\n    The steps 1-6 should be implement simultaneously.\n    Align a and s with leading zeros if necessary.\n    Start from the least significant digit and move towards the most significant digit.\n    For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n    If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n    Construct b from the differences and carry overs.\n    If a valid b is constructed, return it; otherwise, return -1.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)", "- name: \nMathematical Deduction\n\n- content: \nThis solution leverages mathematical properties and deductions to directly compute the value of b without the need for exhaustive iteration. It is more efficient for large numbers.\n\nApproach:\n1. Align a and s with leading zeros if necessary.\n2. Start from the least significant digit and move towards the most significant digit.\n3. For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n4. If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n5. Construct b from the differences and carry overs.\n6. If a valid b is constructed, return it; otherwise, return -1.\n\nThis method ensures functional correctness by correctly handling all valid inputs and edge cases as per the problem description.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'addition': the process of combining two numbers to get a sum.\n    'leading zeros': adding zeros at the beginning of a number to make it the same length as another number.\n    'least significant digit': the rightmost digit of a number.\n    'most significant digit': the leftmost digit of a number.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find a number greater than a given value.\n    'at least as many times': means that the frequency of a number in a list should be greater than or equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition.\n\n# [code logic]\n    The steps 1-6 should be implement simultaneously.\n    Align a and s with leading zeros if necessary.\n    Start from the least significant digit and move towards the most significant digit.\n    For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n    If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n    Construct b from the differences and carry overs.\n    If a valid b is constructed, return it; otherwise, return -1.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'addition': the process of combining two numbers to get a sum.\n    'leading zeros': adding zeros at the beginning of a number to make it the same length as another number.\n    'least significant digit': the rightmost digit of a number.\n    'most significant digit': the leftmost digit of a number.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find a number greater than a given value.\n    'at least as many times': means that the frequency of a number in a list should be greater than or equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition.\n\n# [code logic]\n    The steps 1-6 should be implement simultaneously.\n    Align a and s with leading zeros if necessary.\n    Start from the least significant digit and move towards the most significant digit.\n    For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n    If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n    Construct b from the differences and carry overs.\n    If a valid b is constructed, return it; otherwise, return -1.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)", "- name: \nGreedy Algorithm with Carry Propagation\n\n- content: \nWe can use a greedy approach to solve the problem by iterating from the least significant digit to the most significant digit, keeping track of any carry that may occur. For each pair of digits from a and s, we determine the corresponding digit in b, ensuring that the sum does not exceed 9. If at any point we encounter a situation where the sum of two digits exceeds 9 and there is no preceding carry, we return -1. This method ensures that we find a valid b if it exists by leveraging the properties of binary addition.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'leading zeros': means that if the sum of two digits exceeds 9, we need to add a digit with a leading zero to the sum to ensure the correct binary addition representation.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate from the least significant digit to the most significant digit, keeping track of any carry that may occur. For each pair of digits from a and s, we determine the corresponding digit in b, ensuring that the sum does not exceed 9.\n\n# [edge case] \n    search([1, 1], 2) = 1\n    explanation: The sum of the digits is 2, which is equal to s, and there is no carry. The corresponding b is 1.\n    search([1, 2], 3) = 2\n    explanation: The sum of the digits is 3, which is equal to s, and there is no carry. The corresponding b is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The given logic already correctly handles the case where the sum of two digits exceeds 9 by adding a leading zero to the sum.\n\n# [core concept]\n    'carry propagation': means that if the sum of two digits exceeds 9, we need to carry over the excess to the next digit, ensuring the correct binary addition representation.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate from the least significant digit to the most significant digit, keeping track of any carry that may occur. For each pair of digits from a and s, we determine the corresponding digit in b, ensuring that the sum does not exceed 9.\n\n# [edge case] \n    search([1, 1], 2) = 1\n    explanation: The sum of the digits is 2, which is equal to s, and there is no carry. The corresponding b is 1.\n    search([1, 2], 3) = 2\n    explanation: The sum of the digits is 3, which is equal to s, and there is no carry. The corresponding b is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The given logic already correctly handles the case where the sum of two digits exceeds 9 by adding a leading zero to the sum.", "- name: \nMathematical Deduction\n\n- content: \nThis solution leverages mathematical properties and deductions to directly compute the value of b without the need for exhaustive iteration. It is more efficient for large numbers.\n\nApproach:\n1. Align a and s with leading zeros if necessary.\n2. Start from the least significant digit and move towards the most significant digit.\n3. For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n4. If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n5. Construct b from the differences and carry overs.\n6. If a valid b is constructed, return it; otherwise, return -1.\n\nThis method ensures functional correctness by correctly handling all valid inputs and edge cases as per the problem description.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'addition': the process of combining two numbers to get a sum.\n    'leading zeros': adding zeros at the beginning of a number to make it the same length as another number.\n    'least significant digit': the rightmost digit of a number.\n    'most significant digit': the leftmost digit of a number.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find a number greater than a given value.\n    'at least as many times': means that the frequency of a number in a list should be greater than or equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition.\n\n# [code logic]\n    The steps 1-6 should be implement simultaneously.\n    Align a and s with leading zeros if necessary.\n    Start from the least significant digit and move towards the most significant digit.\n    For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n    If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n    Construct b from the differences and carry overs.\n    If a valid b is constructed, return it; otherwise, return -1.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'addition': the process of combining two numbers to get a sum.\n    'leading zeros': adding zeros at the beginning of a number to make it the same length as another number.\n    'least significant digit': the rightmost digit of a number.\n    'most significant digit': the leftmost digit of a number.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find a number greater than a given value.\n    'at least as many times': means that the frequency of a number in a list should be greater than or equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition.\n\n# [code logic]\n    The steps 1-6 should be implement simultaneously.\n    Align a and s with leading zeros if necessary.\n    Start from the least significant digit and move towards the most significant digit.\n    For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n    If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n    Construct b from the differences and carry overs.\n    If a valid b is constructed, return it; otherwise, return -1.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)", "- name: \nMathematical Deduction\n\n- content: \nThis solution leverages mathematical properties and deductions to directly compute the value of b without the need for exhaustive iteration. It is more efficient for large numbers.\n\nApproach:\n1. Align a and s with leading zeros if necessary.\n2. Start from the least significant digit and move towards the most significant digit.\n3. For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n4. If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n5. Construct b from the differences and carry overs.\n6. If a valid b is constructed, return it; otherwise, return -1.\n\nThis method ensures functional correctness by correctly handling all valid inputs and edge cases as per the problem description.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'addition': the process of combining two numbers to get a sum.\n    'leading zeros': adding zeros at the beginning of a number to make it the same length as another number.\n    'least significant digit': the rightmost digit of a number.\n    'most significant digit': the leftmost digit of a number.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find a number greater than a given value.\n    'at least as many times': means that the frequency of a number in a list should be greater than or equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition.\n\n# [code logic]\n    The steps 1-6 should be implement simultaneously.\n    Align a and s with leading zeros if necessary.\n    Start from the least significant digit and move towards the most significant digit.\n    For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n    If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n    Construct b from the differences and carry overs.\n    If a valid b is constructed, return it; otherwise, return -1.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'addition': the process of combining two numbers to get a sum.\n    'leading zeros': adding zeros at the beginning of a number to make it the same length as another number.\n    'least significant digit': the rightmost digit of a number.\n    'most significant digit': the leftmost digit of a number.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find a number greater than a given value.\n    'at least as many times': means that the frequency of a number in a list should be greater than or equal to the number itself.\n\n# [degree adverb] \n    'largest': means that we need to find the biggest number that meets the condition.\n\n# [code logic]\n    The steps 1-6 should be implement simultaneously.\n    Align a and s with leading zeros if necessary.\n    Start from the least significant digit and move towards the most significant digit.\n    For each pair of digits (a_i, s_i), compute the difference (s_i - a_i).\n    If the difference is less than 0, check if there is a carry from the previous digit that satisfies the condition.\n    Construct b from the differences and carry overs.\n    If a valid b is constructed, return it; otherwise, return -1.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)", "- name: \nGreedy Algorithm with Carry Propagation\n\n- content: \nWe can use a greedy approach to solve the problem by iterating from the least significant digit to the most significant digit, keeping track of any carry that may occur. For each pair of digits from a and s, we determine the corresponding digit in b, ensuring that the sum does not exceed 9. If at any point we encounter a situation where the sum of two digits exceeds 9 and there is no preceding carry, we return -1. This method ensures that we find a valid b if it exists by leveraging the properties of binary addition.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'leading zeros': means that if the sum of two digits exceeds 9, we need to add a digit with a leading zero to the sum to ensure the correct binary addition representation.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate from the least significant digit to the most significant digit, keeping track of any carry that may occur. For each pair of digits from a and s, we determine the corresponding digit in b, ensuring that the sum does not exceed 9.\n\n# [edge case] \n    search([1, 1], 2) = 1\n    explanation: The sum of the digits is 2, which is equal to s, and there is no carry. The corresponding b is 1.\n    search([1, 2], 3) = 2\n    explanation: The sum of the digits is 3, which is equal to s, and there is no carry. The corresponding b is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The given logic already correctly handles the case where the sum of two digits exceeds 9 by adding a leading zero to the sum.\n\n# [core concept]\n    'carry propagation': means that if the sum of two digits exceeds 9, we need to carry over the excess to the next digit, ensuring the correct binary addition representation.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. We need to iterate from the least significant digit to the most significant digit, keeping track of any carry that may occur. For each pair of digits from a and s, we determine the corresponding digit in b, ensuring that the sum does not exceed 9.\n\n# [edge case] \n    search([1, 1], 2) = 1\n    explanation: The sum of the digits is 2, which is equal to s, and there is no carry. The corresponding b is 1.\n    search([1, 2], 3) = 2\n    explanation: The sum of the digits is 3, which is equal to s, and there is no carry. The corresponding b is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The given logic already correctly handles the case where the sum of two digits exceeds 9 by adding a leading zero to the sum."]
----------
False
----------
0
multi-gen-prompt:
 You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers (a_1 and a_2, a_2 and a_3, ..., a_{n - 1} and a_n, and a_n and a_1), you wrote down: are the numbers in the pair equal or not. Unfortunately, you've lost a piece of paper with the array a. Moreover, you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array a which is consistent with

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Next t cases follow.

The first and only line of each test case contains a non-empty string s consisting of characters E and/or N. The length of s is equal to the size of array n and 2 ≤ n ≤ 50. For each i from 1 to n: 

  * if s_i = E then a_i is equal to a_{i + 1} (a_n = a_1 for i = n); 
  * if s_i = N then a_i is not equal to a_{i + 1} (a_n ≠ a_1 for i = n). 

Output

For each test case, print YES if it's possible to choose array a that are consistent with information from s you know. Otherwise, print NO.

It can be proved, that if there exists some array a, then there exists an array a of positive integers with values less or equal to 10^9.

Example

Input


4
EEE
EN
ENNEENE
NENN


Output


YES
NO
YES
YES

Note

In the first test case, you can choose, for example, a_1 = a_2 = a_3 = 5.

In the second test case, there is no array a, since, according to s_1, a_1 is equal to a_2, but, according to s_2, a_2 is not equal to a_1.

In the third test case, you can, for example, choose array a = [20, 20, 4, 50, 50, 50, 20].

In the fourth test case, you can, for example, choose a = [1, 3, 3, 7].
multi-gen-prompt:
 You had n positive integers a_1, a_2, ..., a_n arranged in a circle. For each pair of neighboring numbers, you wrote down whether the numbers in the pair were equal or not. Unfortunately, you've lost the array a, and you're concerned that the information about the equality or non-equality of neighboring elements might be inconsistent. Is there any array a that could be consistent with this information?

Input

The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Next t cases follow.

The first and only line of each test case contains a non-empty string s consisting of characters E and/or N. The length of s is equal to the size of array n and 2 ≤ n ≤ 50. For each i from 1 to n: 

  * if s_i = E then a_i is equal to a_{i + 1} (a_n = a_1 for i = n); 
  * if s_i = N then a_i is not equal to a_{i + 1} (a_n ≠ a_1 for i = n). 

Output

For each test case, print YES if it's possible to choose array a that are consistent with information from s you know. Otherwise, print NO.

It can be proved, that if there exists some array a, then there exists an array a of positive integers with values less or equal to 10^9.

Example

Input


4
EEE
EN
ENNEENE
NENN


Output


YES
NO
YES
YES

Note

In the first test case, you can choose, for example, a_1 = a_2 = a_3 = 5.

In the second test case, there is no array a, since, according to s_1, a_1 is equal to a_2, but, according to s_2, a_2 is not equal to a_1.

In the third test case, you can, for example, choose array a = [20, 20, 4, 50, 50, 50, 20].

In the fourth test case, you can, for example, choose a = [1, 3, 3, 7].
generating with deepseek-coder
----------
['def is_consistent(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] == \'E\':\n            if s[(i + 1) % n] == \'E\':\n                return True\n        else:\n            if s[(i + 1) % n] == \'N\':\n                return True\n    return False\n\ndef f1(t, test_cases):\n    results = []\n    for s in test_cases:\n        results.append("YES" if is_consistent(s) else "NO")\n    return results\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    test_cases = [input().strip() for _ in range(t)]\n    results = f1(t, test_cases)\n    for result in results:\n        print(result)', 'def is_consistent_array(s):\n    n = len(s)\n    for i in range(n):\n        for j in range(1, 10**9 + 1):\n            valid = True\n            for k in range(n):\n                if s[k] == \'E\' and (j != j) != (j != j):\n                    valid = False\n                    break\n                if s[k] == \'N\' and (j == j) != (j == j):\n                    valid = False\n                    break\n            if valid:\n                return "YES"\n    return "NO"\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        s = input().strip()\n        result = is_consistent_array(s)\n        print(result)\n\nif __name__ == "__main__":\n    solve()', 'def is_consistent_array(s):\n    n = len(s)\n    if \'E\' not in s:\n        return "YES"\n    if \'N\' not in s:\n        return "YES"\n    if n == 2:\n        return "NO"\n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        s = input()\n        results.append(is_consistent_array(s))\n    for result in results:\n        print(result)', 'def is_consistent(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] == \'E\':\n            if s[(i + 1) % n] == \'E\':\n                return True\n        else:\n            if s[(i + 1) % n] == \'N\':\n                return True\n    return False\n\ndef f1(t, test_cases):\n    results = []\n    for s in test_cases:\n        results.append("YES" if is_consistent(s) else "NO")\n    return results\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    test_cases = [input().strip() for _ in range(t)]\n    results = f1(t, test_cases)\n    for result in results:\n        print(result)', 'def is_consistent(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] == \'E\':\n            if s[(i + 1) % n] == \'E\':\n                return True\n        else:\n            if s[(i + 1) % n] == \'N\':\n                return True\n    return False\n\ndef f1(t, test_cases):\n    results = []\n    for s in test_cases:\n        results.append("YES" if is_consistent(s) else "NO")\n    return results\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    test_cases = [input().strip() for _ in range(t)]\n    results = f1(t, test_cases)\n    for result in results:\n        print(result)', 'def is_consistent(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] == \'E\':\n            if s[(i + 1) % n] == \'E\':\n                return True\n        else:\n            if s[(i + 1) % n] == \'N\':\n                return True\n    return False\n\ndef f1(t, test_cases):\n    results = []\n    for s in test_cases:\n        results.append("YES" if is_consistent(s) else "NO")\n    return results\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    test_cases = [input().strip() for _ in range(t)]\n    results = f1(t, test_cases)\n    for result in results:\n        print(result)', 'def is_consistent(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] == \'E\':\n            if s[(i + 1) % n] == \'E\':\n                return True\n        else:\n            if s[(i + 1) % n] == \'N\':\n                return True\n    return False\n\ndef f1(t, test_cases):\n    results = []\n    for s in test_cases:\n        results.append("YES" if is_consistent(s) else "NO")\n    return results\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    test_cases = [input().strip() for _ in range(t)]\n    results = f1(t, test_cases)\n    for result in results:\n        print(result)', 'def is_consistent(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] == \'E\':\n            if s[(i + 1) % n] == \'E\':\n                return True\n        else:\n            if s[(i + 1) % n] == \'N\':\n                return True\n    return False\n\ndef f1(t, test_cases):\n    results = []\n    for s in test_cases:\n        results.append("YES" if is_consistent(s) else "NO")\n    return results\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    test_cases = [input().strip() for _ in range(t)]\n    results = f1(t, test_cases)\n    for result in results:\n        print(result)', 'def is_consistent(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] == \'E\':\n            if s[(i + 1) % n] == \'E\':\n                return True\n        else:\n            if s[(i + 1) % n] == \'N\':\n                return True\n    return False\n\ndef f1(t, test_cases):\n    results = []\n    for s in test_cases:\n        results.append("YES" if is_consistent(s) else "NO")\n    return results\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    test_cases = [input().strip() for _ in range(t)]\n    results = f1(t, test_cases)\n    for result in results:\n        print(result)', 'def is_consistent(s):\n    n = len(s)\n    for i in range(n):\n        if s[i] == \'E\':\n            if s[(i + 1) % n] == \'E\':\n                return True\n        else:\n            if s[(i + 1) % n] == \'N\':\n                return True\n    return False\n\ndef f1(t, test_cases):\n    results = []\n    for s in test_cases:\n        results.append("YES" if is_consistent(s) else "NO")\n    return results\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    test_cases = [input().strip() for _ in range(t)]\n    results = f1(t, test_cases)\n    for result in results:\n        print(result)']
----------
['- name: \nBrute Force Check for Validity\n\n- content: \nFor each test case, we can generate all possible arrays and check if any of them satisfy the given conditions.\n\n**Solution Approach:**\n1. **Array Generation:**\n   - Generate all possible arrays of positive integers that fit within the constraints.\n2. **Condition Check:**\n   - For each array, check if it satisfies the conditions given by the string.\n3. **Output Result:**\n   - If a valid array is found, output "YES". Otherwise, output "NO".\n\n**Edge Cases:**\n- Small input size allows for brute force generation and checking.\n- Ensure that the generated arrays are within the constraints of positive integers up to 10^9.\n\nThis approach ensures that all possible arrays are checked, but it may be computationally expensive for larger inputs.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array arrangement\': means the order of elements in a list and how they relate to each other.\n    \'equality/non-equality\': means the relationship between neighboring elements in the array.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach is to generate all possible arrays and check if they satisfy the conditions. This can be done by iterating through possible values for each position in the array and checking if the conditions are met.\n\n# [edge case] \n    test case: EEE\n    expected output: YES\n    explanation: For the string "EEE", we can choose the same value for all elements (e.g., a_1 = a_2 = a_3 = 5). This satisfies the condition that each element is equal to its neighbor.\n\n    test case: EN\n    expected output: NO\n    explanation: The string "EN" implies that the first element is not equal to the second, and the second is equal to the third (considering the circular nature). This is a contradiction, so no array can satisfy both conditions simultaneously.\n\n    test case: ENNEENE\n    expected output: YES\n    explanation: For the string "ENNEENE", we can choose an array such as [20, 20, 4, 50, 50, 50, 20]. This array satisfies the conditions given by the string, as it alternates between equality and non-equality.\n\n    test case: NENN\n    expected output: YES\n    explanation: For the string "NENN", we can choose an array such as [1, 3, 3, 7]. This array satisfies the conditions, as it alternates between non-equality and equality.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the brute force approach is straightforward and fits within the constraints provided.', '- name: \nBrute Force Solution\n\n- content: \nFor each test case, we can try all possible sequences of positive integers that could satisfy the given conditions. We iterate through possible values for each element in the sequence and check if they satisfy all conditions. This approach is feasible given the constraint on the size of n (2 ≤ n ≤ 50). We need to ensure that no two consecutive elements violate the conditions specified by the string s. If we find a valid sequence for any test case, we output "YES"; otherwise, we output "NO".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'circle arrangement\': means that the last element is considered adjacent to the first element.\n    \'equality or non-equality\': refers to the relationship between neighboring elements in the sequence.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    For each test case, we need to check all possible sequences of positive integers that could satisfy the given conditions. This can be done by iterating through possible values for each element in the sequence and checking if they satisfy all conditions.\n\n# [edge case] \n    Test case: EEE\n    Expected output: YES\n    Explanation: For this test case, we can choose the same value for all elements since all neighboring elements are required to be equal. For example, a_1 = a_2 = a_3 = 5.\n\n    Test case: EN\n    Expected output: NO\n    Explanation: In this test case, the first element requires that a_1 = a_2, and the second element requires that a_2 ≠ a_1. These two conditions are contradictory, so there is no array a that can satisfy both conditions simultaneously.\n\n    Test case: ENNEENE\n    Expected output: YES\n    Explanation: For this test case, we can choose a sequence where the values repeat in a way that satisfies the conditions. For example, a = [20, 20, 4, 50, 50, 50, 20].\n\n    Test case: NENN\n    Expected output: YES\n    Explanation: For this test case, we can choose a sequence where the values are chosen such that no two consecutive elements are equal. For example, a = [1, 3, 3, 7].\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases since the brute force solution can be used to check all possible sequences for validity.', '- name: \nConsistency Check via Simulation\n\n- content: \nFor each test case, simulate the possible arrangement of the array based on the given string of \'E\' and \'N\'.\n\n- If the string contains only \'E\', any sequence of positive integers is valid.\n- If the string contains only \'N\', any sequence of distinct positive integers is valid.\n- If the string contains both \'E\' and \'N\', check if there\'s a way to arrange the numbers such that all conditions are satisfied. This can be done by ensuring that no two consecutive numbers are forced to be both equal or both not equal by adjacent conditions.\n\nTo implement this:\n1. Parse the input string.\n2. For each test case, initialize an array of size n.\n3. Based on the presence of \'E\' and \'N\', assign values to the array elements.\n4. Check if the conditions are satisfied for all pairs. If they are, output "YES"; otherwise, output "NO".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array arrangement\': understanding the relationship between neighboring elements in an array based on \'E\' (equal) and \'N\' (not equal) conditions.\n    Explanation: The core concept here is to determine if there\'s a consistent arrangement of integers in an array that adheres to the given \'E\' and \'N\' conditions.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    The steps should be implemented sequentially for each test case.\n    For each test case:\n    1. Parse the input string to understand the conditions.\n    2. Initialize an array of size n.\n    3. Assign values to the array elements based on the conditions.\n    4. Check if the conditions are satisfied for all pairs.\n\n# [edge case] \n    Edge case 1: s = "EEE"\n    Expected output: YES\n    Explanation: Since all conditions are \'E\', any sequence of positive integers is valid.\n\n    Edge case 2: s = "EN"\n    Expected output: NO\n    Explanation: The first condition says the numbers are equal, and the second says they are not. This is contradictory, so no valid array can be formed.\n\n    Edge case 3: s = "ENNEENE"\n    Expected output: YES\n    Explanation: The conditions allow for a sequence where numbers are equal and not equal in a cyclic manner, which can be satisfied by choosing appropriate values.\n\n    Edge case 4: s = "NENN"\n    Expected output: YES\n    Explanation: The conditions allow for a sequence where numbers are not equal and then equal, followed by two not equal conditions. This can be satisfied by choosing values accordingly.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to determine the validity of the array based on the given conditions.', '- name: \nBrute Force Check for Validity\n\n- content: \nFor each test case, we can generate all possible arrays and check if any of them satisfy the given conditions.\n\n**Solution Approach:**\n1. **Array Generation:**\n   - Generate all possible arrays of positive integers that fit within the constraints.\n2. **Condition Check:**\n   - For each array, check if it satisfies the conditions given by the string.\n3. **Output Result:**\n   - If a valid array is found, output "YES". Otherwise, output "NO".\n\n**Edge Cases:**\n- Small input size allows for brute force generation and checking.\n- Ensure that the generated arrays are within the constraints of positive integers up to 10^9.\n\nThis approach ensures that all possible arrays are checked, but it may be computationally expensive for larger inputs.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array arrangement\': means the order of elements in a list and how they relate to each other.\n    \'equality/non-equality\': means the relationship between neighboring elements in the array.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach is to generate all possible arrays and check if they satisfy the conditions. This can be done by iterating through possible values for each position in the array and checking if the conditions are met.\n\n# [edge case] \n    test case: EEE\n    expected output: YES\n    explanation: For the string "EEE", we can choose the same value for all elements (e.g., a_1 = a_2 = a_3 = 5). This satisfies the condition that each element is equal to its neighbor.\n\n    test case: EN\n    expected output: NO\n    explanation: The string "EN" implies that the first element is not equal to the second, and the second is equal to the third (considering the circular nature). This is a contradiction, so no array can satisfy both conditions simultaneously.\n\n    test case: ENNEENE\n    expected output: YES\n    explanation: For the string "ENNEENE", we can choose an array such as [20, 20, 4, 50, 50, 50, 20]. This array satisfies the conditions given by the string, as it alternates between equality and non-equality.\n\n    test case: NENN\n    expected output: YES\n    explanation: For the string "NENN", we can choose an array such as [1, 3, 3, 7]. This array satisfies the conditions, as it alternates between non-equality and equality.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the brute force approach is straightforward and fits within the constraints provided.', '- name: \nBrute Force Check for Validity\n\n- content: \nFor each test case, we can generate all possible arrays and check if any of them satisfy the given conditions.\n\n**Solution Approach:**\n1. **Array Generation:**\n   - Generate all possible arrays of positive integers that fit within the constraints.\n2. **Condition Check:**\n   - For each array, check if it satisfies the conditions given by the string.\n3. **Output Result:**\n   - If a valid array is found, output "YES". Otherwise, output "NO".\n\n**Edge Cases:**\n- Small input size allows for brute force generation and checking.\n- Ensure that the generated arrays are within the constraints of positive integers up to 10^9.\n\nThis approach ensures that all possible arrays are checked, but it may be computationally expensive for larger inputs.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array arrangement\': means the order of elements in a list and how they relate to each other.\n    \'equality/non-equality\': means the relationship between neighboring elements in the array.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach is to generate all possible arrays and check if they satisfy the conditions. This can be done by iterating through possible values for each position in the array and checking if the conditions are met.\n\n# [edge case] \n    test case: EEE\n    expected output: YES\n    explanation: For the string "EEE", we can choose the same value for all elements (e.g., a_1 = a_2 = a_3 = 5). This satisfies the condition that each element is equal to its neighbor.\n\n    test case: EN\n    expected output: NO\n    explanation: The string "EN" implies that the first element is not equal to the second, and the second is equal to the third (considering the circular nature). This is a contradiction, so no array can satisfy both conditions simultaneously.\n\n    test case: ENNEENE\n    expected output: YES\n    explanation: For the string "ENNEENE", we can choose an array such as [20, 20, 4, 50, 50, 50, 20]. This array satisfies the conditions given by the string, as it alternates between equality and non-equality.\n\n    test case: NENN\n    expected output: YES\n    explanation: For the string "NENN", we can choose an array such as [1, 3, 3, 7]. This array satisfies the conditions, as it alternates between non-equality and equality.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the brute force approach is straightforward and fits within the constraints provided.', '- name: \nBrute Force Check for Validity\n\n- content: \nFor each test case, we can generate all possible arrays and check if any of them satisfy the given conditions.\n\n**Solution Approach:**\n1. **Array Generation:**\n   - Generate all possible arrays of positive integers that fit within the constraints.\n2. **Condition Check:**\n   - For each array, check if it satisfies the conditions given by the string.\n3. **Output Result:**\n   - If a valid array is found, output "YES". Otherwise, output "NO".\n\n**Edge Cases:**\n- Small input size allows for brute force generation and checking.\n- Ensure that the generated arrays are within the constraints of positive integers up to 10^9.\n\nThis approach ensures that all possible arrays are checked, but it may be computationally expensive for larger inputs.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array arrangement\': means the order of elements in a list and how they relate to each other.\n    \'equality/non-equality\': means the relationship between neighboring elements in the array.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach is to generate all possible arrays and check if they satisfy the conditions. This can be done by iterating through possible values for each position in the array and checking if the conditions are met.\n\n# [edge case] \n    test case: EEE\n    expected output: YES\n    explanation: For the string "EEE", we can choose the same value for all elements (e.g., a_1 = a_2 = a_3 = 5). This satisfies the condition that each element is equal to its neighbor.\n\n    test case: EN\n    expected output: NO\n    explanation: The string "EN" implies that the first element is not equal to the second, and the second is equal to the third (considering the circular nature). This is a contradiction, so no array can satisfy both conditions simultaneously.\n\n    test case: ENNEENE\n    expected output: YES\n    explanation: For the string "ENNEENE", we can choose an array such as [20, 20, 4, 50, 50, 50, 20]. This array satisfies the conditions given by the string, as it alternates between equality and non-equality.\n\n    test case: NENN\n    expected output: YES\n    explanation: For the string "NENN", we can choose an array such as [1, 3, 3, 7]. This array satisfies the conditions, as it alternates between non-equality and equality.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the brute force approach is straightforward and fits within the constraints provided.', '- name: \nBrute Force Check for Validity\n\n- content: \nFor each test case, we can generate all possible arrays and check if any of them satisfy the given conditions.\n\n**Solution Approach:**\n1. **Array Generation:**\n   - Generate all possible arrays of positive integers that fit within the constraints.\n2. **Condition Check:**\n   - For each array, check if it satisfies the conditions given by the string.\n3. **Output Result:**\n   - If a valid array is found, output "YES". Otherwise, output "NO".\n\n**Edge Cases:**\n- Small input size allows for brute force generation and checking.\n- Ensure that the generated arrays are within the constraints of positive integers up to 10^9.\n\nThis approach ensures that all possible arrays are checked, but it may be computationally expensive for larger inputs.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array arrangement\': means the order of elements in a list and how they relate to each other.\n    \'equality/non-equality\': means the relationship between neighboring elements in the array.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach is to generate all possible arrays and check if they satisfy the conditions. This can be done by iterating through possible values for each position in the array and checking if the conditions are met.\n\n# [edge case] \n    test case: EEE\n    expected output: YES\n    explanation: For the string "EEE", we can choose the same value for all elements (e.g., a_1 = a_2 = a_3 = 5). This satisfies the condition that each element is equal to its neighbor.\n\n    test case: EN\n    expected output: NO\n    explanation: The string "EN" implies that the first element is not equal to the second, and the second is equal to the third (considering the circular nature). This is a contradiction, so no array can satisfy both conditions simultaneously.\n\n    test case: ENNEENE\n    expected output: YES\n    explanation: For the string "ENNEENE", we can choose an array such as [20, 20, 4, 50, 50, 50, 20]. This array satisfies the conditions given by the string, as it alternates between equality and non-equality.\n\n    test case: NENN\n    expected output: YES\n    explanation: For the string "NENN", we can choose an array such as [1, 3, 3, 7]. This array satisfies the conditions, as it alternates between non-equality and equality.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the brute force approach is straightforward and fits within the constraints provided.', '- name: \nBrute Force Check for Validity\n\n- content: \nFor each test case, we can generate all possible arrays and check if any of them satisfy the given conditions.\n\n**Solution Approach:**\n1. **Array Generation:**\n   - Generate all possible arrays of positive integers that fit within the constraints.\n2. **Condition Check:**\n   - For each array, check if it satisfies the conditions given by the string.\n3. **Output Result:**\n   - If a valid array is found, output "YES". Otherwise, output "NO".\n\n**Edge Cases:**\n- Small input size allows for brute force generation and checking.\n- Ensure that the generated arrays are within the constraints of positive integers up to 10^9.\n\nThis approach ensures that all possible arrays are checked, but it may be computationally expensive for larger inputs.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array arrangement\': means the order of elements in a list and how they relate to each other.\n    \'equality/non-equality\': means the relationship between neighboring elements in the array.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach is to generate all possible arrays and check if they satisfy the conditions. This can be done by iterating through possible values for each position in the array and checking if the conditions are met.\n\n# [edge case] \n    test case: EEE\n    expected output: YES\n    explanation: For the string "EEE", we can choose the same value for all elements (e.g., a_1 = a_2 = a_3 = 5). This satisfies the condition that each element is equal to its neighbor.\n\n    test case: EN\n    expected output: NO\n    explanation: The string "EN" implies that the first element is not equal to the second, and the second is equal to the third (considering the circular nature). This is a contradiction, so no array can satisfy both conditions simultaneously.\n\n    test case: ENNEENE\n    expected output: YES\n    explanation: For the string "ENNEENE", we can choose an array such as [20, 20, 4, 50, 50, 50, 20]. This array satisfies the conditions given by the string, as it alternates between equality and non-equality.\n\n    test case: NENN\n    expected output: YES\n    explanation: For the string "NENN", we can choose an array such as [1, 3, 3, 7]. This array satisfies the conditions, as it alternates between non-equality and equality.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the brute force approach is straightforward and fits within the constraints provided.', '- name: \nBrute Force Check for Validity\n\n- content: \nFor each test case, we can generate all possible arrays and check if any of them satisfy the given conditions.\n\n**Solution Approach:**\n1. **Array Generation:**\n   - Generate all possible arrays of positive integers that fit within the constraints.\n2. **Condition Check:**\n   - For each array, check if it satisfies the conditions given by the string.\n3. **Output Result:**\n   - If a valid array is found, output "YES". Otherwise, output "NO".\n\n**Edge Cases:**\n- Small input size allows for brute force generation and checking.\n- Ensure that the generated arrays are within the constraints of positive integers up to 10^9.\n\nThis approach ensures that all possible arrays are checked, but it may be computationally expensive for larger inputs.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array arrangement\': means the order of elements in a list and how they relate to each other.\n    \'equality/non-equality\': means the relationship between neighboring elements in the array.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach is to generate all possible arrays and check if they satisfy the conditions. This can be done by iterating through possible values for each position in the array and checking if the conditions are met.\n\n# [edge case] \n    test case: EEE\n    expected output: YES\n    explanation: For the string "EEE", we can choose the same value for all elements (e.g., a_1 = a_2 = a_3 = 5). This satisfies the condition that each element is equal to its neighbor.\n\n    test case: EN\n    expected output: NO\n    explanation: The string "EN" implies that the first element is not equal to the second, and the second is equal to the third (considering the circular nature). This is a contradiction, so no array can satisfy both conditions simultaneously.\n\n    test case: ENNEENE\n    expected output: YES\n    explanation: For the string "ENNEENE", we can choose an array such as [20, 20, 4, 50, 50, 50, 20]. This array satisfies the conditions given by the string, as it alternates between equality and non-equality.\n\n    test case: NENN\n    expected output: YES\n    explanation: For the string "NENN", we can choose an array such as [1, 3, 3, 7]. This array satisfies the conditions, as it alternates between non-equality and equality.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the brute force approach is straightforward and fits within the constraints provided.', '- name: \nBrute Force Check for Validity\n\n- content: \nFor each test case, we can generate all possible arrays and check if any of them satisfy the given conditions.\n\n**Solution Approach:**\n1. **Array Generation:**\n   - Generate all possible arrays of positive integers that fit within the constraints.\n2. **Condition Check:**\n   - For each array, check if it satisfies the conditions given by the string.\n3. **Output Result:**\n   - If a valid array is found, output "YES". Otherwise, output "NO".\n\n**Edge Cases:**\n- Small input size allows for brute force generation and checking.\n- Ensure that the generated arrays are within the constraints of positive integers up to 10^9.\n\nThis approach ensures that all possible arrays are checked, but it may be computationally expensive for larger inputs.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array arrangement\': means the order of elements in a list and how they relate to each other.\n    \'equality/non-equality\': means the relationship between neighboring elements in the array.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach is to generate all possible arrays and check if they satisfy the conditions. This can be done by iterating through possible values for each position in the array and checking if the conditions are met.\n\n# [edge case] \n    test case: EEE\n    expected output: YES\n    explanation: For the string "EEE", we can choose the same value for all elements (e.g., a_1 = a_2 = a_3 = 5). This satisfies the condition that each element is equal to its neighbor.\n\n    test case: EN\n    expected output: NO\n    explanation: The string "EN" implies that the first element is not equal to the second, and the second is equal to the third (considering the circular nature). This is a contradiction, so no array can satisfy both conditions simultaneously.\n\n    test case: ENNEENE\n    expected output: YES\n    explanation: For the string "ENNEENE", we can choose an array such as [20, 20, 4, 50, 50, 50, 20]. This array satisfies the conditions given by the string, as it alternates between equality and non-equality.\n\n    test case: NENN\n    expected output: YES\n    explanation: For the string "NENN", we can choose an array such as [1, 3, 3, 7]. This array satisfies the conditions, as it alternates between non-equality and equality.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the brute force approach is straightforward and fits within the constraints provided.']
----------
False
----------
0
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same.

Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step:

  * either you can select any blue element and decrease its value by 1; 
  * or you can select any red element and increase its value by 1. 

Situations in which there are no elements of some color at all are also possible. For example,

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
multi-gen-prompt:
 You are given an array of integers a of length n. The elements of the array can be either different or the same. Each element of the array is colored either blue or red. There are no unpainted elements in the array. One of the two operations described below can be applied to an array in a single step: either you can select any blue element and decrease its value by 1; or you can select any red element and increase its value by 1. Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n?

Input

The first line contains an integer t (1 ≤ t ≤ 10^4) — the number of input data sets in the test.

The description of each set of input data consists of three lines. The first line contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — the length of the original array a. The second line contains n integers a_1, a_2, ..., a_n (-10^9 ≤ a_i ≤ 10^9) — the array elements themselves.

The third line has length n and consists exclusively of the letters 'B' and/or 'R': ith character is 'B' if a_i is colored blue, and is 'R' if colored red.

It is guaranteed that the sum of n over all input sets does not exceed 2 ⋅ 10^5.

Output

Print t lines, each of which contains the answer to the corresponding test case of the input. Print YES as an answer if the corresponding array can be transformed into a permutation, and NO otherwise.

You can print the answer in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).

Example

Input


8
4
1 2 5 2
BRBR
2
1 1
BB
5
3 1 4 2 5
RBRRB
5
3 1 3 1 3
RBRRB
5
5 1 5 1 5
RBRRB
4
2 2 2 2
BRBR
2
1 -2
BR
4
-2 -1 4 0
RRRR


Output


YES
NO
YES
YES
NO
YES
YES
YES

Note

In the first test case of the example, the following sequence of moves can be performed:

  * choose i=3, element a_3=5 is blue, so we decrease it, we get a=[1,2,4,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,3,4,2]; 
  * choose i=3, element a_3=4 is blue, so we decrease it, we get a=[1,3,3,2]; 
  * choose i=2, element a_2=2 is red, so we increase it, we get a=[1,4,3,2]. 



We got that a is a permutation. Hence the answer is YES.
generating with deepseek-coder
----------
['def can_form_permutation(n, arr, colors):\n    blue_range = []\n    red_range = []\n\n    for i in range(n):\n        if colors[i] == \'B\':\n            blue_range.append(arr[i])\n        else:\n            red_range.append(arr[i])\n\n    blue_range.sort()\n    red_range.sort()\n\n    for i in range(len(blue_range)):\n        if blue_range[i] < i + 1:\n            return "NO"\n\n    for i in range(len(red_range)):\n        if red_range[i] > n - i:\n            return "NO"\n\n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        colors = input().strip()\n        results.append(can_form_permutation(n, arr, colors))\n    \n    for result in results:\n        print(result)', 'def can_form_permutation(n, a, colors):\n    blue_elements = []\n    red_elements = []\n    \n    for i in range(n):\n        if colors[i] == \'B\':\n            blue_elements.append(a[i])\n        else:\n            red_elements.append(a[i])\n    \n    # Sort the elements to determine the range\n    blue_elements.sort()\n    red_elements.sort()\n    \n    # Check if the sorted blue elements can cover the range from 1 to n\n    for i in range(len(blue_elements)):\n        if blue_elements[i] < i + 1:\n            return "NO"\n    \n    # Check if the sorted red elements can cover the range from 1 to n\n    for i in range(len(red_elements)):\n        if red_elements[i] > n - i:\n            return "NO"\n    \n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        colors = input().strip()\n        results.append(can_form_permutation(n, a, colors))\n    \n    for result in results:\n        print(result)', 'def can_form_permutation(n, arr, colors):\n    blue_range = []\n    red_range = []\n\n    for i in range(n):\n        if colors[i] == \'B\':\n            blue_range.append(arr[i])\n        else:\n            red_range.append(arr[i])\n\n    blue_range.sort()\n    red_range.sort()\n\n    for i in range(len(blue_range)):\n        if blue_range[i] < i + 1:\n            return "NO"\n\n    for i in range(len(red_range)):\n        if red_range[i] > n - i:\n            return "NO"\n\n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        colors = input().strip()\n        results.append(can_form_permutation(n, arr, colors))\n    \n    for result in results:\n        print(result)', 'def can_form_permutation(n, arr, colors):\n    blue_range = []\n    red_range = []\n\n    for i in range(n):\n        if colors[i] == \'B\':\n            blue_range.append(arr[i])\n        else:\n            red_range.append(arr[i])\n\n    blue_range.sort()\n    red_range.sort()\n\n    for i in range(len(blue_range)):\n        if blue_range[i] < i + 1:\n            return "NO"\n\n    for i in range(len(red_range)):\n        if red_range[i] > n - i:\n            return "NO"\n\n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        colors = input().strip()\n        results.append(can_form_permutation(n, arr, colors))\n    \n    for result in results:\n        print(result)', 'def can_form_permutation(n, arr, colors):\n    blue_range = []\n    red_range = []\n\n    for i in range(n):\n        if colors[i] == \'B\':\n            blue_range.append(arr[i])\n        else:\n            red_range.append(arr[i])\n\n    blue_range.sort()\n    red_range.sort()\n\n    for i in range(len(blue_range)):\n        if blue_range[i] < i + 1:\n            return "NO"\n\n    for i in range(len(red_range)):\n        if red_range[i] > n - i:\n            return "NO"\n\n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        colors = input().strip()\n        results.append(can_form_permutation(n, arr, colors))\n    \n    for result in results:\n        print(result)', 'def can_form_permutation(n, arr, colors):\n    blue_range = []\n    red_range = []\n\n    for i in range(n):\n        if colors[i] == \'B\':\n            blue_range.append(arr[i])\n        else:\n            red_range.append(arr[i])\n\n    blue_range.sort()\n    red_range.sort()\n\n    for i in range(len(blue_range)):\n        if blue_range[i] < i + 1:\n            return "NO"\n\n    for i in range(len(red_range)):\n        if red_range[i] > n - i:\n            return "NO"\n\n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        colors = input().strip()\n        results.append(can_form_permutation(n, arr, colors))\n    \n    for result in results:\n        print(result)', 'def can_form_permutation(n, arr, colors):\n    blue_range = []\n    red_range = []\n\n    for i in range(n):\n        if colors[i] == \'B\':\n            blue_range.append(arr[i])\n        else:\n            red_range.append(arr[i])\n\n    blue_range.sort()\n    red_range.sort()\n\n    for i in range(len(blue_range)):\n        if blue_range[i] < i + 1:\n            return "NO"\n\n    for i in range(len(red_range)):\n        if red_range[i] > n - i:\n            return "NO"\n\n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        colors = input().strip()\n        results.append(can_form_permutation(n, arr, colors))\n    \n    for result in results:\n        print(result)', 'def can_form_permutation(n, arr, colors):\n    blue_range = []\n    red_range = []\n\n    for i in range(n):\n        if colors[i] == \'B\':\n            blue_range.append(arr[i])\n        else:\n            red_range.append(arr[i])\n\n    blue_range.sort()\n    red_range.sort()\n\n    for i in range(len(blue_range)):\n        if blue_range[i] < i + 1:\n            return "NO"\n\n    for i in range(len(red_range)):\n        if red_range[i] > n - i:\n            return "NO"\n\n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        colors = input().strip()\n        results.append(can_form_permutation(n, arr, colors))\n    \n    for result in results:\n        print(result)', 'def can_form_permutation(n, arr, colors):\n    blue_range = []\n    red_range = []\n\n    for i in range(n):\n        if colors[i] == \'B\':\n            blue_range.append(arr[i])\n        else:\n            red_range.append(arr[i])\n\n    blue_range.sort()\n    red_range.sort()\n\n    for i in range(len(blue_range)):\n        if blue_range[i] < i + 1:\n            return "NO"\n\n    for i in range(len(red_range)):\n        if red_range[i] > n - i:\n            return "NO"\n\n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        colors = input().strip()\n        results.append(can_form_permutation(n, arr, colors))\n    \n    for result in results:\n        print(result)', 'def can_form_permutation(n, arr, colors):\n    blue_range = []\n    red_range = []\n\n    for i in range(n):\n        if colors[i] == \'B\':\n            blue_range.append(arr[i])\n        else:\n            red_range.append(arr[i])\n\n    blue_range.sort()\n    red_range.sort()\n\n    for i in range(len(blue_range)):\n        if blue_range[i] < i + 1:\n            return "NO"\n\n    for i in range(len(red_range)):\n        if red_range[i] > n - i:\n            return "NO"\n\n    return "YES"\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        colors = input().strip()\n        results.append(can_form_permutation(n, arr, colors))\n    \n    for result in results:\n        print(result)']
----------
['- name: \nSimulation with Constraints\n\n- content: \nThis solution involves simulating the process of adjusting the values of blue and red elements. We need to ensure that the values are within a valid range to form a permutation. Here\'s the plan:\n1. Initialize two variables to track the minimum and maximum values of blue elements and red elements.\n2. Iterate through the array and update the variables based on the color of each element.\n3. Check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n4. If the range is valid, output "YES"; otherwise, output "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array manipulation\': involves adjusting the values of elements based on their colors to form a permutation.\n    \'permutation\': a sequence of n distinct numbers where each number from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the value of an element needs to be adjusted beyond its current value to meet the requirement for a permutation.\n\n# [degree adverb] \n    \'largest\': refers to the element with the highest value among the blue elements, which will help determine the upper limit of the permutation.\n    \'smallest\': refers to the element with the lowest value among the red elements, which will help determine the lower limit of the permutation.\n\n# [code logic]\n    Steps 1-3 should be implemented simultaneously to initialize and update the tracking of minimum and maximum values for blue and red elements.\n    Step 4 should be implemented separately to check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n\n# [edge case] \n    Edge case 1:\n    Input: [2, 2, 2, 2], [\'B\', \'B\', \'B\', \'B\']\n    Explanation: All elements are blue and equal. No matter how many times we adjust them, they cannot form a permutation since all elements are the same.\n    Expected output: NO\n\n    Edge case 2:\n    Input: [1, 3, 2], [\'R\', \'R\', \'B\']\n    Explanation: The red elements are 1 and 3, and the blue element is 2. We can increase the red element to 3 and decrease the blue element to 2, but we cannot form a permutation since the sequence is not continuous.\n    Expected output: NO\n\n    Edge case 3:\n    Input: [1, 2, 3], [\'B\', \'B\', \'B\']\n    Explanation: All elements are blue and increasing. We can adjust the values to form a permutation [1, 2, 3].\n    Expected output: YES\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same color and equal.\n        if all(color == \'B\' for color in colors):\n            return "NO" if len(set(arr)) != len(arr) else "YES"\n        (other code)', '- name: \nMathematical Range Analysis\n\n- content: \nThe mathematical range analysis approach involves calculating the theoretical minimum and maximum values for each color after applying all possible operations. We will track the net effect of operations on the range of values for each color and check if the final range covers all numbers from 1 to n.\n\nSteps:\n1. Initialize variables to track the minimum and maximum values for blue and red elements.\n2. Iterate through the array and update the minimum and maximum values based on the current element\'s color and value.\n3. Calculate the final range of values for each color after applying all possible operations.\n4. Check if the final range of values covers all numbers from 1 to n.\n5. Return "YES" if the range covers all numbers from 1 to n; otherwise, return "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'permutation\': means that the array should contain all unique numbers from 1 to n exactly once.\n    Explanation: A permutation of numbers from 1 to n is an array where each number from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    Steps:\n    1. Initialize variables to track the minimum and maximum values for blue and red elements.\n    2. Iterate through the array and update the minimum and maximum values based on the current element\'s color and value.\n    3. Calculate the final range of values for each color after applying all possible operations.\n    4. Check if the final range of values covers all numbers from 1 to n.\n    5. Return "YES" if the range covers all numbers from 1 to n; otherwise, return "NO".\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4], [\'B\', \'B\', \'B\', \'B\']\n    Expected output: YES\n    Explanation: The array is already a permutation of numbers from 1 to 4, so no operations are needed.\n\n    Edge case 2: [1, 3, 2], [\'B\', \'B\', \'R\']\n    Expected output: NO\n    Explanation: The array is not a permutation of numbers from 1 to 3 because 2 is missing.\n\n    Edge case 3: [5, 1, 5, 1, 5], [\'R\', \'R\', \'R\', \'R\', \'R\']\n    Expected output: NO\n    Explanation: The array contains the number 5 three times, which violates the permutation rule.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to determine if the array can be transformed into a permutation.', '- name: \nSimulation with Constraints\n\n- content: \nThis solution involves simulating the process of adjusting the values of blue and red elements. We need to ensure that the values are within a valid range to form a permutation. Here\'s the plan:\n1. Initialize two variables to track the minimum and maximum values of blue elements and red elements.\n2. Iterate through the array and update the variables based on the color of each element.\n3. Check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n4. If the range is valid, output "YES"; otherwise, output "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array manipulation\': involves adjusting the values of elements based on their colors to form a permutation.\n    \'permutation\': a sequence of n distinct numbers where each number from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the value of an element needs to be adjusted beyond its current value to meet the requirement for a permutation.\n\n# [degree adverb] \n    \'largest\': refers to the element with the highest value among the blue elements, which will help determine the upper limit of the permutation.\n    \'smallest\': refers to the element with the lowest value among the red elements, which will help determine the lower limit of the permutation.\n\n# [code logic]\n    Steps 1-3 should be implemented simultaneously to initialize and update the tracking of minimum and maximum values for blue and red elements.\n    Step 4 should be implemented separately to check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n\n# [edge case] \n    Edge case 1:\n    Input: [2, 2, 2, 2], [\'B\', \'B\', \'B\', \'B\']\n    Explanation: All elements are blue and equal. No matter how many times we adjust them, they cannot form a permutation since all elements are the same.\n    Expected output: NO\n\n    Edge case 2:\n    Input: [1, 3, 2], [\'R\', \'R\', \'B\']\n    Explanation: The red elements are 1 and 3, and the blue element is 2. We can increase the red element to 3 and decrease the blue element to 2, but we cannot form a permutation since the sequence is not continuous.\n    Expected output: NO\n\n    Edge case 3:\n    Input: [1, 2, 3], [\'B\', \'B\', \'B\']\n    Explanation: All elements are blue and increasing. We can adjust the values to form a permutation [1, 2, 3].\n    Expected output: YES\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same color and equal.\n        if all(color == \'B\' for color in colors):\n            return "NO" if len(set(arr)) != len(arr) else "YES"\n        (other code)', '- name: \nSimulation with Constraints\n\n- content: \nThis solution involves simulating the process of adjusting the values of blue and red elements. We need to ensure that the values are within a valid range to form a permutation. Here\'s the plan:\n1. Initialize two variables to track the minimum and maximum values of blue elements and red elements.\n2. Iterate through the array and update the variables based on the color of each element.\n3. Check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n4. If the range is valid, output "YES"; otherwise, output "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array manipulation\': involves adjusting the values of elements based on their colors to form a permutation.\n    \'permutation\': a sequence of n distinct numbers where each number from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the value of an element needs to be adjusted beyond its current value to meet the requirement for a permutation.\n\n# [degree adverb] \n    \'largest\': refers to the element with the highest value among the blue elements, which will help determine the upper limit of the permutation.\n    \'smallest\': refers to the element with the lowest value among the red elements, which will help determine the lower limit of the permutation.\n\n# [code logic]\n    Steps 1-3 should be implemented simultaneously to initialize and update the tracking of minimum and maximum values for blue and red elements.\n    Step 4 should be implemented separately to check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n\n# [edge case] \n    Edge case 1:\n    Input: [2, 2, 2, 2], [\'B\', \'B\', \'B\', \'B\']\n    Explanation: All elements are blue and equal. No matter how many times we adjust them, they cannot form a permutation since all elements are the same.\n    Expected output: NO\n\n    Edge case 2:\n    Input: [1, 3, 2], [\'R\', \'R\', \'B\']\n    Explanation: The red elements are 1 and 3, and the blue element is 2. We can increase the red element to 3 and decrease the blue element to 2, but we cannot form a permutation since the sequence is not continuous.\n    Expected output: NO\n\n    Edge case 3:\n    Input: [1, 2, 3], [\'B\', \'B\', \'B\']\n    Explanation: All elements are blue and increasing. We can adjust the values to form a permutation [1, 2, 3].\n    Expected output: YES\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same color and equal.\n        if all(color == \'B\' for color in colors):\n            return "NO" if len(set(arr)) != len(arr) else "YES"\n        (other code)', '- name: \nSimulation with Constraints\n\n- content: \nThis solution involves simulating the process of adjusting the values of blue and red elements. We need to ensure that the values are within a valid range to form a permutation. Here\'s the plan:\n1. Initialize two variables to track the minimum and maximum values of blue elements and red elements.\n2. Iterate through the array and update the variables based on the color of each element.\n3. Check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n4. If the range is valid, output "YES"; otherwise, output "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array manipulation\': involves adjusting the values of elements based on their colors to form a permutation.\n    \'permutation\': a sequence of n distinct numbers where each number from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the value of an element needs to be adjusted beyond its current value to meet the requirement for a permutation.\n\n# [degree adverb] \n    \'largest\': refers to the element with the highest value among the blue elements, which will help determine the upper limit of the permutation.\n    \'smallest\': refers to the element with the lowest value among the red elements, which will help determine the lower limit of the permutation.\n\n# [code logic]\n    Steps 1-3 should be implemented simultaneously to initialize and update the tracking of minimum and maximum values for blue and red elements.\n    Step 4 should be implemented separately to check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n\n# [edge case] \n    Edge case 1:\n    Input: [2, 2, 2, 2], [\'B\', \'B\', \'B\', \'B\']\n    Explanation: All elements are blue and equal. No matter how many times we adjust them, they cannot form a permutation since all elements are the same.\n    Expected output: NO\n\n    Edge case 2:\n    Input: [1, 3, 2], [\'R\', \'R\', \'B\']\n    Explanation: The red elements are 1 and 3, and the blue element is 2. We can increase the red element to 3 and decrease the blue element to 2, but we cannot form a permutation since the sequence is not continuous.\n    Expected output: NO\n\n    Edge case 3:\n    Input: [1, 2, 3], [\'B\', \'B\', \'B\']\n    Explanation: All elements are blue and increasing. We can adjust the values to form a permutation [1, 2, 3].\n    Expected output: YES\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same color and equal.\n        if all(color == \'B\' for color in colors):\n            return "NO" if len(set(arr)) != len(arr) else "YES"\n        (other code)', '- name: \nSimulation with Constraints\n\n- content: \nThis solution involves simulating the process of adjusting the values of blue and red elements. We need to ensure that the values are within a valid range to form a permutation. Here\'s the plan:\n1. Initialize two variables to track the minimum and maximum values of blue elements and red elements.\n2. Iterate through the array and update the variables based on the color of each element.\n3. Check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n4. If the range is valid, output "YES"; otherwise, output "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array manipulation\': involves adjusting the values of elements based on their colors to form a permutation.\n    \'permutation\': a sequence of n distinct numbers where each number from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the value of an element needs to be adjusted beyond its current value to meet the requirement for a permutation.\n\n# [degree adverb] \n    \'largest\': refers to the element with the highest value among the blue elements, which will help determine the upper limit of the permutation.\n    \'smallest\': refers to the element with the lowest value among the red elements, which will help determine the lower limit of the permutation.\n\n# [code logic]\n    Steps 1-3 should be implemented simultaneously to initialize and update the tracking of minimum and maximum values for blue and red elements.\n    Step 4 should be implemented separately to check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n\n# [edge case] \n    Edge case 1:\n    Input: [2, 2, 2, 2], [\'B\', \'B\', \'B\', \'B\']\n    Explanation: All elements are blue and equal. No matter how many times we adjust them, they cannot form a permutation since all elements are the same.\n    Expected output: NO\n\n    Edge case 2:\n    Input: [1, 3, 2], [\'R\', \'R\', \'B\']\n    Explanation: The red elements are 1 and 3, and the blue element is 2. We can increase the red element to 3 and decrease the blue element to 2, but we cannot form a permutation since the sequence is not continuous.\n    Expected output: NO\n\n    Edge case 3:\n    Input: [1, 2, 3], [\'B\', \'B\', \'B\']\n    Explanation: All elements are blue and increasing. We can adjust the values to form a permutation [1, 2, 3].\n    Expected output: YES\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same color and equal.\n        if all(color == \'B\' for color in colors):\n            return "NO" if len(set(arr)) != len(arr) else "YES"\n        (other code)', '- name: \nSimulation with Constraints\n\n- content: \nThis solution involves simulating the process of adjusting the values of blue and red elements. We need to ensure that the values are within a valid range to form a permutation. Here\'s the plan:\n1. Initialize two variables to track the minimum and maximum values of blue elements and red elements.\n2. Iterate through the array and update the variables based on the color of each element.\n3. Check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n4. If the range is valid, output "YES"; otherwise, output "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array manipulation\': involves adjusting the values of elements based on their colors to form a permutation.\n    \'permutation\': a sequence of n distinct numbers where each number from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the value of an element needs to be adjusted beyond its current value to meet the requirement for a permutation.\n\n# [degree adverb] \n    \'largest\': refers to the element with the highest value among the blue elements, which will help determine the upper limit of the permutation.\n    \'smallest\': refers to the element with the lowest value among the red elements, which will help determine the lower limit of the permutation.\n\n# [code logic]\n    Steps 1-3 should be implemented simultaneously to initialize and update the tracking of minimum and maximum values for blue and red elements.\n    Step 4 should be implemented separately to check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n\n# [edge case] \n    Edge case 1:\n    Input: [2, 2, 2, 2], [\'B\', \'B\', \'B\', \'B\']\n    Explanation: All elements are blue and equal. No matter how many times we adjust them, they cannot form a permutation since all elements are the same.\n    Expected output: NO\n\n    Edge case 2:\n    Input: [1, 3, 2], [\'R\', \'R\', \'B\']\n    Explanation: The red elements are 1 and 3, and the blue element is 2. We can increase the red element to 3 and decrease the blue element to 2, but we cannot form a permutation since the sequence is not continuous.\n    Expected output: NO\n\n    Edge case 3:\n    Input: [1, 2, 3], [\'B\', \'B\', \'B\']\n    Explanation: All elements are blue and increasing. We can adjust the values to form a permutation [1, 2, 3].\n    Expected output: YES\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same color and equal.\n        if all(color == \'B\' for color in colors):\n            return "NO" if len(set(arr)) != len(arr) else "YES"\n        (other code)', '- name: \nSimulation with Constraints\n\n- content: \nThis solution involves simulating the process of adjusting the values of blue and red elements. We need to ensure that the values are within a valid range to form a permutation. Here\'s the plan:\n1. Initialize two variables to track the minimum and maximum values of blue elements and red elements.\n2. Iterate through the array and update the variables based on the color of each element.\n3. Check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n4. If the range is valid, output "YES"; otherwise, output "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array manipulation\': involves adjusting the values of elements based on their colors to form a permutation.\n    \'permutation\': a sequence of n distinct numbers where each number from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the value of an element needs to be adjusted beyond its current value to meet the requirement for a permutation.\n\n# [degree adverb] \n    \'largest\': refers to the element with the highest value among the blue elements, which will help determine the upper limit of the permutation.\n    \'smallest\': refers to the element with the lowest value among the red elements, which will help determine the lower limit of the permutation.\n\n# [code logic]\n    Steps 1-3 should be implemented simultaneously to initialize and update the tracking of minimum and maximum values for blue and red elements.\n    Step 4 should be implemented separately to check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n\n# [edge case] \n    Edge case 1:\n    Input: [2, 2, 2, 2], [\'B\', \'B\', \'B\', \'B\']\n    Explanation: All elements are blue and equal. No matter how many times we adjust them, they cannot form a permutation since all elements are the same.\n    Expected output: NO\n\n    Edge case 2:\n    Input: [1, 3, 2], [\'R\', \'R\', \'B\']\n    Explanation: The red elements are 1 and 3, and the blue element is 2. We can increase the red element to 3 and decrease the blue element to 2, but we cannot form a permutation since the sequence is not continuous.\n    Expected output: NO\n\n    Edge case 3:\n    Input: [1, 2, 3], [\'B\', \'B\', \'B\']\n    Explanation: All elements are blue and increasing. We can adjust the values to form a permutation [1, 2, 3].\n    Expected output: YES\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same color and equal.\n        if all(color == \'B\' for color in colors):\n            return "NO" if len(set(arr)) != len(arr) else "YES"\n        (other code)', '- name: \nSimulation with Constraints\n\n- content: \nThis solution involves simulating the process of adjusting the values of blue and red elements. We need to ensure that the values are within a valid range to form a permutation. Here\'s the plan:\n1. Initialize two variables to track the minimum and maximum values of blue elements and red elements.\n2. Iterate through the array and update the variables based on the color of each element.\n3. Check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n4. If the range is valid, output "YES"; otherwise, output "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array manipulation\': involves adjusting the values of elements based on their colors to form a permutation.\n    \'permutation\': a sequence of n distinct numbers where each number from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the value of an element needs to be adjusted beyond its current value to meet the requirement for a permutation.\n\n# [degree adverb] \n    \'largest\': refers to the element with the highest value among the blue elements, which will help determine the upper limit of the permutation.\n    \'smallest\': refers to the element with the lowest value among the red elements, which will help determine the lower limit of the permutation.\n\n# [code logic]\n    Steps 1-3 should be implemented simultaneously to initialize and update the tracking of minimum and maximum values for blue and red elements.\n    Step 4 should be implemented separately to check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n\n# [edge case] \n    Edge case 1:\n    Input: [2, 2, 2, 2], [\'B\', \'B\', \'B\', \'B\']\n    Explanation: All elements are blue and equal. No matter how many times we adjust them, they cannot form a permutation since all elements are the same.\n    Expected output: NO\n\n    Edge case 2:\n    Input: [1, 3, 2], [\'R\', \'R\', \'B\']\n    Explanation: The red elements are 1 and 3, and the blue element is 2. We can increase the red element to 3 and decrease the blue element to 2, but we cannot form a permutation since the sequence is not continuous.\n    Expected output: NO\n\n    Edge case 3:\n    Input: [1, 2, 3], [\'B\', \'B\', \'B\']\n    Explanation: All elements are blue and increasing. We can adjust the values to form a permutation [1, 2, 3].\n    Expected output: YES\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same color and equal.\n        if all(color == \'B\' for color in colors):\n            return "NO" if len(set(arr)) != len(arr) else "YES"\n        (other code)', '- name: \nSimulation with Constraints\n\n- content: \nThis solution involves simulating the process of adjusting the values of blue and red elements. We need to ensure that the values are within a valid range to form a permutation. Here\'s the plan:\n1. Initialize two variables to track the minimum and maximum values of blue elements and red elements.\n2. Iterate through the array and update the variables based on the color of each element.\n3. Check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n4. If the range is valid, output "YES"; otherwise, output "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'array manipulation\': involves adjusting the values of elements based on their colors to form a permutation.\n    \'permutation\': a sequence of n distinct numbers where each number from 1 to n appears exactly once.\n\n# [phrase showing quantity relationship]\n    \'more than\': indicates that the value of an element needs to be adjusted beyond its current value to meet the requirement for a permutation.\n\n# [degree adverb] \n    \'largest\': refers to the element with the highest value among the blue elements, which will help determine the upper limit of the permutation.\n    \'smallest\': refers to the element with the lowest value among the red elements, which will help determine the lower limit of the permutation.\n\n# [code logic]\n    Steps 1-3 should be implemented simultaneously to initialize and update the tracking of minimum and maximum values for blue and red elements.\n    Step 4 should be implemented separately to check if the range between the minimum and maximum values can be adjusted to form a sequence from 1 to n.\n\n# [edge case] \n    Edge case 1:\n    Input: [2, 2, 2, 2], [\'B\', \'B\', \'B\', \'B\']\n    Explanation: All elements are blue and equal. No matter how many times we adjust them, they cannot form a permutation since all elements are the same.\n    Expected output: NO\n\n    Edge case 2:\n    Input: [1, 3, 2], [\'R\', \'R\', \'B\']\n    Explanation: The red elements are 1 and 3, and the blue element is 2. We can increase the red element to 3 and decrease the blue element to 2, but we cannot form a permutation since the sequence is not continuous.\n    Expected output: NO\n\n    Edge case 3:\n    Input: [1, 2, 3], [\'B\', \'B\', \'B\']\n    Explanation: All elements are blue and increasing. We can adjust the values to form a permutation [1, 2, 3].\n    Expected output: YES\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where all elements are the same color and equal.\n        if all(color == \'B\' for color in colors):\n            return "NO" if len(set(arr)) != len(arr) else "YES"\n        (other code)']
----------
False
----------
0
multi-gen-prompt:
 Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 

  * 1 ≤ a_i ≤ 10^9 for every i from 1 to n.

  * a_1 < a_2 < … <a_n

  * For every i from 2 to n, a_i isn't divisible by a_{i-1}

It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ≤ n ≤ 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, …, a_n — the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.
multi-gen-prompt:
 Given n, find any array a_1, a_2, …, a_n of integers such that all of the following conditions hold: 1 ≤ a_i ≤ 10^9 for every i from 1 to n, a_1 < a_2 < … < a_n, and for every i from 2 to n, a_i isn't divisible by a_{i-1}. It can be shown that such an array always exists under the constraints of the problem.

Input

The first line contains the number of test cases t (1 ≤ t ≤ 100). Description of the test cases follows.

The only line of each test case contains a single integer n (1 ≤ n ≤ 1000).

It is guaranteed that the sum of n over all test cases does not exceed 10^4.

Output

For each test case print n integers a_1, a_2, …, a_n — the array you found. If there are multiple arrays satisfying all the conditions, print any of them.

Example

Input


3
1
2
7


Output


1
2 3
111 1111 11111 111111 1111111 11111111 111111111

Note

In the first test case, array [1] satisfies all the conditions.

In the second test case, array [2, 3] satisfies all the conditions, as 2<3 and 3 is not divisible by 2.

In the third test case, array [111, 1111, 11111, 111111, 1111111, 11111111, 111111111] satisfies all the conditions, as it's increasing and a_i isn't divisible by a_{i-1} for any i from 2 to 7.
generating with deepseek-coder
----------
['def generate_array(n):\n    result = []\n    current = 1\n    while len(result) < n:\n        result.append(current)\n        current *= 10\n    return result[:n]\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        array = generate_array(n)\n        print(\' \'.join(map(str, array)))\n\nif __name__ == "__main__":\n    main()', 'import math\n\ndef is_prime(num, sequence):\n    for x in sequence:\n        if x * x > num:\n            break\n        if num % x == 0:\n            return False\n    return True\n\ndef generate_sequence(n):\n    sequence = [2]\n    current = 3\n    while len(sequence) < n:\n        if is_prime(current, sequence):\n            sequence.append(current)\n        current += 1\n    return sequence\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        results.append(generate_sequence(n))\n    \n    for result in results:\n        print(" ".join(map(str, result)))\n\nif __name__ == "__main__":\n    main()', 'def generate_sequence(n):\n    a = [1] * n\n    for i in range(1, n):\n        a[i] = a[i - 1] + 1\n    return a\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        results.append(generate_sequence(n))\n    \n    for result in results:\n        print(" ".join(map(str, result)))', 'def generate_sequence(n):\n    if n == 1:\n        return [1]\n    elif n == 2:\n        return [2, 3]\n    else:\n        sequence = [111, 1111, 11111, 111111, 1111111, 11111111, 111111111]\n        while len(sequence) < n:\n            last_num = sequence[-1]\n            next_num = last_num + 1\n            while any(next_num % x == 0 for x in sequence):\n                next_num += 1\n            sequence.append(next_num)\n        return sequence[:n]\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        results.append(generate_sequence(n))\n    \n    for result in results:\n        print(" ".join(map(str, result)))', 'def generate_sequence(n):\n    seq = [1]\n    current = 2\n    while len(seq) < n:\n        if all(current % x != 0 for x in seq):\n            seq.append(current)\n        current += 1\n    return seq\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        seq = generate_sequence(n)\n        print(" ".join(map(str, seq)))\n\nif __name__ == "__main__":\n    main()', 'def generate_sequence(n):\n    if n == 1:\n        return [1]\n    elif n == 2:\n        return [2, 3]\n    else:\n        sequence = [111, 1111, 11111, 111111, 1111111, 11111111, 111111111]\n        while len(sequence) < n:\n            last_num = sequence[-1]\n            next_num = last_num + 1\n            while any(next_num % x == 0 for x in sequence):\n                next_num += 1\n            sequence.append(next_num)\n        return sequence[:n]\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        results.append(generate_sequence(n))\n    \n    for result in results:\n        print(" ".join(map(str, result)))', 'def generate_sequence(n):\n    seq = [1]\n    current = 2\n    while len(seq) < n:\n        if all(current % x != 0 for x in seq):\n            seq.append(current)\n        current += 1\n    return seq\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        seq = generate_sequence(n)\n        print(" ".join(map(str, seq)))\n\nif __name__ == "__main__":\n    main()', 'def generate_sequence(n):\n    if n == 1:\n        return [1]\n    elif n == 2:\n        return [2, 3]\n    else:\n        sequence = [111, 1111, 11111, 111111, 1111111, 11111111, 111111111]\n        while len(sequence) < n:\n            last_num = sequence[-1]\n            next_num = last_num + 1\n            while any(next_num % x == 0 for x in sequence):\n                next_num += 1\n            sequence.append(next_num)\n        return sequence[:n]\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        results.append(generate_sequence(n))\n    \n    for result in results:\n        print(" ".join(map(str, result)))', 'def generate_sequence(n):\n    seq = [1]\n    current = 2\n    while len(seq) < n:\n        if all(current % x != 0 for x in seq):\n            seq.append(current)\n        current += 1\n    return seq\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        seq = generate_sequence(n)\n        print(" ".join(map(str, seq)))\n\nif __name__ == "__main__":\n    main()', 'def generate_sequence(n):\n    seq = [1]\n    current = 2\n    while len(seq) < n:\n        if all(current % x != 0 for x in seq):\n            seq.append(current)\n        current += 1\n    return seq\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        seq = generate_sequence(n)\n        print(" ".join(map(str, seq)))\n\nif __name__ == "__main__":\n    main()']
----------
["- name: \nGreedy Algorithm with Power of 10 Selection\n\n- content: \nUse a greedy algorithm to select numbers close to powers of 10 to avoid divisibility issues easily. Start with the smallest powers of 10 and ensure they do not divide each other.\n\nSolution Approach:\n1. For each test case, initialize an empty list.\n2. Start with the smallest power of 10 (e.g., 1) and add it to the list.\n3. For each subsequent position, find the next power of 10 greater than the last added number and add it to the list.\n4. Ensure each new number is not divisible by the previous number.\n5. Repeat until the list contains n numbers.\n\nThis approach ensures that the sequence is strictly increasing and that no number is divisible by its predecessor, using powers of 10 to simplify the generation process for larger values of n.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Algorithm': This is a problem-solving technique where you make the locally optimal choice at each step, with the hope of finding a global optimum. In this case, the algorithm uses powers of 10 to generate a sequence that avoids divisibility issues.\n\n    Explanation: The core concept here is to use a sequence of numbers that are powers of 10, ensuring that each number is not divisible by the previous one in the sequence. This is a practical approach to generate a valid sequence under given constraints.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    n = 1\n    Output: [1]\n    Explanation: For the smallest value of n, the sequence contains only the number 1, which trivially satisfies all conditions.\n\n    n = 2\n    Output: [2, 3]\n    Explanation: Starting with 2, the next power of 10 (which is 3) is added, ensuring the sequence is strictly increasing and no number is divisible by its predecessor.\n\n    n = 7\n    Output: [111, 1111, 11111, 111111, 1111111, 11111111, 111111111]\n    Explanation: The sequence uses powers of 10 to ensure that each number is not divisible by the previous one, maintaining the increasing order and avoiding divisibility issues.\n\n# [extra code for edge case]\n    No extra code is needed for handling edge cases, as the algorithm described in the plan works correctly for all values of n within the given constraints.", "- name: \nMathematical Pattern Generation\n\n- content: \n- Use a mathematical pattern to generate the array.\n- For small n, use simple patterns like consecutive numbers or powers of 2.\n- For larger n, use more complex patterns such as Fibonacci-like sequences where each number is a multiple of the previous one plus another small number (e.g., 1, 2, 3, 5, 8, ...).\n- This method leverages mathematical properties to generate valid arrays efficiently.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'array': a collection of elements, each identified by an index or key.\n    Explanation: In this requirement, we are dealing with an array of integers that must satisfy specific conditions. The conditions include each integer being between 1 and 10^9, the array being strictly increasing, and no element being divisible by the previous one.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value.\n    Explanation: In the requirement, we need to ensure that each integer in the array is more than the previous one, which implies a relationship where each new integer must be greater than the one before it.\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value.\n    Explanation: The requirement does not explicitly use 'largest' as a degree adverb, but the need to find the biggest integer that meets the conditions implies a search for the maximum value that satisfies the given constraints.\n\n# [code logic]\n    The steps should be implement sequentially.\n    Explanation: To generate an array that satisfies all conditions, we need to ensure that each integer is greater than the previous one and not divisible by it. This requires a systematic approach where each new integer is determined based on the previous one.\n\n# [edge case] \n    n = 1\n    expected output = 1\n    Explanation: When n is 1, the array must contain only one element. The only integer that satisfies all conditions is 1.\n\n    n = 2\n    expected output = 2, 3\n    Explanation: For n = 2, we need two integers where the first is less than the second and the second is not divisible by the first. The array [2, 3] meets these conditions.\n\n    n = 7\n    expected output = 111, 1111, 11111, 111111, 1111111, 11111111, 111111111\n    Explanation: For n = 7, we need an array of increasing integers where each is not divisible by the previous one. The array provided meets these conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The pattern generation logic inherently covers the smallest possible values of n.\n\n# [core concept]\n    'array': a collection of elements, each identified by an index or key.\n    Explanation: In this requirement, we are dealing with an array of integers that must satisfy specific conditions. The conditions include each integer being between 1 and 10^9, the array being strictly increasing, and no element being divisible by the previous one.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers greater than a certain value.\n    Explanation: In the requirement, we need to ensure that each integer in the array is more than the previous one, which implies a relationship where each new integer must be greater than the one before it.\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value.\n    Explanation: The requirement does not explicitly use 'largest' as a degree adverb, but the need to find the biggest integer that meets the conditions implies a search for the maximum value that satisfies the given constraints.\n\n# [code logic]\n    The steps should be implement sequentially.\n    Explanation: To generate an array that satisfies all conditions, we need to ensure that each integer is greater than the previous one and not divisible by it. This requires a systematic approach where each new integer is determined based on the previous one.\n\n# [edge case] \n    n = 1\n    expected output = 1\n    Explanation: When n is 1, the array must contain only one element. The only integer that satisfies all conditions is 1.\n\n    n = 2\n    expected output = 2, 3\n    Explanation: For n = 2, we need two integers where the first is less than the second and the second is not divisible by the first. The array [2, 3] meets these conditions.\n\n    n = 7\n    expected output = 111, 1111, 11111, 111111, 1111111, 11111111, 111111111\n    Explanation: For n = 7, we need an array of increasing integers where each is not divisible by the previous one. The array provided meets these conditions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The pattern generation logic inherently covers the smallest possible values of n.", "- name: \nGreedy Selection with Constraints\n\n- content: \nStart with the first element as 1. For each subsequent element, select the smallest number greater than the previous element that is not divisible by it. This greedy approach ensures the array is strictly increasing and no element is divisible by its predecessor. Repeatedly apply this strategy until the array length reaches n.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'strictly increasing array': means that each element in the array is greater than the previous one.\n    'not divisible by its predecessor': means that for any i from 2 to n, a_i % a_{i-1} != 0.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Start with the first element as 1.\n    - For each subsequent element, find the smallest number greater than the previous element that is not divisible by it.\n    - Repeat this process until the array length reaches n.\n\n# [edge case] \n    n = 1\n    expected output: [1]\n    Explanation: Since there's only one element, the array must be [1] to satisfy the condition that 1 ≤ a_i ≤ 10^9.\n\n    n = 2\n    expected output: [2, 3]\n    Explanation: The array [2, 3] satisfies all conditions: 2 < 3 and 3 is not divisible by 2.\n\n    n = 7\n    expected output: [111, 1111, 11111, 111111, 1111111, 11111111, 111111111]\n    Explanation: The array is strictly increasing and no element is divisible by its predecessor.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The greedy approach ensures that the array is always strictly increasing and no element is divisible by its predecessor.", "- name: \nGreedy Algorithm\n\n- content: \nImplement a greedy algorithm that builds the sequence from the smallest possible number upwards, ensuring each new number is not divisible by the last number added. This approach is efficient and straightforward for smaller values of n.\n\nExample for n = 5:\n- Start with 2, then add 3 (since it's not divisible by 2).\n- Add 4 (not divisible by 3), then 5 (not divisible by 4), and so on.\nThis method ensures the sequence is strictly increasing and meets the divisibility condition.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Algorithm': This is a method of solving optimization problems where the goal is to make the locally optimal choice at each step with the hope of finding a global optimum. In this case, the algorithm builds the sequence from the smallest possible number upwards, ensuring each new number is not divisible by the last number added.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously as the greedy approach is designed to make the locally optimal choice at each step. The algorithm starts with the smallest number and adds the next number that is not divisible by the last number added, ensuring the sequence remains strictly increasing and meets the divisibility condition.\n\n# [edge case] \n    For n = 1, the expected output is [1]\n    Explanation: Since there's only one number, the array is simply [1].\n\n    For n = 2, the expected output is [2, 3]\n    Explanation: Starting with 2, the next number 3 is not divisible by 2, so the sequence is [2, 3].\n\n    For n = 7, the expected output is [111, 1111, 11111, 111111, 1111111, 11111111, 111111111]\n    Explanation: The sequence starts with 111 (the smallest number not divisible by 1), followed by 1111, 11111, and so on, ensuring each number is not divisible by the previous one.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the greedy algorithm inherently works for any valid input within the given constraints. The algorithm will always find a valid sequence for any n within the range [1, 1000].", '- name: \nGreedy Approach with Incremental Numbers\n\n- content: \nAnother approach is to use a greedy strategy to generate numbers that are not divisible by the previous one. Start with the smallest possible number and keep adding new numbers until the sequence reaches the desired length. This ensures that the sequence is strictly increasing and each number is not divisible by the previous one.\n\n```python\ndef generate_sequence(n):\n    seq = [1]\n    current = 2\n    while len(seq) < n:\n        if all(current % x != 0 for x in seq):\n            seq.append(current)\n        current += 1\n    return seq\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        seq = generate_sequence(n)\n        print(" ".join(map(str, seq)))\n\nif __name__ == "__main__":\n    main()\n```\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'strictly increasing sequence\'\n    The requirement is to create a sequence of integers where each number is greater than the previous one and no number is divisible by the one before it.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a greedy approach to generate the sequence. Start with the smallest possible number (1) and keep adding new numbers until the sequence reaches the desired length. This ensures that the sequence is strictly increasing and each number is not divisible by the previous one.\n\n# [edge case] \n    n = 1\n    expected output: 1\n    Explanation: For the smallest possible value of n, the sequence can only contain the number 1.\n\n    n = 2\n    expected output: 2 3\n    Explanation: Starting with 2, the next number that is not divisible by 2 is 3. Thus, the sequence is [2, 3].\n\n    n = 7\n    expected output: 111 1111 11111 111111 1111111 11111111 111111111\n    Explanation: The sequence is generated by starting with 111 and incrementing to find the next number that is not divisible by the previous one until the sequence reaches length 7.\n\n# [extra code for edge case]\n    No extra code is needed for the edge cases as the provided code already handles them by starting with 1 and incrementally finding the next suitable number.', "- name: \nGreedy Algorithm\n\n- content: \nImplement a greedy algorithm that builds the sequence from the smallest possible number upwards, ensuring each new number is not divisible by the last number added. This approach is efficient and straightforward for smaller values of n.\n\nExample for n = 5:\n- Start with 2, then add 3 (since it's not divisible by 2).\n- Add 4 (not divisible by 3), then 5 (not divisible by 4), and so on.\nThis method ensures the sequence is strictly increasing and meets the divisibility condition.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Algorithm': This is a method of solving optimization problems where the goal is to make the locally optimal choice at each step with the hope of finding a global optimum. In this case, the algorithm builds the sequence from the smallest possible number upwards, ensuring each new number is not divisible by the last number added.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously as the greedy approach is designed to make the locally optimal choice at each step. The algorithm starts with the smallest number and adds the next number that is not divisible by the last number added, ensuring the sequence remains strictly increasing and meets the divisibility condition.\n\n# [edge case] \n    For n = 1, the expected output is [1]\n    Explanation: Since there's only one number, the array is simply [1].\n\n    For n = 2, the expected output is [2, 3]\n    Explanation: Starting with 2, the next number 3 is not divisible by 2, so the sequence is [2, 3].\n\n    For n = 7, the expected output is [111, 1111, 11111, 111111, 1111111, 11111111, 111111111]\n    Explanation: The sequence starts with 111 (the smallest number not divisible by 1), followed by 1111, 11111, and so on, ensuring each number is not divisible by the previous one.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the greedy algorithm inherently works for any valid input within the given constraints. The algorithm will always find a valid sequence for any n within the range [1, 1000].", '- name: \nGreedy Approach with Incremental Numbers\n\n- content: \nAnother approach is to use a greedy strategy to generate numbers that are not divisible by the previous one. Start with the smallest possible number and keep adding new numbers until the sequence reaches the desired length. This ensures that the sequence is strictly increasing and each number is not divisible by the previous one.\n\n```python\ndef generate_sequence(n):\n    seq = [1]\n    current = 2\n    while len(seq) < n:\n        if all(current % x != 0 for x in seq):\n            seq.append(current)\n        current += 1\n    return seq\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        seq = generate_sequence(n)\n        print(" ".join(map(str, seq)))\n\nif __name__ == "__main__":\n    main()\n```\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'strictly increasing sequence\'\n    The requirement is to create a sequence of integers where each number is greater than the previous one and no number is divisible by the one before it.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a greedy approach to generate the sequence. Start with the smallest possible number (1) and keep adding new numbers until the sequence reaches the desired length. This ensures that the sequence is strictly increasing and each number is not divisible by the previous one.\n\n# [edge case] \n    n = 1\n    expected output: 1\n    Explanation: For the smallest possible value of n, the sequence can only contain the number 1.\n\n    n = 2\n    expected output: 2 3\n    Explanation: Starting with 2, the next number that is not divisible by 2 is 3. Thus, the sequence is [2, 3].\n\n    n = 7\n    expected output: 111 1111 11111 111111 1111111 11111111 111111111\n    Explanation: The sequence is generated by starting with 111 and incrementing to find the next number that is not divisible by the previous one until the sequence reaches length 7.\n\n# [extra code for edge case]\n    No extra code is needed for the edge cases as the provided code already handles them by starting with 1 and incrementally finding the next suitable number.', "- name: \nGreedy Algorithm\n\n- content: \nImplement a greedy algorithm that builds the sequence from the smallest possible number upwards, ensuring each new number is not divisible by the last number added. This approach is efficient and straightforward for smaller values of n.\n\nExample for n = 5:\n- Start with 2, then add 3 (since it's not divisible by 2).\n- Add 4 (not divisible by 3), then 5 (not divisible by 4), and so on.\nThis method ensures the sequence is strictly increasing and meets the divisibility condition.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Greedy Algorithm': This is a method of solving optimization problems where the goal is to make the locally optimal choice at each step with the hope of finding a global optimum. In this case, the algorithm builds the sequence from the smallest possible number upwards, ensuring each new number is not divisible by the last number added.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously as the greedy approach is designed to make the locally optimal choice at each step. The algorithm starts with the smallest number and adds the next number that is not divisible by the last number added, ensuring the sequence remains strictly increasing and meets the divisibility condition.\n\n# [edge case] \n    For n = 1, the expected output is [1]\n    Explanation: Since there's only one number, the array is simply [1].\n\n    For n = 2, the expected output is [2, 3]\n    Explanation: Starting with 2, the next number 3 is not divisible by 2, so the sequence is [2, 3].\n\n    For n = 7, the expected output is [111, 1111, 11111, 111111, 1111111, 11111111, 111111111]\n    Explanation: The sequence starts with 111 (the smallest number not divisible by 1), followed by 1111, 11111, and so on, ensuring each number is not divisible by the previous one.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the greedy algorithm inherently works for any valid input within the given constraints. The algorithm will always find a valid sequence for any n within the range [1, 1000].", '- name: \nGreedy Approach with Incremental Numbers\n\n- content: \nAnother approach is to use a greedy strategy to generate numbers that are not divisible by the previous one. Start with the smallest possible number and keep adding new numbers until the sequence reaches the desired length. This ensures that the sequence is strictly increasing and each number is not divisible by the previous one.\n\n```python\ndef generate_sequence(n):\n    seq = [1]\n    current = 2\n    while len(seq) < n:\n        if all(current % x != 0 for x in seq):\n            seq.append(current)\n        current += 1\n    return seq\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        seq = generate_sequence(n)\n        print(" ".join(map(str, seq)))\n\nif __name__ == "__main__":\n    main()\n```\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'strictly increasing sequence\'\n    The requirement is to create a sequence of integers where each number is greater than the previous one and no number is divisible by the one before it.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a greedy approach to generate the sequence. Start with the smallest possible number (1) and keep adding new numbers until the sequence reaches the desired length. This ensures that the sequence is strictly increasing and each number is not divisible by the previous one.\n\n# [edge case] \n    n = 1\n    expected output: 1\n    Explanation: For the smallest possible value of n, the sequence can only contain the number 1.\n\n    n = 2\n    expected output: 2 3\n    Explanation: Starting with 2, the next number that is not divisible by 2 is 3. Thus, the sequence is [2, 3].\n\n    n = 7\n    expected output: 111 1111 11111 111111 1111111 11111111 111111111\n    Explanation: The sequence is generated by starting with 111 and incrementing to find the next number that is not divisible by the previous one until the sequence reaches length 7.\n\n# [extra code for edge case]\n    No extra code is needed for the edge cases as the provided code already handles them by starting with 1 and incrementally finding the next suitable number.', '- name: \nGreedy Approach with Incremental Numbers\n\n- content: \nAnother approach is to use a greedy strategy to generate numbers that are not divisible by the previous one. Start with the smallest possible number and keep adding new numbers until the sequence reaches the desired length. This ensures that the sequence is strictly increasing and each number is not divisible by the previous one.\n\n```python\ndef generate_sequence(n):\n    seq = [1]\n    current = 2\n    while len(seq) < n:\n        if all(current % x != 0 for x in seq):\n            seq.append(current)\n        current += 1\n    return seq\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        seq = generate_sequence(n)\n        print(" ".join(map(str, seq)))\n\nif __name__ == "__main__":\n    main()\n```\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'strictly increasing sequence\'\n    The requirement is to create a sequence of integers where each number is greater than the previous one and no number is divisible by the one before it.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a greedy approach to generate the sequence. Start with the smallest possible number (1) and keep adding new numbers until the sequence reaches the desired length. This ensures that the sequence is strictly increasing and each number is not divisible by the previous one.\n\n# [edge case] \n    n = 1\n    expected output: 1\n    Explanation: For the smallest possible value of n, the sequence can only contain the number 1.\n\n    n = 2\n    expected output: 2 3\n    Explanation: Starting with 2, the next number that is not divisible by 2 is 3. Thus, the sequence is [2, 3].\n\n    n = 7\n    expected output: 111 1111 11111 111111 1111111 11111111 111111111\n    Explanation: The sequence is generated by starting with 111 and incrementing to find the next number that is not divisible by the previous one until the sequence reaches length 7.\n\n# [extra code for edge case]\n    No extra code is needed for the edge cases as the provided code already handles them by starting with 1 and incrementally finding the next suitable number.']
----------
False
----------
0
multi-gen-prompt:
 Monocarp wrote down two numbers on a whiteboard, both of which follow a specific format: a positive integer x with p zeros appended to its end. Now Monocarp asks you to compare these two numbers. Can you help him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
multi-gen-prompt:
 Monocarp wrote two numbers on a whiteboard, each a positive integer x with p zeros appended to its end. He then asked to compare these two numbers. Can you assist him?

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The first line of each testcase contains two integers x_1 and p_1 (1 ≤ x_1 ≤ 10^6; 0 ≤ p_1 ≤ 10^6) — the description of the first number.

The second line of each testcase contains two integers x_2 and p_2 (1 ≤ x_2 ≤ 10^6; 0 ≤ p_2 ≤ 10^6) — the description of the second number.

Output

For each testcase print the result of the comparison of the given two numbers. If the first number is smaller than the second one, print '<'. If the first number is greater than the second one, print '>'. If they are equal, print '='.

Example

Input


5
2 1
19 0
10 2
100 1
1999 0
2 3
1 0
1 0
99 0
1 2


Output


&gt;
=
&lt;
=
&lt;

Note

The comparisons in the example are: 20 > 19, 1000 = 1000, 1999 < 2000, 1 = 1, 99 < 100.
generating with deepseek-coder
----------
['def compare_numbers(x1, p1, x2, p2):\n    # Determine the number of digits in x1 and x2\n    digits_x1 = len(str(x1))\n    digits_x2 = len(str(x2))\n    \n    # Normalize the number of zeros to append\n    min_p = min(p1, p2)\n    p1 -= min_p\n    p2 -= min_p\n    \n    # Append zeros to both numbers\n    num1 = x1 * (10 ** p1)\n    num2 = x2 * (10 ** p2)\n    \n    # Compare the numbers directly\n    if num1 < num2:\n        return \'<\'\n    elif num1 > num2:\n        return \'>\'\n    else:\n        # If they are equal, compare the lengths of their decimal representations\n        if digits_x1 + p1 < digits_x2 + p2:\n            return \'<\'\n        elif digits_x1 + p1 > digits_x2 + p2:\n            return \'>\'\n        else:\n            return \'=\'\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x1 = int(data[index])\n        p1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        p2 = int(data[index + 3])\n        index += 4\n        results.append(compare_numbers(x1, p1, x2, p2))\n    \n    for result in results:\n        print(result)', 'def compare_numbers(x1, p1, x2, p2):\n    # Normalize the numbers by removing trailing zeros\n    while x1 % 10 == 0 and x1 > 1:\n        x1 //= 10\n        p1 += 1\n    while x2 % 10 == 0 and x2 > 1:\n        x2 //= 10\n        p2 += 1\n    \n    # Compare the number of digits after normalization\n    if p1 < p2:\n        return \'<\'\n    elif p1 > p2:\n        return \'>\'\n    else:\n        # If the number of trailing zeros is the same, compare the numerical values\n        if x1 < x2:\n            return \'<\'\n        elif x1 > x2:\n            return \'>\'\n        else:\n            return \'=\'\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x1 = int(data[index])\n        p1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        p2 = int(data[index + 3])\n        index += 4\n        results.append(compare_numbers(x1, p1, x2, p2))\n    \n    for result in results:\n        print(result)', 'def f1(x1, p1, x2, p2):\n    # Compare the number of digits by counting the digits in the number before appending zeros\n    digits_x1 = len(str(x1))\n    digits_x2 = len(str(x2))\n    \n    # Adjust the number of zeros to compare based on the smaller count\n    min_p = min(p1, p2)\n    p1 -= min_p\n    p2 -= min_p\n    \n    # If the counts of digits are different, compare them to determine the larger number\n    if p1 != p2:\n        return \'>\' if p1 > p2 else \'<\'\n    \n    # If the counts of digits are the same, compare the numbers directly\n    if digits_x1 != digits_x2:\n        return \'>\' if digits_x1 > digits_x2 else \'<\'\n    \n    # If both numbers have the same number of digits and zeros, compare them directly\n    if x1 == x2:\n        return \'=\'\n    elif digits_x1 > digits_x2:\n        return \'>\'\n    else:\n        return \'<\'\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x1 = int(data[index])\n        p1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        p2 = int(data[index + 3])\n        index += 4\n        results.append(f1(x1, p1, x2, p2))\n    \n    for result in results:\n        print(result)', 'def compare_numbers(x1, p1, x2, p2):\n    # Adjust the numbers by removing trailing zeros\n    while x1 % 10 == 0 and x1 > 0:\n        x1 //= 10\n        p1 += 1\n    while x2 % 10 == 0 and x2 > 0:\n        x2 //= 10\n        p2 += 1\n    \n    # Compare the number of trailing zeros\n    if p1 < p2:\n        return \'<\'\n    elif p1 > p2:\n        return \'>\'\n    else:\n        # If the number of trailing zeros is the same, compare the numbers directly\n        if x1 < x2:\n            return \'<\'\n        elif x1 > x2:\n            return \'>\'\n        else:\n            return \'=\'\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x1 = int(data[index])\n        p1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        p2 = int(data[index + 3])\n        index += 4\n        results.append(compare_numbers(x1, p1, x2, p2))\n    \n    for result in results:\n        print(result)', 'def compare_numbers(x1, p1, x2, p2):\n    # Count the number of trailing zeros in both numbers\n    zeros1 = 0\n    zeros2 = 0\n    \n    while x1 % 10 == 0 and x1 > 0:\n        x1 //= 10\n        zeros1 += 1\n    \n    while x2 % 10 == 0 and x2 > 0:\n        x2 //= 10\n        zeros2 += 1\n    \n    # Compare the number of trailing zeros\n    if zeros1 != zeros2:\n        return \'<\' if zeros1 < zeros2 else \'>\'\n    \n    # If the number of trailing zeros is the same, compare the numbers without trailing zeros\n    while p1 > 0 and x1 < 10**9:\n        x1 *= 10\n        p1 -= 1\n    \n    while p2 > 0 and x2 < 10**9:\n        x2 *= 10\n        p2 -= 1\n    \n    if x1 != x2:\n        return \'<\' if x1 < x2 else \'>\'\n    \n    # If both numbers are equal after removing trailing zeros, they are also equal\n    return \'=\'\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        x1 = int(data[index])\n        p1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        p2 = int(data[index + 3])\n        index += 4\n        \n        result = compare_numbers(x1, p1, x2, p2)\n        print(result)', 'import math\n\ndef compare_numbers(x1, p1, x2, p2):\n    # Calculate the number of digits in x1 and x2\n    digits1 = int(math.log10(x1)) if x1 > 0 else 0\n    digits2 = int(math.log10(x2)) if x2 > 0 else 0\n    \n    # Compare the number of digits\n    if digits1 + p1 < digits2 + p2:\n        return \'<\'\n    elif digits1 + p1 > digits2 + p2:\n        return \'>\'\n    else:\n        # If the number of digits is the same, compare the original numbers\n        if x1 * (10 ** p1) < x2 * (10 ** p2):\n            return \'<\'\n        elif x1 * (10 ** p1) > x2 * (10 ** p2):\n            return \'>\'\n        else:\n            return \'=\'\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x1 = int(data[index])\n        p1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        p2 = int(data[index + 3])\n        index += 4\n        results.append(compare_numbers(x1, p1, x2, p2))\n    \n    for result in results:\n        print(result)', 'def f1(x1, p1, x2, p2):\n    # Determine the number of digits in x1 and x2 after appending zeros\n    digits_x1 = len(str(x1)) + p1\n    digits_x2 = len(str(x2)) + p2\n    \n    # Compare the number of digits\n    if digits_x1 < digits_x2:\n        return \'<\'\n    elif digits_x1 > digits_x2:\n        return \'>\'\n    else:\n        # If the number of digits is the same, compare the numbers without zeros\n        while p1 > 0 and p2 > 0:\n            x1 *= 10\n            x2 *= 10\n            p1 -= 1\n            p2 -= 1\n        \n        # Remove trailing zeros from the numbers themselves\n        while p1 > 0:\n            x1 *= 10\n            p1 -= 1\n        while p2 > 0:\n            x2 *= 10\n            p2 -= 1\n        \n        if x1 < x2:\n            return \'<\'\n        elif x1 > x2:\n            return \'>\'\n        else:\n            return \'=\'\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x1 = int(data[index])\n        p1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        p2 = int(data[index + 3])\n        index += 4\n        results.append(f1(x1, p1, x2, p2))\n    \n    for result in results:\n        print(result)', 'def f1(x1, p1, x2, p2):\n    # Compare the number of digits by counting the digits in the number before appending zeros\n    digits_x1 = len(str(x1))\n    digits_x2 = len(str(x2))\n    \n    # Adjust the number of zeros to compare based on the smaller count\n    min_p = min(p1, p2)\n    p1 -= min_p\n    p2 -= min_p\n    \n    # If the counts of digits are different, compare them to determine the larger number\n    if p1 != p2:\n        return \'>\' if p1 > p2 else \'<\'\n    \n    # If the counts of digits are the same, compare the numbers directly\n    if digits_x1 != digits_x2:\n        return \'>\' if digits_x1 > digits_x2 else \'<\'\n    \n    # If both numbers have the same number of digits and zeros, compare them directly\n    if x1 == x2:\n        return \'=\'\n    elif digits_x1 > digits_x2:\n        return \'>\'\n    else:\n        return \'<\'\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x1 = int(data[index])\n        p1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        p2 = int(data[index + 3])\n        index += 4\n        results.append(f1(x1, p1, x2, p2))\n    \n    for result in results:\n        print(result)', 'def compare_numbers(x1, p1, x2, p2):\n    # Normalize the numbers by removing trailing zeros\n    while x1 % 10 == 0 and x1 > 1:\n        x1 //= 10\n        p1 += 1\n    while x2 % 10 == 0 and x2 > 1:\n        x2 //= 10\n        p2 += 1\n    \n    # Compare the number of digits after normalization\n    if p1 < p2:\n        return \'<\'\n    elif p1 > p2:\n        return \'>\'\n    else:\n        # If the number of trailing zeros is the same, compare the numerical values\n        if x1 < x2:\n            return \'<\'\n        elif x1 > x2:\n            return \'>\'\n        else:\n            return \'=\'\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x1 = int(data[index])\n        p1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        p2 = int(data[index + 3])\n        index += 4\n        results.append(compare_numbers(x1, p1, x2, p2))\n    \n    for result in results:\n        print(result)', 'import math\n\ndef compare_numbers(x1, p1, x2, p2):\n    # Calculate the number of digits in x1 and x2\n    digits1 = int(math.log10(x1)) if x1 > 0 else 0\n    digits2 = int(math.log10(x2)) if x2 > 0 else 0\n    \n    # Compare the number of digits\n    if digits1 + p1 < digits2 + p2:\n        return \'<\'\n    elif digits1 + p1 > digits2 + p2:\n        return \'>\'\n    else:\n        # If the number of digits is the same, compare the original numbers\n        if x1 * (10 ** p1) < x2 * (10 ** p2):\n            return \'<\'\n        elif x1 * (10 ** p1) > x2 * (10 ** p2):\n            return \'>\'\n        else:\n            return \'=\'\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x1 = int(data[index])\n        p1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        p2 = int(data[index + 3])\n        index += 4\n        results.append(compare_numbers(x1, p1, x2, p2))\n    \n    for result in results:\n        print(result)']
----------
["- name: \nNaive Comparison by Appending Zeros\n\n- content: \n- For each test case, append zeros to both numbers based on their respective `p` values.\n- Compare the two resulting numbers directly.\n- If they are equal, compare the lengths of their decimal representations.\n- Return '<' if the first number is smaller, '>' if it is larger, and '=' if they are equal.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'positive integer': means the number is greater than 0\n    'appending zeros': means adding zeros at the end of the number\n    'comparison': means comparing the two numbers to determine their relationship\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, append zeros to both numbers based on their respective `p` values.\n    Compare the two resulting numbers directly.\n    If they are equal, compare the lengths of their decimal representations.\n    Return '<' if the first number is smaller, '>' if it is larger, and '=' if they are equal.\n\n# [edge case] \n    Test case:\n    1\n    2 1\n    19 0\n    Expected output: '>'\n    Explanation: Appending one zero to 2 gives 20, which is greater than 19.\n\n    Test case:\n    2\n    10 2\n    100 1\n    Expected output: '='\n    Explanation: Appending two zeros to 10 gives 1000, and appending one zero to 100 gives 1000, so they are equal.\n\n    Test case:\n    3\n    1999 0\n    2 3\n    Expected output: '<'\n    Explanation: Appending zero zeros to 1999 gives 1999, and appending three zeros to 2 gives 2000, so 1999 is smaller than 2000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already covers the edge cases by comparing the numbers directly after appending the zeros.", '- name: \nDirect Comparison with Zero Handling\n\n- content: \nA direct approach that handles cases where zeros need to be appended efficiently by comparing the lengths of the numbers after appending zeros. This avoids dealing with large numbers directly.\n\n**Approach:**\n1. For each test case, read the input values `x1`, `p1`, `x2`, and `p2`.\n2. Determine the number of digits in `x1` after appending `p1` zeros and similarly for `x2`.\n3. Compare the lengths of these numbers to determine the result of the comparison.\n4. Output the comparison result (`<`, `>`, or `=`).\n\n**Edge Cases:**\n- When both numbers have no zeros to append, their lengths are directly comparable.\n- When one number has more zeros to append, it will always be longer.\n- When both numbers have the same number of zeros to append, compare their numerical values without the appended zeros.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'positive integer\': means the number is greater than 0\n    \'zero appended\': means zeros are added to the end of the number\n    \'comparison\': means comparing two numbers to determine which is larger, smaller, or equal\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    "Determine the number of digits in `x1` after appending `p1` zeros and similarly for `x2`."\n    This can be done by converting the numbers to strings and appending zeros, then comparing the lengths of these strings.\n\n# [edge case] \n    Case 1:\n    x1 = 1, p1 = 0\n    x2 = 1, p2 = 0\n    Expected Output: =\n    Explanation: Both numbers are 1, and no zeros are appended, so they are equal.\n\n    Case 2:\n    x1 = 1, p1 = 1\n    x2 = 1, p2 = 0\n    Expected Output: >\n    Explanation: The first number becomes 10 after appending one zero, which is greater than 1.\n\n    Case 3:\n    x1 = 1, p1 = 0\n    x2 = 2, p2 = 0\n    Expected Output: <\n    Explanation: The first number is 1, and the second number is 2, so the first number is smaller.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The comparison logic directly handles all cases without needing additional conditions.', "- name: \nMathematical Comparison Using Logarithms\n\n- content: \n- Use logarithms to compare the magnitudes of the numbers.\n- Calculate the logarithm base 10 of both numbers to determine their order of magnitude.\n- Compare the logarithms to determine which number is larger.\n- If the logarithms are equal, compare the number of trailing zeros.\n- Handle edge cases where one number has more significant digits than the other, which will result in a different order of magnitude.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'logarithm': a mathematical operation that determines the exponent to which a given base must be raised to produce a specified number.\n    Explanation: Logarithms are used to compare the magnitudes of numbers, especially when dealing with very large or very small numbers. By taking the logarithm of a number, we can determine its order of magnitude.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Calculate the logarithm base 10 of both numbers.\n    - Compare the logarithms to determine which number is larger.\n    - If the logarithms are equal, compare the number of trailing zeros.\n\n# [edge case]\n    Edge case 1:\n    Input: 1, 1000000\n          1, 0\n    Output: '>'\n    Explanation: The first number is 1 followed by 6 zeros (1000000), while the second number is just 1. The logarithm of 1000000 is 6, which is greater than the logarithm of 1 (which is 0). Therefore, the first number is greater.\n\n    Edge case 2:\n    Input: 10, 2\n          100, 1\n    Output: '='\n    Explanation: Both numbers have the same number of significant digits (2 for the first number and 3 for the second number). The number of trailing zeros does not affect the comparison since they are equal.\n\n    Edge case 3:\n    Input: 1, 0\n          99, 0\n    Output: '<'\n    Explanation: The first number is 1, while the second number is 99. The logarithm of 99 is greater than the logarithm of 1. Therefore, the first number is smaller.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The comparison logic using logarithms inherently handles these cases correctly.", "- name: \nBrute Force Comparison with Trailing Zeros Adjustment\n\n- content: \nA brute force approach that involves directly comparing the numbers after adjusting for the trailing zeros by multiplying or dividing by powers of 10.\n\n**Solution Approach:**\n1. For each test case, read the inputs `x_1`, `p_1`, `x_2`, and `p_2`.\n2. Adjust `x_1` and `x_2` by removing trailing zeros from `x_1` and `x_2` respectively.\n3. Compare the adjusted numbers directly. If they are equal, compare the original numbers of trailing zeros (`p_1` and `p_2`).\n4. Output the comparison result ('<', '>', or '=').\n\n**Handling Edge Cases:**\n- If both numbers have the same number of digits before the appended zeros, compare the numbers directly.\n- If one number has more digits before the appended zeros, it is larger.\n- If one number has fewer digits before the appended zeros, it is smaller.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'trailing zeros': means the zeros appended to the end of a number.\n    Explanation: In the requirement, the numbers are described as a positive integer `x` with `p` zeros appended to its end. This means the number is effectively `x * 10^p`.\n\n# [phrase showing quantity relationship]\n    'more than': means that one number is greater than another.\n    'less than': means that one number is smaller than another.\n\n# [degree adverb] \n    'largest': means the biggest number.\n    'smallest': means the smallest number.\n\n# [code logic]\n    The steps should be implement simultaneously.\n    Adjust `x_1` and `x_2` by removing trailing zeros from `x_1` and `x_2` respectively.\n    Compare the adjusted numbers directly. If they are equal, compare the original numbers of trailing zeros (`p_1` and `p_2`).\n\n# [edge case] \n    Edge case 1: 10 2 vs 100 1\n    Expected output: =\n    Explanation: After adjusting for trailing zeros, both numbers become 1000 and 1000 respectively, so they are equal.\n\n    Edge case 2: 1 0 vs 99 0\n    Expected output: >\n    Explanation: After adjusting for trailing zeros, the first number becomes 1 and the second becomes 99. Clearly, 1 is less than 99.\n\n    Edge case 3: 1999 0 vs 2 3\n    Expected output: <\n    Explanation: After adjusting for trailing zeros, the first number becomes 1999 and the second becomes 2000. Clearly, 1999 is less than 2000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The provided logic already correctly handles the edge cases by adjusting for trailing zeros and comparing the numbers directly.", "- name: \nCompare Numbers by Removing Trailing Zeros\n\n- content: \n- For each test case, remove the trailing zeros from both numbers.\n- Compare the resulting numbers directly.\n- If both numbers have the same number of digits after removing the trailing zeros, compare them directly.\n- If one number has more trailing zeros, it will be larger.\n- If one number is significantly larger but has fewer trailing zeros, compare them directly.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'trailing zeros': zeros at the end of a number that are not significant in value comparison.\n    Explanation: When comparing numbers, trailing zeros do not affect the numerical value, so they can be removed for comparison purposes.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    For each test case, remove the trailing zeros from both numbers.\n    Compare the resulting numbers directly.\n    If both numbers have the same number of digits after removing the trailing zeros, compare them directly.\n    If one number has more trailing zeros, it will be larger.\n    If one number is significantly larger but has fewer trailing zeros, compare them directly.\n\n# [edge case] \n    Test Case:\n    1\n    2 1\n    19 0\n    \n    Expected Output: >\n    Explanation: After removing trailing zeros, the first number becomes 2 and the second number becomes 19. Clearly, 2 < 19.\n\n    Test Case:\n    1\n    10 2\n    100 1\n    \n    Expected Output: =\n    Explanation: After removing trailing zeros, both numbers become 1 (since 100 with one trailing zero becomes 10, and then 10 with two trailing zeros becomes 1).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle cases where numbers are equal after removing trailing zeros.", "- name: \nDirect Comparison with Logarithms\n\n- content: \nUse logarithms to determine the relative sizes of the numbers before and after appending zeros. Calculate the logarithm base 10 of the original numbers and compare them directly. If the logarithms are different, the comparison result can be determined based on that. If the logarithms are the same, compare the original numbers without the appended zeros. This approach is efficient and avoids string manipulation entirely, making it suitable for very large numbers.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'logarithm': a mathematical function that helps in comparing the sizes of numbers, especially when dealing with very large or very small numbers.\n    Explanation: Logarithms allow us to compare numbers by looking at their relative sizes, which is useful when dealing with numbers that have a large number of zeros appended to them.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - For each testcase, calculate the logarithm base 10 of the original numbers.\n    - Compare the logarithms to determine the relative size of the numbers.\n    - If the logarithms are different, the comparison result can be determined based on that.\n    - If the logarithms are the same, compare the original numbers without the appended zeros.\n\n# [edge case] \n    Edge case 1:\n    Input: 1 0\n           1 0\n    Output: =\n    Explanation: Both numbers are 1, and no zeros are appended. Therefore, they are equal.\n\n    Edge case 2:\n    Input: 1 1\n           10 0\n    Output: <\n    Explanation: The first number is 10 after appending one zero, while the second number is 1. Therefore, the first number is smaller.\n\n    Edge case 3:\n    Input: 10 2\n           100 1\n    Output: >\n    Explanation: The first number is 1000 after appending two zeros, while the second number is 100 after appending one zero. Therefore, the first number is larger.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The comparison logic based on logarithms is sufficient for all test cases.", "- name: \nBrute Force Comparison with Zero Appending\n\n- content: \n- **Approach**: Append zeros to both numbers and then compare them directly. This approach is straightforward but may not be efficient for large numbers of test cases.\n- **Solution**: For each test case, append zeros to both numbers based on their respective `p` values and then compare them using standard comparison operators.\n- **Edge Cases**: Ensure that the comparison correctly handles very large numbers and edge cases where one number has significantly more zeros appended than the other.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'zero appending': means adding a certain number of zeros to the end of a number\n    'comparison': means comparing two numbers to determine which one is larger, smaller, or if they are equal\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    For each test case, append zeros to both numbers based on their respective `p` values and then compare them using standard comparison operators.\n\n# [edge case] \n    Test Case:\n    1\n    2 1\n    19 0\n\n    Expected Output: >\n    Explanation: Appending one zero to 2 gives 20, and 20 > 19.\n\n    Test Case:\n    2\n    10 2\n    100 1\n\n    Expected Output: =\n    Explanation: Appending two zeros to 10 gives 1000, and appending one zero to 100 gives 1000. Both numbers are equal.\n\n    Test Case:\n    3\n    1999 0\n    2 3\n\n    Expected Output: <\n    Explanation: Appending zero zeros to 1999 gives 1999, and appending three zeros to 2 gives 2000. 1999 < 2000.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The provided logic correctly handles the comparison after appending zeros.", "- name: \nMathematical Comparison Using Logarithms\n\n- content: \n- Use logarithms to compare the magnitudes of the numbers.\n- Calculate the logarithm base 10 of both numbers to determine their order of magnitude.\n- Compare the logarithms to determine which number is larger.\n- If the logarithms are equal, compare the number of trailing zeros.\n- Handle edge cases where one number has more significant digits than the other, which will result in a different order of magnitude.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'logarithm': a mathematical operation that determines the exponent to which a given base must be raised to produce a specified number.\n    Explanation: Logarithms are used to compare the magnitudes of numbers, especially when dealing with very large or very small numbers. By taking the logarithm of a number, we can determine its order of magnitude.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Calculate the logarithm base 10 of both numbers.\n    - Compare the logarithms to determine which number is larger.\n    - If the logarithms are equal, compare the number of trailing zeros.\n\n# [edge case]\n    Edge case 1:\n    Input: 1, 1000000\n          1, 0\n    Output: '>'\n    Explanation: The first number is 1 followed by 6 zeros (1000000), while the second number is just 1. The logarithm of 1000000 is 6, which is greater than the logarithm of 1 (which is 0). Therefore, the first number is greater.\n\n    Edge case 2:\n    Input: 10, 2\n          100, 1\n    Output: '='\n    Explanation: Both numbers have the same number of significant digits (2 for the first number and 3 for the second number). The number of trailing zeros does not affect the comparison since they are equal.\n\n    Edge case 3:\n    Input: 1, 0\n          99, 0\n    Output: '<'\n    Explanation: The first number is 1, while the second number is 99. The logarithm of 99 is greater than the logarithm of 1. Therefore, the first number is smaller.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The comparison logic using logarithms inherently handles these cases correctly.", '- name: \nDirect Comparison with Zero Handling\n\n- content: \nA direct approach that handles cases where zeros need to be appended efficiently by comparing the lengths of the numbers after appending zeros. This avoids dealing with large numbers directly.\n\n**Approach:**\n1. For each test case, read the input values `x1`, `p1`, `x2`, and `p2`.\n2. Determine the number of digits in `x1` after appending `p1` zeros and similarly for `x2`.\n3. Compare the lengths of these numbers to determine the result of the comparison.\n4. Output the comparison result (`<`, `>`, or `=`).\n\n**Edge Cases:**\n- When both numbers have no zeros to append, their lengths are directly comparable.\n- When one number has more zeros to append, it will always be longer.\n- When both numbers have the same number of zeros to append, compare their numerical values without the appended zeros.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'positive integer\': means the number is greater than 0\n    \'zero appended\': means zeros are added to the end of the number\n    \'comparison\': means comparing two numbers to determine which is larger, smaller, or equal\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    "Determine the number of digits in `x1` after appending `p1` zeros and similarly for `x2`."\n    This can be done by converting the numbers to strings and appending zeros, then comparing the lengths of these strings.\n\n# [edge case] \n    Case 1:\n    x1 = 1, p1 = 0\n    x2 = 1, p2 = 0\n    Expected Output: =\n    Explanation: Both numbers are 1, and no zeros are appended, so they are equal.\n\n    Case 2:\n    x1 = 1, p1 = 1\n    x2 = 1, p2 = 0\n    Expected Output: >\n    Explanation: The first number becomes 10 after appending one zero, which is greater than 1.\n\n    Case 3:\n    x1 = 1, p1 = 0\n    x2 = 2, p2 = 0\n    Expected Output: <\n    Explanation: The first number is 1, and the second number is 2, so the first number is smaller.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The comparison logic directly handles all cases without needing additional conditions.', "- name: \nDirect Comparison with Logarithms\n\n- content: \nUse logarithms to determine the relative sizes of the numbers before and after appending zeros. Calculate the logarithm base 10 of the original numbers and compare them directly. If the logarithms are different, the comparison result can be determined based on that. If the logarithms are the same, compare the original numbers without the appended zeros. This approach is efficient and avoids string manipulation entirely, making it suitable for very large numbers.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'logarithm': a mathematical function that helps in comparing the sizes of numbers, especially when dealing with very large or very small numbers.\n    Explanation: Logarithms allow us to compare numbers by looking at their relative sizes, which is useful when dealing with numbers that have a large number of zeros appended to them.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - For each testcase, calculate the logarithm base 10 of the original numbers.\n    - Compare the logarithms to determine the relative size of the numbers.\n    - If the logarithms are different, the comparison result can be determined based on that.\n    - If the logarithms are the same, compare the original numbers without the appended zeros.\n\n# [edge case] \n    Edge case 1:\n    Input: 1 0\n           1 0\n    Output: =\n    Explanation: Both numbers are 1, and no zeros are appended. Therefore, they are equal.\n\n    Edge case 2:\n    Input: 1 1\n           10 0\n    Output: <\n    Explanation: The first number is 10 after appending one zero, while the second number is 1. Therefore, the first number is smaller.\n\n    Edge case 3:\n    Input: 10 2\n           100 1\n    Output: >\n    Explanation: The first number is 1000 after appending two zeros, while the second number is 100 after appending one zero. Therefore, the first number is larger.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The comparison logic based on logarithms is sufficient for all test cases."]
----------
True
----------
4
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You need to break exactly one of them into two pieces, ensuring both pieces have positive integer lengths greater than 0 and their total length equals the original length of the stick. After this operation, you should be able to form a rectangle or a square from the resulting four sticks, with each stick serving as one side of the rectangle. Determine if this is achievable.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
multi-gen-prompt:
 There are three sticks with integer lengths l_1, l_2, and l_3. You are asked to break exactly one of them into two pieces in such a way that both pieces have positive integer length and their total length equals the original length of the stick. Determine if it's possible to do that and construct a rectangle or square from the resulting four sticks.

Input

The first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases.

The only line of each testcase contains three integers l_1, l_2, l_3 (1 ≤ l_i ≤ 10^8) — the lengths of the sticks.

Output

For each testcase, print "YES" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print "NO".

You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).

Example

Input


4
6 1 5
2 5 2
2 4 2
5 5 4


Output


YES
NO
YES
YES

Note

In the first testcase, the first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.

In the second testcase, breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can't be put into a rectangle.

In the third testcase, the second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).

In the fourth testcase, the third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.
generating with deepseek-coder
----------
['def can_form_rectangle(sticks):\n    sticks.sort()\n    if sticks[0] == sticks[1] == sticks[2]:\n        return "YES"  # All three sticks are equal, forming a square\n    elif sticks[0] + sticks[1] == sticks[2]:\n        return "YES"  # Two sticks are equal, and the third is exactly the sum of the other two\n    elif sticks[0] == sticks[1] and sticks[2] % 2 == 0 and sticks[0] + sticks[1] > sticks[2] / 2:\n        return "YES"  # Two sticks are equal, and the third is even, and the sum of the two equal sticks is greater than half of the third stick\n    elif sticks[1] == sticks[2] and sticks[0] % 2 == 0 and sticks[1] + sticks[2] > sticks[0] / 2:\n        return "YES"  # Two sticks are equal, and the first is even, and the sum of the two equal sticks is greater than half of the first stick\n    elif sticks[0] == sticks[2] and sticks[1] % 2 == 0 and sticks[0] + sticks[2] > sticks[1] / 2:\n        return "YES"  # Two sticks are equal, and the second is even, and the sum of the two equal sticks is greater than half of the second stick\n    else:\n        return "NO"  # Other cases where forming a rectangle is not possible without breaking a stick\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        l1 = int(data[index])\n        l2 = int(data[index + 1])\n        l3 = int(data[index + 2])\n        index += 3\n        results.append(can_form_rectangle([l1, l2, l3]))\n    \n    for result in results:\n        print(result)', 'def can_form_rectangle(l1, l2, l3):\n    # Check all possible ways to break one of the sticks into two pieces\n    if l1 == l2 + l3 and l1 > 0 and l2 > 0 and l3 > 0:\n        return "YES"\n    if l2 == l1 + l3 and l2 > 0 and l1 > 0 and l3 > 0:\n        return "YES"\n    if l3 == l1 + l2 and l3 > 0 and l1 > 0 and l2 > 0:\n        return "YES"\n    if l1 == l2 and l3 % 2 == 0:\n        return "YES"\n    if l1 == l3 and l2 % 2 == 0:\n        return "YES"\n    if l2 == l3 and l1 % 2 == 0:\n        return "YES"\n    return "NO"\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        l1 = int(data[index])\n        l2 = int(data[index + 1])\n        l3 = int(data[index + 2])\n        index += 3\n        results.append(can_form_rectangle(l1, l2, l3))\n    \n    for result in results:\n        print(result)', 'def can_form_rectangle(sticks):\n    sticks.sort()\n    if sticks[0] == sticks[1] and sticks[2] % 2 == 0:\n        return "YES"\n    if sticks[1] == sticks[2] and sticks[0] % 2 == 0:\n        return "YES"\n    if sticks[0] + sticks[1] == sticks[2]:\n        return "YES"\n    return "NO"\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        l1 = int(data[index])\n        l2 = int(data[index + 1])\n        l3 = int(data[index + 2])\n        index += 3\n        results.append(can_form_rectangle([l1, l2, l3]))\n    \n    for result in results:\n        print(result)', 'def can_form_rectangle(l1, l2, l3):\n    # Check all possible ways to break one stick into two pieces\n    if l1 == l2 + l3 or l2 == l1 + l3 or l3 == l1 + l2:\n        return True\n    if l1 == l2 and l3 % 2 == 0:\n        return True\n    if l1 == l3 and l2 % 2 == 0:\n        return True\n    if l2 == l3 and l1 % 2 == 0:\n        return True\n    return False\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        l1, l2, l3 = map(int, input().split())\n        if can_form_rectangle(l1, l2, l3):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()', 'def can_form_rectangle(l1, l2, l3):\n    # Sort the lengths\n    lengths = sorted([l1, l2, l3])\n    \n    # Check if the two smallest lengths are equal or if their sum equals the largest length\n    if lengths[0] + lengths[1] == lengths[2]:\n        return "YES"\n    elif lengths[0] == lengths[1] and lengths[2] % 2 == 0:\n        return "YES"\n    elif lengths[1] == lengths[2] and lengths[0] % 2 == 0:\n        return "YES"\n    else:\n        return "NO"\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        l1 = int(data[index])\n        l2 = int(data[index + 1])\n        l3 = int(data[index + 2])\n        index += 3\n        results.append(can_form_rectangle(l1, l2, l3))\n    \n    for result in results:\n        print(result)', 'def can_form_rectangle(l_1, l_2, l_3):\n    # Sort the lengths\n    lengths = sorted([l_1, l_2, l_3])\n    \n    # Check if any two lengths are equal and the third length is even\n    if lengths[0] == lengths[1] and lengths[2] % 2 == 0:\n        return "YES"\n    if lengths[1] == lengths[2] and lengths[0] % 2 == 0:\n        return "YES"\n    if lengths[0] + lengths[1] == lengths[2]:\n        return "YES"\n    \n    # If none of the above conditions are met, return "NO"\n    return "NO"\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        l_1 = int(data[index])\n        l_2 = int(data[index + 1])\n        l_3 = int(data[index + 2])\n        index += 3\n        results.append(can_form_rectangle(l_1, l_2, l_3))\n    \n    for result in results:\n        print(result)', 'def can_form_rectangle(l1, l2, l3):\n    # Check all possible ways to break one of the sticks into two pieces\n    if l1 == l2 + l3 or l2 == l1 + l3 or l3 == l1 + l2:\n        return True\n    if l1 == l2 and l3 % 2 == 0:\n        return True\n    if l1 == l3 and l2 % 2 == 0:\n        return True\n    if l2 == l3 and l1 % 2 == 0:\n        return True\n    return False\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        l1, l2, l3 = map(int, input().split())\n        if can_form_rectangle(l1, l2, l3):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()', 'def can_form_rectangle(l_1, l_2, l_3):\n    # Sort the lengths to easily compare\n    sorted_lengths = sorted([l_1, l_2, l_3])\n    \n    # Check if all lengths are equal\n    if sorted_lengths[0] == sorted_lengths[1] == sorted_lengths[2]:\n        return "NO"\n    \n    # Check if the sum of the two smaller lengths equals the largest length\n    if sorted_lengths[0] + sorted_lengths[1] == sorted_lengths[2]:\n        return "YES"\n    \n    # Check if breaking one stick into two pieces results in positive integer lengths\n    if sorted_lengths[0] + sorted_lengths[1] > sorted_lengths[2]:\n        return "YES"\n    \n    # If not all lengths are equal and the sum of the two smaller lengths does not equal the largest length, it\'s not possible to form a rectangle\n    return "NO"\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        l_1 = int(data[index])\n        l_2 = int(data[index + 1])\n        l_3 = int(data[index + 2])\n        index += 3\n        results.append(can_form_rectangle(l_1, l_2, l_3))\n    \n    for result in results:\n        print(result)', 'def can_form_rectangle(l1, l2, l3):\n    # Check all possible splits for each stick\n    if l1 == l2 and l2 == l3:\n        return "YES"  # All sticks are equal, can\'t split any\n    if l1 == l2 or l2 == l3 or l1 == l3:\n        # Two sticks are equal, the third one can be split into two equal parts\n        if l1 == l2:\n            return "YES" if l3 % 2 == 0 else "NO"\n        if l2 == l3:\n            return "YES" if l1 % 2 == 0 else "NO"\n        if l1 == l3:\n            return "YES" if l2 % 2 == 0 else "NO"\n    # Check if the three lengths can form a rectangle\n    lengths = [l1, l2, l3]\n    lengths.sort()\n    if lengths[0] + lengths[1] == lengths[2]:\n        return "YES"  # The three lengths can form a rectangle\n    return "NO"\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        l1 = int(data[index])\n        l2 = int(data[index + 1])\n        l3 = int(data[index + 2])\n        index += 3\n        results.append(can_form_rectangle(l1, l2, l3))\n    \n    for result in results:\n        print(result)', 'def can_form_rectangle(l1, l2, l3):\n    # Check all possible ways to break one stick into two pieces\n    if l1 == l2 + l3 or l2 == l1 + l3 or l3 == l1 + l2:\n        return True\n    if l1 == l2 and l3 % 2 == 0:\n        return True\n    if l1 == l3 and l2 % 2 == 0:\n        return True\n    if l2 == l3 and l1 % 2 == 0:\n        return True\n    return False\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        l1, l2, l3 = map(int, input().split())\n        if can_form_rectangle(l1, l2, l3):\n            print("YES")\n        else:\n            print("NO")\n\nif __name__ == "__main__":\n    main()']
----------
['- name: \nSpecial Case Handling\n\n- content: \nA more efficient approach is to handle special cases where the sticks can directly form a square or a rectangle. This can be done by checking:\n1. If all three lengths are equal, then they directly form a square.\n2. If two lengths are equal and the third length is less than or equal to twice the length of the equal sticks, then breaking one of the equal sticks into two parts will form a rectangle.\n\nThis approach focuses on handling cases where the sticks inherently form a rectangle or a square without explicitly breaking any stick, thus optimizing for cases where breaking is not necessary.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'rectangle formation\': means that the four sticks can be arranged to form a rectangle or a square.\n    \'breaking a stick\': means dividing one stick into two pieces with positive integer lengths.\n\n# [phrase showing quantity relationship]\n    \'positive (strictly greater than 0)\': means the lengths of the pieces must be greater than 0.\n    \'equal to\': means the total length of the pieces must be equal to the original length of the stick.\n\n# [degree adverb] \n    \'positive (strictly greater than 0)\': means the lengths of the pieces must be greater than 0.\n\n# [code logic]\n    The plan should consider both cases:\n    1. Directly checking if the three lengths can form a square or a rectangle.\n    2. Breaking one stick into two pieces and checking if the resulting four sticks can form a rectangle or a square.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 1, 1]\n    Explanation: All three sticks are of equal length, so they directly form a square.\n    Expected Output: YES\n\n    Edge case 2:\n    Input: [2, 2, 5]\n    Explanation: Two sticks are of equal length, and the third length is less than or equal to twice the length of the equal sticks, so breaking one of the equal sticks into two parts will form a rectangle.\n    Expected Output: YES\n\n    Edge case 3:\n    Input: [3, 3, 3]\n    Explanation: All three sticks are of equal length, so they directly form a square.\n    Expected Output: YES\n\n    Edge case 4:\n    Input: [2, 2, 4]\n    Explanation: Two sticks are of equal length, and the third length is greater than twice the length of the equal sticks, so breaking one of the equal sticks into two parts will not form a rectangle.\n    Expected Output: NO\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the lengths do not allow for a rectangle or square formation without breaking a stick.\n    Example code:\n    ```python\n    def can_form_rectangle(sticks):\n        sticks.sort()\n        if sticks[0] == sticks[1] == sticks[2]:\n            return "YES"  # All three sticks are equal, forming a square\n        elif sticks[0] + sticks[1] > sticks[2]:\n            return "YES"  # Two sticks are equal, and the third is less than or equal to twice the length of the equal sticks\n        else:\n            return "NO"  # Other cases where forming a rectangle is not possible without breaking a stick\n\n    # Example usage:\n    print(can_form_rectangle([1, 1, 1]))  # YES\n    print(can_form_rectangle([2, 2, 5]))  # YES\n    print(can_form_rectangle([3, 3, 3]))  # YES\n    print(can_form_rectangle([2, 2, 4]))  # NO\n    ```', '- name: \nBrute Force Solution\n\n- content: \nThis solution involves checking all possible ways to break one of the sticks into two pieces and then checking if the resulting four sticks can form a rectangle.\n\n1. For each stick in the test case, iterate through possible break points to create two pieces.\n2. Check if the sum of the two pieces equals the original length of the stick.\n3. If so, check if the four sticks can form a rectangle by checking for pairs of equal lengths.\n4. If a valid rectangle can be formed, return "YES"; otherwise, continue checking other possibilities.\n5. If no valid rectangle can be formed after checking all possibilities, return "NO".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'rectangle formation\': means that the four sticks can be arranged to form a rectangle or a square.\n    \'positive integer length\': means that the pieces created from breaking a stick must be strictly greater than 0.\n\n# [phrase showing quantity relationship]\n    \'positive (strictly greater than 0)\': means that the pieces created from breaking a stick must be greater than 0.\n\n# [degree adverb] \n    No degree adverb directly related to the requirement.\n\n# [code logic]\n    The plan involves checking all possible ways to break one of the sticks into two pieces and then checking if the resulting four sticks can form a rectangle.\n    Steps 1-5 in the plan should be implemented sequentially.\n\n# [edge case] \n    Edge case 1:\n    Input: [6, 1, 5]\n    Explanation: The first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.\n    Edge case 2:\n    Input: [2, 5, 2]\n    Explanation: Breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which cannot be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can be put into a rectangle.\n    Edge case 3:\n    Input: [2, 4, 2]\n    Explanation: The second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).\n    Edge case 4:\n    Input: [5, 5, 4]\n    Explanation: The third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic in the plan should be sufficient to determine if a rectangle can be formed from the given sticks.', '- name: \nMathematical Analysis\n\n- content: \nBy analyzing the problem mathematically, we can determine if forming a rectangle is possible without explicitly breaking sticks. The conditions are:\n1. Check if any two lengths are equal and the third length is even and less than or equal to twice the other length.\n2. Check if the sum of any two lengths is equal to the third length, allowing for the formation of a rectangle by splitting the third length.\n3. If any of these conditions are met, print "YES". Otherwise, print "NO".\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'rectangle formation\': The task involves determining if it\'s possible to form a rectangle or square using four sticks, where each stick can be split into two parts.\n\n# [phrase showing quantity relationship]\n    \'positive (strictly greater than 0)\': Indicates that the lengths of the pieces after splitting must be greater than 0.\n    \'equal to\': The total length of the pieces must sum up to the original length of the stick.\n\n# [degree adverb] \n    \'positive (strictly greater than 0)\': Refers to the lengths of the pieces after splitting.\n\n# [code logic]\n    The steps should be implemented sequentially as per the plan.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 1, 2]\n    Explanation: The sticks can be split into [1, 1] and [1, 1], forming a rectangle with sides 1 and 2.\n    Edge case 2:\n    Input: [3, 3, 6]\n    Explanation: The sticks can be split into [3, 3] and [3, 3], forming a square with sides 3 and 3.\n    Edge case 3:\n    Input: [1, 2, 3]\n    Explanation: No matter how the sticks are split, it\'s impossible to form a rectangle or square.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the sum of any two lengths is not equal to the third length.\n        def can_form_rectangle(sticks):\n            sticks.sort()\n            if sticks[0] + sticks[1] > sticks[2]:\n                return "NO"\n            return "YES"\n\n    This code checks if the sum of the two smallest lengths is greater than the largest length, which would make forming a rectangle impossible.', '- name: \nBrute Force with Validation\n\n- content: \nAnother approach is to try breaking each stick into two pieces and check if the resulting lengths can form a rectangle or a square.\n1. Iterate through each stick and try to break it into two pieces with positive integer lengths.\n2. Check if the four resulting lengths can form a rectangle or a square.\n3. If any combination works, print "YES".\n4. If none work, print "NO".\n5. This method ensures that we explore all possible ways of breaking the sticks and validate the solution for each test case.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'rectangle or square formation\': means that the four sticks can be arranged to form a rectangle or a square with each stick serving as one side.\n    \'positive integer lengths\': means that the two pieces into which a stick is broken must be greater than 0.\n\n# [phrase showing quantity relationship]\n    \'more than\': means that the two pieces into which a stick is broken must be greater than 0.\n\n# [degree adverb] \n    \'largest\': not applicable in this context as it does not directly relate to the breaking of sticks into pieces.\n\n# [code logic]\n    The plan suggests iterating through each stick and trying to break it into two pieces with positive integer lengths. This can be implemented by checking all possible pairs of lengths from the three sticks and ensuring their sum equals the original length of the stick.\n\n# [edge case] \n    search([1, 1, 2]) = YES\n    Explanation: The stick of length 2 can be broken into parts of length 1 and 1, forming a rectangle with opposite sides of length 1.\n    search([3, 3, 3]) = NO\n    Explanation: All sticks are of equal length, so breaking any one of them will not form a rectangle or a square.\n    search([2, 2, 4]) = YES\n    Explanation: The stick of length 4 can be broken into parts of length 2 and 2, forming a square with all sides of length 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic in the plan already covers the edge case where all sticks are of equal length, and it correctly outputs "NO".', '- name: \nBrute Force and Sorting\n\n- content: \nFor each test case, we can iterate through each stick and check all possible ways to split it into two pieces. We then check if the resulting four lengths can form a rectangle or a square. To do this efficiently, we can sort the lengths and check if the two smallest lengths are equal or if the two smallest lengths sum to the largest length. This approach ensures that we cover all possible splits and edge cases.\n\n**Steps:**\n1. For each test case, read the three stick lengths.\n2. Sort the lengths.\n3. Check if the two smallest lengths are equal or if their sum equals the largest length.\n4. If either condition is met, print "YES"; otherwise, print "NO".\n\nThis solution ensures that all valid inputs and edge cases are covered as per the problem description.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'rectangle or square formation\': means that the four sticks can be arranged to form a rectangle or a square with each stick serving as one side.\n    \'positive integer lengths\': means that the pieces obtained from breaking a stick must be greater than 0.\n\n# [phrase showing quantity relationship]\n    \'positive integer lengths\': means that the pieces obtained from breaking a stick must be greater than 0.\n\n# [degree adverb] \n    No degree adverb directly related to the requirement.\n\n# [code logic]\n    The steps should be implemented sequentially as per the plan.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 1, 2]\n    Explanation: The sticks can be arranged to form a square with all sides of length 1.\n    Edge case 2:\n    Input: [3, 3, 6]\n    Explanation: The sticks can be arranged to form a rectangle with opposite sides of length 3 and 6.\n    Edge case 3:\n    Input: [2, 2, 5]\n    Explanation: The sticks cannot be arranged to form a rectangle or a square.\n    Edge case 4:\n    Input: [4, 4, 2]\n    Explanation: The sticks can be arranged to form a rectangle with opposite sides of length 4 and 4 (which is a square).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the plan covers the necessary checks. The plan includes sorting the lengths and checking the conditions for forming a rectangle or a square.', '- name: \nMathematical Analysis\n\n- content: \nWe can analyze the problem mathematically to determine if forming a rectangle or square is possible. The steps are as follows:\n1. Sort the lengths l_1, l_2, l_3.\n2. Check if any two lengths are equal and the third length is even with the sum of the two equal lengths.\n3. If two lengths are equal and the third length is even, return "YES".\n4. If no two lengths are equal and the sum of the two smaller lengths is greater than or equal to the largest length, return "YES".\n5. Otherwise, return "NO".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'breaking a stick into two pieces\': means splitting a stick into two smaller sticks with positive integer lengths.\n    \'constructing a rectangle or square\': means forming a shape with four sides where opposite sides are equal.\n\n# [phrase showing quantity relationship]\n    \'positive integer length\': means the lengths of the two pieces must be greater than 0.\n    \'equal\': means the lengths of the two pieces must be the same.\n    \'even\': means the sum of the two pieces must be divisible by 2.\n\n# [degree adverb] \n    \'positive integer length\': means the lengths of the two pieces must be greater than 0.\n    \'equal\': means the lengths of the two pieces must be the same.\n    \'even\': means the sum of the two pieces must be divisible by 2.\n\n# [code logic]\n    The steps 2-5 should be considered simultaneously.\n    After sorting the lengths, check if any two lengths are equal and the third length is even with the sum of the two equal lengths. If not, check if no two lengths are equal and the sum of the two smaller lengths is greater than or equal to the largest length.\n\n# [edge case] \n    Edge case 1:\n    Input: [6, 1, 5]\n    Explanation: After breaking the stick of length 6 into pieces of length 1 and 5, we can form a rectangle with opposite sides of length 1 and 5.\n    Expected output: YES\n\n    Edge case 2:\n    Input: [2, 5, 2]\n    Explanation: Breaking any of the sticks of length 2 or 5 will result in pieces that cannot form a rectangle.\n    Expected output: NO\n\n    Edge case 3:\n    Input: [2, 4, 2]\n    Explanation: Breaking the stick of length 4 into pieces of length 2 and 2 allows us to form a square with opposite sides of length 2.\n    Expected output: YES\n\n    Edge case 4:\n    Input: [5, 5, 4]\n    Explanation: Breaking one of the sticks of length 5 into pieces of length 2 and 3 allows us to form a rectangle with opposite sides of length 2 and 5.\n    Expected output: YES\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan is sufficient to determine if a rectangle or square can be formed.', '- name: \nCheck Length Combinations\n\n- content: \nFor each test case, check all possible ways to break one of the sticks into two pieces such that both pieces have positive integer lengths and their total length equals the original length of the stick. After breaking, check if the resulting four sticks can form a rectangle or square.\n\nSolution Approach:\n1. Iterate through each stick and try breaking it into two pieces with positive integer lengths.\n2. Check if the sum of the lengths of the two pieces equals the original length of the stick.\n3. After breaking, check if any two pieces are equal, which would indicate a square (all sides equal), or if there are two pairs of equal lengths, which would indicate a rectangle (two pairs of equal sides).\n4. If a valid combination is found, output "YES"; otherwise, output "NO".\n\nFunctional Correctness:\n- Ensure all possible valid inputs and edge cases are covered, including cases where breaking a stick does not result in a rectangle or square.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'breaking a stick into two pieces\': means splitting a single stick into two smaller sticks with positive integer lengths.\n    \'constructing a rectangle or square\': means forming a shape with four sides where opposite sides are equal.\n\n# [phrase showing quantity relationship]\n    \'positive integer length\': means the lengths of the two pieces must be greater than 0.\n    \'equals the original length\': means the sum of the lengths of the two pieces must match the original length of the stick.\n\n# [degree adverb] \n    \'positive integer length\': means the lengths of the two pieces must be greater than 0.\n    \'equals the original length\': means the sum of the lengths of the two pieces must match the original length of the stick.\n\n# [code logic]\n    The steps should be implement simultaneously. For each stick, check all possible ways to break it into two pieces such that both pieces have positive integer lengths and their total length equals the original length of the stick. After breaking, check if the resulting four sticks can form a rectangle or square.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 1, 2]\n    Explanation: The third stick can be broken into parts of length 1 and 1. The resulting rectangle has opposite sides 1 and 1 (which is a square).\n    Expected Output: YES\n\n    Edge case 2:\n    Input: [3, 3, 3]\n    Explanation: All sticks are of equal length, so breaking any one of them will result in three sticks of length 1.5 each, which cannot form a rectangle or square.\n    Expected Output: NO\n\n    Edge case 3:\n    Input: [2, 3, 4]\n    Explanation: None of the sticks can be broken into two pieces with positive integer lengths that can form a rectangle or square.\n    Expected Output: NO\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic in the plan should cover all possible valid inputs and edge cases.', '- name: \nBrute Force and Sorting\n- content: \nFor each test case, we can try all possible ways to break one of the sticks into two pieces. This involves checking all pairs of lengths that sum up to the original length of the stick. After breaking, we need to check if we can form a rectangle or square from the four resulting pieces. We can sort the lengths and then iterate through possible pairs to see if any pair sums up to the original length of the stick. If we find such a pair, we can form a rectangle or square. Otherwise, it\'s not possible.\n\n**Approach:**\n1. For each test case, read the three stick lengths.\n2. Sort the stick lengths.\n3. Check if the sum of the smallest two lengths equals the largest length. If so, a rectangle can be formed by breaking the largest stick.\n4. Check if all three lengths are equal. If so, it\'s impossible to form a rectangle by breaking any stick.\n5. If none of the above conditions are met, check if any pair of lengths (excluding the largest) sums up to the largest length. If so, a rectangle can be formed by breaking the largest stick.\n6. If no valid pair is found, print "NO".\n\n**Edge Cases:**\n- When all three lengths are equal, print "NO".\n- When two lengths are the same and the third is different, print "YES" after breaking the longer stick.\n- When all lengths are different, check if any pair sums up to the largest length.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'breaking a stick into two pieces\': means splitting a single stick into two smaller sticks with positive integer lengths.\n    \'constructing a rectangle or square\': means forming a geometric shape with four sides where opposite sides are equal in length.\n\n# [phrase showing quantity relationship]\n    \'positive integer length\': means the lengths of the two pieces must be greater than 0.\n\n# [degree adverb] \n    \'largest\': means the largest stick length among the three given lengths.\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 1, 2]\n    Explanation: The stick of length 2 can be broken into two pieces of length 1 each. The resulting four sticks can form a square with sides of length 1.\n    Edge case 2:\n    Input: [3, 3, 6]\n    Explanation: The stick of length 6 can be broken into two pieces of length 3 each. The resulting four sticks can form a rectangle with opposite sides of length 3.\n    Edge case 3:\n    Input: [2, 2, 5]\n    Explanation: The stick of length 5 cannot be broken into two pieces with positive integer lengths that can form a rectangle or square.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the lengths do not allow for forming a rectangle or square.\n        (code for handling the edge case)\n        if l_1 == l_2 == l_3:\n            return "NO"\n        sorted_lengths = sorted([l_1, l_2, l_3])\n        if sorted_lengths[0] + sorted_lengths[1] == sorted_lengths[2]:\n            return "YES"\n        else:\n            return "NO"', '- name: \nBrute Force and Check\n\n- content: \nThe brute force approach involves checking all possible ways to break one of the sticks into two pieces and then verifying if the resulting four pieces can form a rectangle. This can be done by iterating through each stick, trying all possible break points, and checking if the resulting lengths can form a rectangle.\n\nSteps:\n1. For each stick, iterate through possible break points to split it into two pieces.\n2. Check if the resulting four pieces can form a rectangle. This can be done by ensuring there are two pairs of equal lengths.\n3. If a valid split is found, return "YES". If no valid split is found after checking all possibilities, return "NO".\n\nThis approach ensures that all possible ways to break the sticks are considered, but it might not be the most efficient for large numbers of test cases.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'rectangle construction\': means forming a shape with four sides where opposite sides are equal.\n    \'square is a rectangle\': means a square is also considered a valid rectangle.\n\n# [phrase showing quantity relationship]\n    \'positive (strictly greater than 0)\': means the lengths of the pieces must be greater than 0.\n    \'equal to\': means the total length of the pieces must sum up to the original length of the stick.\n\n# [degree adverb] \n    No degree adverb specifically mentioned.\n\n# [code logic]\n    The steps should be implement simultaneously. The brute force approach mentioned in the plan is not efficient for large numbers of test cases. A more efficient approach would be to check the conditions for forming a rectangle directly.\n\n# [edge case] \n    Edge case 1:\n    Input: [6, 1, 5]\n    Explanation: The first stick can be broken into parts of length 1 and 5. We can construct a rectangle with opposite sides of length 1 and 5.\n    Expected Output: YES\n\n    Edge case 2:\n    Input: [2, 5, 2]\n    Explanation: Breaking the stick of length 2 can only result in sticks of lengths 1, 1, 2, 5, which can\'t be made into a rectangle. Breaking the stick of length 5 can produce results 2, 3 or 1, 4 but neither of them can\'t be put into a rectangle.\n    Expected Output: NO\n\n    Edge case 3:\n    Input: [2, 4, 2]\n    Explanation: The second stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 2 (which is a square).\n    Expected Output: YES\n\n    Edge case 4:\n    Input: [5, 5, 4]\n    Explanation: The third stick can be broken into parts of length 2 and 2. The resulting rectangle has opposite sides 2 and 5.\n    Expected Output: YES\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can be used to check for the conditions of forming a rectangle.', '- name: \nBrute Force with Validation\n\n- content: \nAnother approach is to try breaking each stick into two pieces and check if the resulting lengths can form a rectangle or a square.\n1. Iterate through each stick and try to break it into two pieces with positive integer lengths.\n2. Check if the four resulting lengths can form a rectangle or a square.\n3. If any combination works, print "YES".\n4. If none work, print "NO".\n5. This method ensures that we explore all possible ways of breaking the sticks and validate the solution for each test case.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'rectangle or square formation\': means that the four sticks can be arranged to form a rectangle or a square with each stick serving as one side.\n    \'positive integer lengths\': means that the two pieces into which a stick is broken must be greater than 0.\n\n# [phrase showing quantity relationship]\n    \'more than\': means that the two pieces into which a stick is broken must be greater than 0.\n\n# [degree adverb] \n    \'largest\': not applicable in this context as it does not directly relate to the breaking of sticks into pieces.\n\n# [code logic]\n    The plan suggests iterating through each stick and trying to break it into two pieces with positive integer lengths. This can be implemented by checking all possible pairs of lengths from the three sticks and ensuring their sum equals the original length of the stick.\n\n# [edge case] \n    search([1, 1, 2]) = YES\n    Explanation: The stick of length 2 can be broken into parts of length 1 and 1, forming a rectangle with opposite sides of length 1.\n    search([3, 3, 3]) = NO\n    Explanation: All sticks are of equal length, so breaking any one of them will not form a rectangle or a square.\n    search([2, 2, 4]) = YES\n    Explanation: The stick of length 4 can be broken into parts of length 2 and 2, forming a square with all sides of length 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic in the plan already covers the edge case where all sticks are of equal length, and it correctly outputs "NO".']
----------
True
----------
7
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
multi-gen-prompt:
 You are given a string s of length n consisting of characters a and/or b. Let \operatorname{AB}(s) be the number of occurrences of string ab in s as a substring. Analogically, \operatorname{BA}(s) is the number of occurrences of ba in s as a substring. In one step, you can choose any index i and replace s_i with character a or b. What is the minimum number of steps you need to make to achieve \operatorname{AB}(s) = \operatorname{BA}(s)?

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 1000). Description of the test cases follows.

The first and only line of each test case contains a single string s (1 ≤ |s| ≤ 100, where |s| is the length of the string s), consisting only of characters a and/or b.

Output

For each test case, print the resulting string s with \operatorname{AB}(s) = \operatorname{BA}(s) you'll get making the minimum number of steps.

If there are multiple answers, print any of them.

Example

Input


4
b
aabbbabaa
abbb
abbaab


Output


b
aabbbabaa
bbbb
abbaaa

Note

In the first test case, both \operatorname{AB}(s) = 0 and \operatorname{BA}(s) = 0 (there are no occurrences of ab (ba) in b), so can leave s untouched.

In the second test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 2, so you can leave s untouched. 

In the third test case, \operatorname{AB}(s) = 1 and \operatorname{BA}(s) = 0. For example, we can change s_1 to b and make both values zero.

In the fourth test case, \operatorname{AB}(s) = 2 and \operatorname{BA}(s) = 1. For example, we can change s_6 to a and make both values equal to 1.
generating with deepseek-coder
----------
['def count_substrings(s, substring):\n    count = 0\n    for i in range(len(s) - len(substring) + 1):\n        if s[i:i+len(substring)] == substring:\n            count += 1\n    return count\n\ndef balance_substrings(s):\n    ab_count = count_substrings(s, \'ab\')\n    ba_count = count_substrings(s, \'ba\')\n    \n    if ab_count == ba_count:\n        return s\n    \n    for i in range(len(s) - 1):\n        if s[i:i+2] == \'ab\' and ab_count > ba_count:\n            return s[:i] + \'b\' + s[i+1:]\n        elif s[i:i+2] == \'ab\' and ab_count < ba_count:\n            return s[:i] + \'a\' + s[i+1:]\n        elif s[i:i+2] == \'ba\' and ab_count < ba_count:\n            return s[:i] + \'a\' + s[i+1:]\n        elif s[i:i+2] == \'ba\' and ab_count > ba_count:\n            return s[:i] + \'b\' + s[i+1:]\n    \n    # If we reach here, it means we need to change the last character to balance the counts\n    return s[:-1] + (\'a\' if ab_count < ba_count else \'b\')\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        s = input().strip()\n        result = balance_substrings(s)\n        print(result)', 'def count_substrings(s, substring):\n    count = 0\n    for i in range(len(s) - len(substring) + 1):\n        if s[i:i+len(substring)] == substring:\n            count += 1\n    return count\n\ndef balance_substrings(s):\n    ab_count = count_substrings(s, "ab")\n    ba_count = count_substrings(s, "ba")\n    \n    if ab_count == ba_count:\n        return s\n    \n    for i in range(len(s) - 1):\n        if s[i:i+2] == "ab":\n            if ab_count > ba_count:\n                return s[:i] + "b" + s[i+1:]\n            else:\n                return s[:i] + "a" + s[i+1:]\n        elif s[i:i+2] == "ba":\n            if ba_count > ab_count:\n                return s[:i] + "a" + s[i+1:]\n            else:\n                return s[:i] + "b" + s[i+1:]\n    \n    # If no direct replacement can balance the counts, we can change the last character.\n    # This is a fallback and should not be needed if the input is well-formed.\n    return s[:-1] + ("a" if ab_count > ba_count else "b")\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    for _ in range(t):\n        s = input().strip()\n        result = balance_substrings(s)\n        print(result)', 'def count_substrings(s, substring):\n    count = 0\n    index = 0\n    while index < len(s):\n        index = s.find(substring, index)\n        if index == -1:\n            break\n        count += 1\n        index += 1\n    return count\n\ndef balance_substrings(s):\n    count_ab = count_substrings(s, \'ab\')\n    count_ba = count_substrings(s, \'ba\')\n    \n    if count_ab == count_ba:\n        return s\n    \n    for i in range(len(s) - 1):\n        if s[i] != s[i+1]:\n            # Check if flipping the current character will balance the counts\n            if s[i] == \'a\':\n                return s[:i] + \'b\' + s[i+1:] if count_ab > count_ba else s[:i] + \'a\' + s[i+1:]\n            else:\n                return s[:i] + \'a\' + s[i+1:] if count_ab > count_ba else s[:i] + \'b\' + s[i+1:]\n    # If no such position is found, return the string as is (though this should not happen based on the problem constraints)\n    return s\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    for _ in range(t):\n        s = input().strip()\n        results.append(balance_substrings(s))\n    \n    for result in results:\n        print(result)', 'def balance_ab_ba(s):\n    ab_count = s.count(\'ab\')\n    ba_count = s.count(\'ba\')\n    \n    if ab_count == ba_count:\n        return s\n    \n    for i in range(len(s) - 1):\n        if s[i:i+2] == \'ab\':\n            if ab_count > ba_count:\n                return s[:i] + \'b\' + s[i+1:]\n            else:\n                return s[:i] + \'a\' + s[i+1:]\n        elif s[i:i+2] == \'ba\':\n            if ba_count > ab_count:\n                return s[:i] + \'a\' + s[i+1:]\n            else:\n                return s[:i] + \'b\' + s[i+1:]\n    \n    # If we reach here, it means the string is too short to balance \'ab\' and \'ba\'\n    # In such cases, we can simply change the last character to balance them\n    return s[:-1] + (\'a\' if ab_count < ba_count else \'b\')\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        s = input()\n        result = balance_ab_ba(s)\n        print(result)', 'def min_steps_to_balance(s):\n    ab_count = s.count(\'ab\')\n    ba_count = s.count(\'ba\')\n    \n    if ab_count == ba_count:\n        return s\n    \n    for i in range(len(s) - 1):\n        if s[i] != s[i+1]:\n            if (s[i] == \'a\' and ab_count > ba_count) or (s[i] == \'b\' and ba_count > ab_count):\n                return s[:i] + (\'b\' if s[i] == \'a\' else \'a\') + s[i+1:]\n            elif (s[i+1] == \'a\' and ab_count > ba_count) or (s[i+1] == \'b\' and ba_count > ab_count):\n                return s[:i+1] + (\'b\' if s[i+1] == \'a\' else \'a\') + s[i+2:]\n    \n    # If no immediate change can balance the counts, make a change at the end\n    return s[:-1] + (\'b\' if s[-1] == \'a\' else \'a\')\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    for _ in range(t):\n        s = input().strip()\n        result = min_steps_to_balance(s)\n        print(result)', 'def count_occurrences(s, substring):\n    count = start = 0\n    while True:\n        start = s.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            break\n    return count\n\ndef balance_ab_ba(s):\n    ab_count = count_occurrences(s, \'ab\')\n    ba_count = count_occurrences(s, \'ba\')\n    \n    if ab_count == ba_count:\n        return s\n    \n    for i in range(len(s) - 1):\n        temp_s = s[:i] + (\'b\' if s[i] == \'a\' else \'a\') + s[i+1:]\n        if count_occurrences(temp_s, \'ab\') == count_occurrences(temp_s, \'ba\'):\n            return temp_s\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        s = input().strip()\n        results.append(balance_ab_ba(s))\n    \n    for result in results:\n        print(result)', 'def balance_ab_ba(s):\n    ab_count = s.count(\'ab\')\n    ba_count = s.count(\'ba\')\n    \n    if ab_count == ba_count:\n        return s\n    \n    for i in range(len(s) - 1):\n        if s[i:i+2] == \'ab\':\n            if ab_count > ba_count:\n                return s[:i] + \'b\' + s[i+1:]\n            else:\n                return s[:i] + \'a\' + s[i+1:]\n        elif s[i:i+2] == \'ba\':\n            if ba_count > ab_count:\n                return s[:i] + \'a\' + s[i+1:]\n            else:\n                return s[:i] + \'b\' + s[i+1:]\n    \n    # If we reach here, it means the string is too short to balance \'ab\' and \'ba\'\n    # In such cases, we can simply change the last character to balance them\n    return s[:-1] + (\'a\' if ab_count < ba_count else \'b\')\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        s = input()\n        result = balance_ab_ba(s)\n        print(result)', 'def min_steps_to_balance(s):\n    ab_count = s.count(\'ab\')\n    ba_count = s.count(\'ba\')\n    \n    if ab_count == ba_count:\n        return s\n    \n    for i in range(len(s) - 1):\n        if s[i] != s[i+1]:\n            if (s[i] == \'a\' and ab_count > ba_count) or (s[i] == \'b\' and ba_count > ab_count):\n                return s[:i] + (\'b\' if s[i] == \'a\' else \'a\') + s[i+1:]\n            elif (s[i+1] == \'a\' and ab_count > ba_count) or (s[i+1] == \'b\' and ba_count > ab_count):\n                return s[:i+1] + (\'b\' if s[i+1] == \'a\' else \'a\') + s[i+2:]\n    \n    # If no immediate change can balance the counts, make a change at the end\n    return s[:-1] + (\'b\' if s[-1] == \'a\' else \'a\')\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    for _ in range(t):\n        s = input().strip()\n        result = min_steps_to_balance(s)\n        print(result)', 'def count_occurrences(s, substring):\n    count = start = 0\n    while True:\n        start = s.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            break\n    return count\n\ndef balance_ab_ba(s):\n    ab_count = count_occurrences(s, \'ab\')\n    ba_count = count_occurrences(s, \'ba\')\n    \n    if ab_count == ba_count:\n        return s\n    \n    for i in range(len(s) - 1):\n        temp_s = s[:i] + (\'b\' if s[i] == \'a\' else \'a\') + s[i+1:]\n        if count_occurrences(temp_s, \'ab\') == count_occurrences(temp_s, \'ba\'):\n            return temp_s\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        s = input().strip()\n        results.append(balance_ab_ba(s))\n    \n    for result in results:\n        print(result)', 'def count_substrings(s, substring):\n    count = 0\n    for i in range(len(s) - len(substring) + 1):\n        if s[i:i+len(substring)] == substring:\n            count += 1\n    return count\n\ndef balance_substrings(s):\n    ab_count = count_substrings(s, "ab")\n    ba_count = count_substrings(s, "ba")\n    \n    if ab_count == ba_count:\n        return s\n    \n    for i in range(len(s) - 1):\n        if s[i:i+2] == "ab":\n            if ab_count > ba_count:\n                return s[:i] + "b" + s[i+1:]\n            else:\n                return s[:i] + "a" + s[i+1:]\n        elif s[i:i+2] == "ba":\n            if ba_count > ab_count:\n                return s[:i] + "a" + s[i+1:]\n            else:\n                return s[:i] + "b" + s[i+1:]\n    \n    # If no direct replacement can balance the counts, we can change the last character.\n    # This is a fallback and should not be needed if the input is well-formed.\n    return s[:-1] + ("a" if ab_count > ba_count else "b")\n\nif __name__ == "__main__":\n    t = int(input().strip())\n    for _ in range(t):\n        s = input().strip()\n        result = balance_substrings(s)\n        print(result)']
----------
['- name: \nGreedy Approach\n\n- content: \nTo solve this problem, we can follow these steps:\n1. Count the number of occurrences of "ab" and "ba" in the given string.\n2. If the counts are already equal, return the string as is.\n3. If the counts are not equal, determine which count is higher and identify the positions where changing a character can balance the counts.\n4. Make the minimum number of changes to balance the counts. If there are multiple positions to change, choose any to balance the counts.\n5. Return the modified string.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'substring occurrences\': The core concept is to count the number of times \'ab\' and \'ba\' appear as substrings within a given string.\n    Explanation: This is crucial for determining the minimum number of steps needed to make the counts equal by changing characters in the string.\n\n# [phrase showing quantity relationship]\n    \'more than\': Indicates that one count is greater than the other, requiring changes to balance them.\n    Explanation: For example, if \'ab\' appears 3 times and \'ba\' appears 1 time, we need to make at least 2 changes to balance them.\n\n# [degree adverb] \n    \'minimum\': Refers to the smallest number of changes needed to achieve balance between \'ab\' and \'ba\' occurrences.\n    Explanation: This suggests an efficient approach to solving the problem, likely involving a greedy or similar strategy.\n\n# [code logic]\n    The steps should be implemented sequentially as described:\n    1. Count the occurrences of \'ab\' and \'ba\'.\n    2. Check if they are already equal; if so, return the string.\n    3. Identify positions to change to balance the counts, making the minimum number of changes.\n\n# [edge case] \n    Edge case 1: "abbb"\n    Expected output: "bbbb"\n    Explanation: \n    - \\operatorname{AB}(s) = 1 (at index 1: "abbb")\n    - \\operatorname{BA}(s) = 0\n    - Change s_1 to \'a\' to make \\operatorname{BA}(s) = 1, resulting in "bbbb".\n\n    Edge case 2: "abbaab"\n    Expected output: "abbaaa"\n    Explanation: \n    - \\operatorname{AB}(s) = 2\n    - \\operatorname{BA}(s) = 1\n    - Change s_6 to \'a\' to make \\operatorname{BA}(s) = 2, resulting in "abbaaa".\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The logic provided in the plan can handle these cases directly.', '- name: \nCount and Adjust\n\n- content: \nTo solve this problem, we can follow these steps:\n1. Count the occurrences of "ab" and "ba" in the given string.\n2. Determine the difference between these counts.\n3. If the counts are already equal, return the string as is.\n4. If there is a difference, identify the positions where changing a character would most likely balance the counts.\n5. Make the necessary changes to achieve equal counts of "ab" and "ba".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'substring occurrences\': The core concept is to count and manipulate substrings ("ab" and "ba") within a string to achieve balance in their occurrences.\n    Explanation: This involves finding and potentially modifying the string to ensure the number of "ab" and "ba" substrings are equal.\n\n# [phrase showing quantity relationship]\n    \'more than\': Indicates that the counts of "ab" and "ba" need to be balanced, where one count is greater than the other.\n    Explanation: For example, if "ab" appears 3 times and "ba" appears 2 times, we need to make the counts equal by either reducing the count of "ab" or increasing the count of "ba".\n\n# [degree adverb] \n    \'minimum\': Suggests that we aim to make the counts equal with the fewest changes possible.\n    Explanation: This implies that we should look for the most efficient way to adjust the string to achieve balance, typically by changing the least number of characters.\n\n# [code logic]\n    The steps should be implemented sequentially as each step relies on the results of the previous ones.\n    - Count the occurrences of "ab" and "ba".\n    - Determine the difference between these counts.\n    - If the counts are not equal, identify positions to change characters to balance the counts.\n    - Make the necessary changes and return the adjusted string.\n\n# [edge case] \n    s = "abbb"\n    expected output = "bbbb"\n    Explanation:\n    - Initially, \\operatorname{AB}(s) = 1 and \\operatorname{BA}(s) = 0.\n    - Changing all characters to \'b\' will result in \\operatorname{AB}(s) = 0 and \\operatorname{BA}(s) = 4, achieving balance.\n\n    s = "abbaab"\n    expected output = "abbaaa"\n    Explanation:\n    - Initially, \\operatorname{AB}(s) = 2 and \\operatorname{BA}(s) = 1.\n    - Changing the last character of the first "ab" to \'a\' will result in \\operatorname{AB}(s) = 1 and \\operatorname{BA}(s) = 1, achieving balance.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle cases where the string is already balanced or where a single change can achieve balance.', '- name: \nDirect Replacement\n\n- content: \nAnother solution involves directly replacing characters to balance the counts. If the initial counts of "ab" and "ba" are not equal, find the first occurrence where changing a character would balance the counts. This can be done by iterating through the string and checking the counts before and after each potential change. Once a change is made, continue iterating to ensure all counts are balanced. This method ensures that we make the minimum number of changes to achieve the balanced state.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'substring occurrences\': The core concept is to count the number of times the substrings \'ab\' and \'ba\' appear in the given string.\n    Explanation: This is crucial because the goal is to make the counts of \'ab\' and \'ba\' equal by making the minimum number of changes to the string.\n\n# [phrase showing quantity relationship]\n    \'more than\': Indicates that the count of \'ab\' should be greater than the count of \'ba\'.\n    Explanation: This phrase shows the relationship between the two counts we need to balance.\n\n# [degree adverb] \n    \'minimum\': Indicates that we need to make the fewest possible changes to achieve the balance.\n    Explanation: This degree adverb emphasizes the efficiency of our approach.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - Iterate through the string to count the occurrences of \'ab\' and \'ba\'.\n    - Identify the first position where changing a character would balance the counts.\n    - Make the change and continue iterating to ensure all counts are balanced.\n\n# [edge case] \n    how_many_times(\'ab\', \'ba\') = 0\n    Explanation: If the initial counts of \'ab\' and \'ba\' are already equal, no changes are needed.\n    how_many_times(\'aabbbabaa\', \'abbb\') = 1\n    Explanation: The string \'aabbbabaa\' has 2 \'ab\' and 1 \'ba\'. Changing the last \'a\' to \'b\' will make both counts equal.\n    how_many_times(\'abbb\', \'abbaab\') = 1\n    Explanation: The string \'abbb\' has 1 \'ab\' and 1 \'ba\'. Changing the first \'a\' to \'b\' in the second string will make both counts equal.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the initial counts are already equal or where the first change balances the counts.\n    Example code:\n        if count_ab == count_ba:\n            return s\n        for i in range(len(s) - 1):\n            if s[i] != s[i+1]:\n                if count_ab > count_ba:\n                    return s[:i+1] + \'b\'*(len(s) - i - 1)\n                else:\n                    return s[:i+1] + \'a\'*(len(s) - i - 1)\n\nThis code checks if the counts are already equal and returns the string as is. If not, it finds the first position where changing a character would balance the counts and makes the necessary change.', '- name: \nGreedy Approach with String Manipulation\n\n- content: \nA more efficient approach is to analyze the string and make a greedy decision based on the first few characters. If the first character is \'a\', we can try changing subsequent \'b\'s to \'a\'s to see if it balances the counts. Conversely, if the first character is \'b\', we can try changing subsequent \'a\'s to \'b\'s. This approach reduces the complexity by directly manipulating the string based on initial observations.\n\nAlgorithm:\n1. Check the first character of the string.\n2. If the first character is \'a\', start changing \'b\'s to \'a\'s from the second character onwards.\n3. If the first character is \'b\', start changing \'a\'s to \'b\'s from the second character onwards.\n4. Continue until the counts of "ab" and "ba" are balanced.\n5. Return the modified string.\n\nThis solution ensures functional correctness by focusing on direct manipulation based on initial character analysis.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'string manipulation\': involves changing characters in a string to achieve a desired outcome, in this case, balancing the occurrences of "ab" and "ba".\n\n# [phrase showing quantity relationship]\n    \'as a substring\': indicates that we need to find occurrences of "ab" and "ba" within the string.\n\n# [degree adverb] \n    \'minimum number of steps\': means we need to find the least number of changes required to balance the counts.\n\n# [code logic]\n    The steps 2-4 should be considered simultaneously. We need to iterate through the string and make changes based on the first character.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [code logic]\n    The steps 2-4 should be considered simultaneously. We need to iterate through the string and make changes based on the first character.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.', '- name: \nGreedy Algorithm\n\n- content: \nWe can use a greedy approach to minimize the number of changes needed. The idea is to check the positions of \'a\' and \'b\' in the string and decide whether to change them to achieve balance.\n\nSteps:\n1. For each test case, iterate through the string to identify any imbalance between "ab" and "ba".\n2. If there is an imbalance, find the first occurrence where a \'b\' can be changed to \'a\' to increase "ab" occurrences and decrease "ba" occurrences, or vice versa.\n3. Perform the change and output the resulting string.\n4. If no imbalance is found, output the original string as it is already balanced.\n\nThis approach ensures functional correctness by focusing on immediate improvements and making decisions based on local properties of the string.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'Imbalance between "ab" and "ba" occurrences\': This is the core concept where the goal is to balance the number of "ab" and "ba" substrings in the given string.\n    Explanation: The requirement asks for the minimum number of steps to make the number of "ab" occurrences equal to the number of "ba" occurrences. This involves identifying positions where changing a character can help balance these counts.\n\n# [phrase showing quantity relationship]\n    \'more than\': This phrase indicates that we need to find situations where one count is greater than the other.\n    Explanation: For example, if "ab" occurrences are more, we need to find ways to increase "ab" and decrease "ba".\n\n# [degree adverb] \n    \'minimum\': This adverb indicates that we need to find the smallest number of changes required to balance the counts.\n    Explanation: We need to find the optimal way to change characters to achieve balance with the least number of changes.\n\n# [code logic]\n    The steps should be implemented sequentially as each step relies on the previous one to identify the necessary changes.\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    Explanation: \'\' appears four times in the original string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    \'Imbalance between "ab" and "ba" occurrences\': This is the core concept where the goal is to balance the number of "ab" and "ba" substrings in the given string.\n    Explanation: The requirement asks for the minimum number of steps to make the number of "ab" occurrences equal to the number of "ba" occurrences. This involves identifying positions where changing a character can help balance these counts.\n\n# [phrase showing quantity relationship]\n    \'more than\': This phrase indicates that we need to find situations where one count is greater than the other.\n    Explanation: For example, if "ab" occurrences are more, we need to find ways to increase "ab" and decrease "ba".\n\n# [degree adverb] \n    \'minimum\': This adverb indicates that we need to find the smallest number of changes required to balance the counts.\n    Explanation: We need to find the optimal way to change characters to achieve balance with the least number of changes.\n\n# [code logic]\n    The steps should be implemented sequentially as each step relies on the previous one to identify the necessary changes.\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    Explanation: \'\' appears four times in the original string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)', '- name: \nCount and Adjust\n\n- content: \nThis solution involves first counting the number of occurrences of "ab" and "ba" in the string. If they are already equal, no changes are needed. If they are not equal, the solution identifies the first index where changing a character can balance the counts and performs the change. The approach is as follows:\n1. Count the occurrences of "ab" and "ba".\n2. If they are already equal, return the string as is.\n3. If not, find the first index where changing a character can balance the counts.\n4. Change the character at that index to the one needed to balance the counts.\n5. Return the modified string.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'occurrences of substring\': means counting how many times a specific pattern appears in a string.\n    \'minimum number of steps\': means finding the smallest number of changes needed to achieve a certain condition.\n\n# [phrase showing quantity relationship]\n    \'as many times as\': means the number of occurrences of a substring should be equal to its value.\n\n# [degree adverb] \n    \'minimum\': means the smallest number of changes needed to achieve the goal.\n\n# [code logic]\n    The steps 1-5 should be implement simultaneously.\n    "Count the occurrences of \'ab\' and \'ba\'" and "find the first index where changing a character can balance the counts" and "change the character at that index" should be done in one code block to ensure the minimum number of steps.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    explanation: Both 2 and 3 appears at least as many times as themselves, but 3 is the largest number that meets the condition.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears at least as many times as itself, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    \'substring occurrences\': means counting how many times a specific pattern appears in a string.\n    \'minimum changes\': means finding the smallest number of changes needed to achieve a certain condition.\n\n# [phrase showing quantity relationship]\n    \'as many times as\': means the number of occurrences of a substring should be equal to its value.\n\n# [degree adverb] \n    \'minimum\': means the smallest number of changes needed to achieve the goal.\n\n# [code logic]\n    The steps 1-5 should be implement simultaneously.\n    "Count the occurrences of \'ab\' and \'ba\'" and "find the first index where changing a character can balance the counts" and "change the character at that index" should be done in one code block to ensure the minimum number of steps.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    explanation: Both 2 and 3 appears at least as many times as themselves, but 3 is the largest number that meets the condition.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears at least as many times as itself, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the condition.', '- name: \nGreedy Approach with String Manipulation\n\n- content: \nA more efficient approach is to analyze the string and make a greedy decision based on the first few characters. If the first character is \'a\', we can try changing subsequent \'b\'s to \'a\'s to see if it balances the counts. Conversely, if the first character is \'b\', we can try changing subsequent \'a\'s to \'b\'s. This approach reduces the complexity by directly manipulating the string based on initial observations.\n\nAlgorithm:\n1. Check the first character of the string.\n2. If the first character is \'a\', start changing \'b\'s to \'a\'s from the second character onwards.\n3. If the first character is \'b\', start changing \'a\'s to \'b\'s from the second character onwards.\n4. Continue until the counts of "ab" and "ba" are balanced.\n5. Return the modified string.\n\nThis solution ensures functional correctness by focusing on direct manipulation based on initial character analysis.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'string manipulation\': involves changing characters in a string to achieve a desired outcome, in this case, balancing the occurrences of "ab" and "ba".\n\n# [phrase showing quantity relationship]\n    \'as a substring\': indicates that we need to find occurrences of "ab" and "ba" within the string.\n\n# [degree adverb] \n    \'minimum number of steps\': means we need to find the least number of changes required to balance the counts.\n\n# [code logic]\n    The steps 2-4 should be considered simultaneously. We need to iterate through the string and make changes based on the first character.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [code logic]\n    The steps 2-4 should be considered simultaneously. We need to iterate through the string and make changes based on the first character.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.', '- name: \nGreedy Algorithm\n\n- content: \nWe can use a greedy approach to minimize the number of changes needed. The idea is to check the positions of \'a\' and \'b\' in the string and decide whether to change them to achieve balance.\n\nSteps:\n1. For each test case, iterate through the string to identify any imbalance between "ab" and "ba".\n2. If there is an imbalance, find the first occurrence where a \'b\' can be changed to \'a\' to increase "ab" occurrences and decrease "ba" occurrences, or vice versa.\n3. Perform the change and output the resulting string.\n4. If no imbalance is found, output the original string as it is already balanced.\n\nThis approach ensures functional correctness by focusing on immediate improvements and making decisions based on local properties of the string.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'Imbalance between "ab" and "ba" occurrences\': This is the core concept where the goal is to balance the number of "ab" and "ba" substrings in the given string.\n    Explanation: The requirement asks for the minimum number of steps to make the number of "ab" occurrences equal to the number of "ba" occurrences. This involves identifying positions where changing a character can help balance these counts.\n\n# [phrase showing quantity relationship]\n    \'more than\': This phrase indicates that we need to find situations where one count is greater than the other.\n    Explanation: For example, if "ab" occurrences are more, we need to find ways to increase "ab" and decrease "ba".\n\n# [degree adverb] \n    \'minimum\': This adverb indicates that we need to find the smallest number of changes required to balance the counts.\n    Explanation: We need to find the optimal way to change characters to achieve balance with the least number of changes.\n\n# [code logic]\n    The steps should be implemented sequentially as each step relies on the previous one to identify the necessary changes.\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    Explanation: \'\' appears four times in the original string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    \'Imbalance between "ab" and "ba" occurrences\': This is the core concept where the goal is to balance the number of "ab" and "ba" substrings in the given string.\n    Explanation: The requirement asks for the minimum number of steps to make the number of "ab" occurrences equal to the number of "ba" occurrences. This involves identifying positions where changing a character can help balance these counts.\n\n# [phrase showing quantity relationship]\n    \'more than\': This phrase indicates that we need to find situations where one count is greater than the other.\n    Explanation: For example, if "ab" occurrences are more, we need to find ways to increase "ab" and decrease "ba".\n\n# [degree adverb] \n    \'minimum\': This adverb indicates that we need to find the smallest number of changes required to balance the counts.\n    Explanation: We need to find the optimal way to change characters to achieve balance with the least number of changes.\n\n# [code logic]\n    The steps should be implemented sequentially as each step relies on the previous one to identify the necessary changes.\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times(\'abc\', \'\') = 4\n    Explanation: \'\' appears four times in the original string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)', '- name: \nCount and Adjust\n\n- content: \nThis solution involves first counting the number of occurrences of "ab" and "ba" in the string. If they are already equal, no changes are needed. If they are not equal, the solution identifies the first index where changing a character can balance the counts and performs the change. The approach is as follows:\n1. Count the occurrences of "ab" and "ba".\n2. If they are already equal, return the string as is.\n3. If not, find the first index where changing a character can balance the counts.\n4. Change the character at that index to the one needed to balance the counts.\n5. Return the modified string.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'occurrences of substring\': means counting how many times a specific pattern appears in a string.\n    \'minimum number of steps\': means finding the smallest number of changes needed to achieve a certain condition.\n\n# [phrase showing quantity relationship]\n    \'as many times as\': means the number of occurrences of a substring should be equal to its value.\n\n# [degree adverb] \n    \'minimum\': means the smallest number of changes needed to achieve the goal.\n\n# [code logic]\n    The steps 1-5 should be implement simultaneously.\n    "Count the occurrences of \'ab\' and \'ba\'" and "find the first index where changing a character can balance the counts" and "change the character at that index" should be done in one code block to ensure the minimum number of steps.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    explanation: Both 2 and 3 appears at least as many times as themselves, but 3 is the largest number that meets the condition.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears at least as many times as itself, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    \'substring occurrences\': means counting how many times a specific pattern appears in a string.\n    \'minimum changes\': means finding the smallest number of changes needed to achieve a certain condition.\n\n# [phrase showing quantity relationship]\n    \'as many times as\': means the number of occurrences of a substring should be equal to its value.\n\n# [degree adverb] \n    \'minimum\': means the smallest number of changes needed to achieve the goal.\n\n# [code logic]\n    The steps 1-5 should be implement simultaneously.\n    "Count the occurrences of \'ab\' and \'ba\'" and "find the first index where changing a character can balance the counts" and "change the character at that index" should be done in one code block to ensure the minimum number of steps.\n\n# [edge case] \n    search([1, 2, 2, 3, 3, 3, 4, 4, 4]) = 3\n    explanation: Both 2 and 3 appears at least as many times as themselves, but 3 is the largest number that meets the condition.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears at least as many times as itself, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the condition.', '- name: \nCount and Adjust\n\n- content: \nTo solve this problem, we can follow these steps:\n1. Count the occurrences of "ab" and "ba" in the given string.\n2. Determine the difference between these counts.\n3. If the counts are already equal, return the string as is.\n4. If there is a difference, identify the positions where changing a character would most likely balance the counts.\n5. Make the necessary changes to achieve equal counts of "ab" and "ba".\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'substring occurrences\': The core concept is to count and manipulate substrings ("ab" and "ba") within a string to achieve balance in their occurrences.\n    Explanation: This involves finding and potentially modifying the string to ensure the number of "ab" and "ba" substrings are equal.\n\n# [phrase showing quantity relationship]\n    \'more than\': Indicates that the counts of "ab" and "ba" need to be balanced, where one count is greater than the other.\n    Explanation: For example, if "ab" appears 3 times and "ba" appears 2 times, we need to make the counts equal by either reducing the count of "ab" or increasing the count of "ba".\n\n# [degree adverb] \n    \'minimum\': Suggests that we aim to make the counts equal with the fewest changes possible.\n    Explanation: This implies that we should look for the most efficient way to adjust the string to achieve balance, typically by changing the least number of characters.\n\n# [code logic]\n    The steps should be implemented sequentially as each step relies on the results of the previous ones.\n    - Count the occurrences of "ab" and "ba".\n    - Determine the difference between these counts.\n    - If the counts are not equal, identify positions to change characters to balance the counts.\n    - Make the necessary changes and return the adjusted string.\n\n# [edge case] \n    s = "abbb"\n    expected output = "bbbb"\n    Explanation:\n    - Initially, \\operatorname{AB}(s) = 1 and \\operatorname{BA}(s) = 0.\n    - Changing all characters to \'b\' will result in \\operatorname{AB}(s) = 0 and \\operatorname{BA}(s) = 4, achieving balance.\n\n    s = "abbaab"\n    expected output = "abbaaa"\n    Explanation:\n    - Initially, \\operatorname{AB}(s) = 2 and \\operatorname{BA}(s) = 1.\n    - Changing the last character of the first "ab" to \'a\' will result in \\operatorname{AB}(s) = 1 and \\operatorname{BA}(s) = 1, achieving balance.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan can handle cases where the string is already balanced or where a single change can achieve balance.']
----------
True
----------
2
multi-gen-prompt:
 
In fact, the problems E1 and E2 are quite distinct. It would be wise to treat them as separate entities.

You are provided with an integer array a[1 … n] = [a_1, a_2, …, a_n]. This array needs to be processed by adding its elements to an initially empty double-ended queue (deque). A deque is a versatile data structure that allows elements to be added to both the beginning and the end. 

For instance, if the deque currently contains the elements [3, 4, 4], adding

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
multi-gen-prompt:
 In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.

You are given an integer array a[1 … n] = [a_1, a_2, …, a_n]. Let us consider an empty deque (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. The elements of the array are sequentially added to the initially empty deque, starting with a_1 and finishing with a_n. Before adding each element to the deque,

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain descriptions of the test cases. 

The first line of each test case description contains an integer n (1 ≤ n ≤ 2 ⋅ 10^5) — array size. The second line of the description contains n space-separated integers a_i (-10^9 ≤ a_i ≤ 10^9) — elements of the array.

It is guaranteed that the sum of n over all test cases does not exceed 2 ⋅ 10^5.

Output

Print t lines, each line containing the answer to the corresponding test case. The answer to a test case should be a single integer — the minimal possible number of inversions in the deque after executing the described algorithm.

Example

Input


6
4
3 7 5 5
3
3 2 1
3
3 1 2
4
-1 2 2 -1
4
4 5 1 3
5
1 3 1 3 2


Output


2
0
1
0
1
2

Note

One of the ways to get the sequence [5, 3, 7, 5] in the deque, containing only two inversions, from the initial array [3, 7, 5, 5] (the first sample test case) is described in the problem statement. 

Also, in this example, you could get the answer of two inversions by simply putting each element of the original array at the end of the deque. In this case, the original sequence [3, 7, 5, 5], also containing exactly two inversions, will be in the deque as-is.
generating with deepseek-coder
----------
['def count_inversions(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        return merged, inv_left + inv_right + inv_merge\n    \n    def merge(left, right):\n        merged = []\n        inversions = 0\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inversions += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inversions\n    \n    _, inversions = merge_sort(arr)\n    return inversions\n\ndef f1(n, a):\n    deque = []\n    for num in a:\n        if not deque or num <= deque[0]:\n            deque.insert(0, num)\n        else:\n            deque.append(num)\n    return count_inversions(deque)\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(f1(n, a))\n    \n    for result in results:\n        print(result)', 'def count_inversions(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        return merged, inv_left + inv_right + inv_merge\n    \n    def merge(left, right):\n        merged = []\n        inversions = 0\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inversions += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inversions\n    \n    _, inversions = merge_sort(arr)\n    return inversions\n\ndef f1(n, a):\n    deque = []\n    for num in a:\n        if not deque or num <= deque[0]:\n            deque.insert(0, num)\n        else:\n            deque.append(num)\n    return count_inversions(deque)\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1: index + n + 1]))\n        index += n + 1\n        results.append(f1(n, a))\n    \n    for result in results:\n        print(result)', 'def count_inversions(arr):\n    n = len(arr)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions\n\ndef min_inversions_deque(arr):\n    n = len(arr)\n    min_inversions = float(\'inf\')\n    \n    # Add elements to the deque from both ends and count inversions\n    for i in range(n):\n        for j in range(n):\n            deque = arr[:i] + arr[i:j+1][::-1] + arr[j+1:]\n            inversions = count_inversions(deque)\n            min_inversions = min(min_inversions, inversions)\n    \n    return min_inversions\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        results.append(min_inversions_deque(arr))\n    \n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def count_inversions(arr):\n    # Function to count inversions in an array using merge sort\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        return merged, inv_left + inv_right + inv_merge\n    \n    def merge_and_count(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n    \n    _, inversions = merge_sort_and_count(arr)\n    return inversions\n\ndef min_inversions_deque(arr):\n    # Sort the array to determine the optimal order of adding elements\n    sorted_arr = sorted(arr)\n    n = len(arr)\n    # Calculate the number of inversions in the original array\n    original_inversions = count_inversions(arr)\n    \n    # Try adding elements alternately from the beginning and the end\n    min_inversions = original_inversions\n    for i in range(n):\n        # Add elements alternately from the beginning and the end\n        deque_elements = []\n        left = 0\n        right = n - 1\n        while left <= right:\n            if left == right:\n                deque_elements.append(arr[left])\n                left += 1\n            else:\n                if i % 2 == 0:\n                    deque_elements.append(arr[left])\n                    left += 1\n                else:\n                    deque_elements.append(arr[right])\n                    right -= 1\n        # Calculate the number of inversions in the current deque configuration\n        current_inversions = count_inversions(deque_elements)\n        # Update the minimum number of inversions found\n        min_inversions = min(min_inversions, current_inversions)\n    \n    return min_inversions\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index + n]))\n        index += n\n        results.append(min_inversions_deque(arr))\n    \n    for result in results:\n        print(result)', 'def count_inversions(arr):\n    inversions = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions\n\ndef solve(n, arr):\n    min_inversions = float(\'inf\')\n    for i in range(n):\n        for j in range(i, n):\n            deque = arr[:i] + arr[i:j+1][::-1] + arr[j+1:]\n            min_inversions = min(min_inversions, count_inversions(deque))\n    return min_inversions\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index + n]))\n        index += n\n        results.append(solve(n, arr))\n    \n    for result in results:\n        print(result)', 'def count_inversions(arr):\n    n = len(arr)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions\n\ndef min_inversions_deque(arr):\n    n = len(arr)\n    min_inversions = float(\'inf\')\n    \n    # Add elements to the deque from both ends and count inversions\n    for i in range(n):\n        for j in range(n):\n            deque = arr[:i] + arr[i:j+1][::-1] + arr[j+1:]\n            inversions = count_inversions(deque)\n            min_inversions = min(min_inversions, inversions)\n    \n    return min_inversions\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        results.append(min_inversions_deque(arr))\n    \n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def count_inversions(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        return merged, inv_left + inv_right + inv_merge\n    \n    def merge(left, right):\n        merged = []\n        inversions = 0\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inversions += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inversions\n    \n    _, inversions = merge_sort(arr)\n    return inversions\n\ndef f1(n, a):\n    deque = []\n    for num in a:\n        if not deque or num <= deque[0]:\n            deque.insert(0, num)\n        else:\n            deque.append(num)\n    return count_inversions(deque)\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1: index + n + 1]))\n        index += n + 1\n        results.append(f1(n, a))\n    \n    for result in results:\n        print(result)', 'def count_inversions(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        return merged, inv_left + inv_right + inv_merge\n    \n    def merge(left, right):\n        merged = []\n        inversions = 0\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inversions += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inversions\n    \n    _, inversions = merge_sort(arr)\n    return inversions\n\ndef f1(n, a):\n    deque = []\n    for num in a:\n        if not deque or num <= deque[0]:\n            deque.insert(0, num)\n        else:\n            deque.append(num)\n    return count_inversions(deque)\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1: index + n + 1]))\n        index += n + 1\n        results.append(f1(n, a))\n    \n    for result in results:\n        print(result)', 'def count_inversions(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        return merged, inv_left + inv_right + inv_merge\n    \n    def merge(left, right):\n        merged = []\n        inversions = 0\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inversions += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inversions\n    \n    _, inversions = merge_sort(arr)\n    return inversions\n\ndef f1(n, a):\n    deque = []\n    for num in a:\n        if not deque or num <= deque[0]:\n            deque.insert(0, num)\n        else:\n            deque.append(num)\n    return count_inversions(deque)\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index + 1: index + n + 1]))\n        index += n + 1\n        results.append(f1(n, a))\n    \n    for result in results:\n        print(result)', 'def count_inversions(arr):\n    n = len(arr)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions\n\ndef min_inversions_deque(arr):\n    n = len(arr)\n    min_inversions = float(\'inf\')\n    \n    # Add elements to the deque from both ends and count inversions\n    for i in range(n):\n        for j in range(n):\n            deque = arr[:i] + arr[i:j+1][::-1] + arr[j+1:]\n            inversions = count_inversions(deque)\n            min_inversions = min(min_inversions, inversions)\n    \n    return min_inversions\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        results.append(min_inversions_deque(arr))\n    \n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()']
----------
["- name: \nDynamic Programming\n\n- content: \nUse dynamic programming to solve the problem by considering subproblems where the state is defined by the current index in the array and the current state of the deque. Maintain a DP table where dp[i][j] represents the minimum number of inversions if we have processed the first `i` elements and the deque has `j` elements. Transition between states involves adding a new element to the deque either at the beginning or at the end, updating the inversion count accordingly. This approach ensures an optimal solution by considering all possible configurations of the deque.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'deque': a data structure that supports adding elements to both the beginning and the end.\n    Explanation: A deque is a double-ended queue that allows for efficient insertion and removal of elements from both ends. This is useful in scenarios where you need to manipulate data in a sequence that can grow or shrink from both ends.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan involves dynamically managing the deque and counting inversions. The steps should be implemented sequentially as each step builds upon the previous one.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: The array is already in ascending order, so no inversions are possible regardless of how the elements are added to the deque.\n    search([3, 2, 1]) = 3\n    Explanation: The array is in descending order, so every insertion will create an inversion. The optimal strategy would be to add elements alternately to the beginning and end of the deque to minimize inversions.\n    search([1, 3, 2]) = 1\n    Explanation: The array has one inversion (1, 2). The optimal strategy would be to add the smallest element (1) to the beginning and then add the largest element (3) to the end, leaving the middle element (2) as is.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases where the array is already sorted or in reverse order.\n        def count_inversions(arr):\n            if arr == sorted(arr):\n                return 0\n            elif arr == sorted(arr, reverse=True):\n                return len(arr) - 1\n            else:\n                # Additional logic to handle general cases\n                pass\n\n    This code checks if the array is sorted or in reverse order and returns the minimum number of inversions accordingly. For other cases, it would involve more complex dynamic programming logic as described in the plan.", "- name: \nBrute Force Simulation\n\n- content: \n- For each test case, generate all possible sequences that can be formed by inserting elements into the deque in all possible orders.\n- Count the number of inversions for each sequence.\n- Select the sequence with the minimum number of inversions as the result for that test case.\n- This approach is straightforward but may not be efficient for large inputs due to the factorial growth in possible sequences.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'deque': A double-ended queue that allows adding and removing elements from both ends.\n    Explanation: A deque is a data structure that supports adding and removing elements from both ends, providing flexibility in managing sequences.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The brute force simulation approach should be used to generate all possible sequences by inserting elements into the deque in all possible orders. For each sequence, count the number of inversions and select the one with the minimum number of inversions.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: The array [1, 2, 3] is already sorted in ascending order, so no matter how the elements are added to the deque, there will be no inversions.\n    search([3, 2, 1]) = 3\n    Explanation: The array [3, 2, 1] is sorted in descending order, so adding elements to the deque will always create inversions. The minimum number of inversions will be achieved by alternating the addition of elements to the beginning and end of the deque, resulting in 3 inversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The core logic of the brute force simulation will naturally handle these cases by considering all possible sequences and their inversions.", "- name: \nBrute Force Calculation\n\n- content: \nFor each test case, we can generate all possible permutations of the deque after adding all elements from the array. We then calculate the number of inversions for each permutation and select the one with the minimal number of inversions. This brute force approach ensures that we find the optimal configuration of the deque.\n\n**Steps:**\n1. For each test case, generate all permutations of the deque after adding all elements from the array.\n2. Calculate the number of inversions for each permutation.\n3. Select the permutation with the minimal number of inversions.\n4. Output the minimal number of inversions for the test case.\n\nThis solution is simple to implement but may not be efficient for large arrays due to the factorial growth of permutations.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'deque': a data structure that supports adding elements to both the beginning and the end.\n    'inversion': in the context of an array or list, an inversion is a pair of indices (i, j) such that i < j and a[i] > a[j].\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests generating all possible permutations of the deque after adding all elements from the array, which is computationally expensive for large arrays due to the factorial growth of permutations.\n\n# [edge case] \n    Edge case 1:\n    Input: [3, 7, 5, 5]\n    Explanation: The minimal number of inversions in any deque configuration is 2, as shown in the example provided.\n    Edge case 2:\n    Input: [3, 2, 1]\n    Explanation: The array is already sorted in descending order, so the deque will have no inversions, and the minimal number of inversions is 0.\n    Edge case 3:\n    Input: [3, 1, 2]\n    Explanation: The minimal number of inversions in any deque configuration is 1, as placing the smallest element (1) at the end minimizes the inversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the problem statement provides clear examples of minimal inversions for given inputs. The brute force approach is not efficient for large inputs and is not necessary to solve the edge cases.", "- name: \nBrute Force Simulation\n\n- content: \nThe brute force approach involves simulating all possible ways to add elements to the deque and counting the inversions for each scenario.\n\n**Solution Steps:**\n1. Generate all permutations of adding elements from the beginning or the end of the deque.\n2. For each permutation, calculate the number of inversions.\n3. Track the minimum number of inversions across all permutations.\n4. Return the minimum number of inversions found.\n\n**Edge Cases:**\n- Handle cases where the array is already sorted or sorted in reverse order.\n- Ensure that the solution is efficient enough to handle the maximum input size constraints by limiting the number of permutations generated based on performance considerations.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'deque': a data structure that supports adding elements to both the beginning and the end.\n    'inversion': a pair of indices (i, j) such that i < j and a_i > a_j.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach involves simulating all possible ways to add elements to the deque and counting the inversions for each scenario.\n    **Solution Steps:**\n    1. Generate all permutations of adding elements from the beginning or the end of the deque.\n    2. For each permutation, calculate the number of inversions.\n    3. Track the minimum number of inversions across all permutations.\n    4. Return the minimum number of inversions found.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 0\n    explanation: The array is already sorted, so no matter how elements are added to the deque, there will be no inversions.\n    search([4, 3, 2, 1]) = 6\n    explanation: The array is sorted in reverse order, so every possible permutation will result in 6 inversions (the maximum possible number of inversions for a sorted array of length 4).\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute force approach inherently handles sorted arrays by considering all permutations without additional logic.\n\n# [core concept]\n    'inversion': a pair of indices (i, j) such that i < j and a_i > a_j.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach involves simulating all possible ways to add elements to the deque and counting the inversions for each scenario.\n    **Solution Steps:**\n    1. Generate all permutations of adding elements from the beginning or the end of the deque.\n    2. For each permutation, calculate the number of inversions.\n    3. Track the minimum number of inversions across all permutations.\n    4. Return the minimum number of inversions found.\n\n# [edge case] \n    search([1, 3, 2, 4]) = 1\n    explanation: One of the optimal ways to add elements to the deque to minimize inversions is to add elements in the order [1, 4, 2, 3], which results in only 1 inversion.\n    search([-1, 2, 2, -1]) = 0\n    explanation: The array contains negative numbers and duplicates. The optimal way to add elements might not be immediately obvious, but by adding elements in the order that minimizes inversions, we can achieve 0 inversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute force approach inherently handles arrays with negative numbers and duplicates by considering all permutations without additional logic.\n\n# [core concept]\n    'inversion': a pair of indices (i, j) such that i < j and a_i > a_j.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The brute force approach involves simulating all possible ways to add elements to the deque and counting the inversions for each scenario.\n    **Solution Steps:**\n    1. Generate all permutations of adding elements from the beginning or the end of the deque.\n    2. For each permutation, calculate the number of inversions.\n    3. Track the minimum number of inversions across all permutations.\n    4. Return the minimum number of inversions found.\n\n# [edge case] \n    search([5, 5, 4, 4, 4]) = 1\n    explanation: One of the optimal ways to add elements to the deque to minimize inversions is to add elements in the order [4, 4, 4, 5, 5], which results in only 1 inversion.\n    search([1, 3, 1, 3, 2]) = 2\n    explanation: The array contains duplicates and requires careful consideration to minimize inversions when adding elements to the deque.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The brute force approach inherently handles arrays with duplicates by considering all permutations without additional logic.", "- name: \nBrute Force Simulation\n\n- content: \n- For each test case, simulate the entire process of adding elements to the deque from both ends.\n- Track the number of inversions in the deque after each insertion.\n- This approach involves generating all possible sequences of insertion and checking their inversion counts.\n- The minimal number of inversions found during this process is the answer for the test case.\n- This method ensures that we explore all possibilities but may be computationally expensive for large arrays.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'deque': a data structure that supports adding elements to both the beginning and the end.\n    'inversion': in an array, an inversion is a pair of indices (i, j) such that i < j and a[i] > a[j].\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The plan suggests simulating the process of adding elements to the deque from both ends, tracking the number of inversions after each insertion. This approach is brute force and involves generating all possible sequences of insertion and checking their inversion counts.\n\n# [edge case] \n    Edge case 1:\n    Input: 3\n        3\n        3 2 1\n    Output: 0\n    Explanation: The array is already sorted in descending order, so no inversions are present. Adding elements to the deque from both ends will not create any new inversions.\n\n    Edge case 2:\n    Input: 4\n        -1 2 2 -1\n    Output: 0\n    Explanation: The array contains equal elements, so no inversions are present. Adding elements to the deque from both ends will not create any new inversions.\n\n    Edge case 3:\n    Input: 5\n        1 3 1 3 2\n    Output: 2\n    Explanation: The array contains repeated elements, and adding elements to the deque from both ends can result in inversions. The minimal number of inversions is 2.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases, as the brute force simulation approach inherently handles them by exploring all possibilities. The edge cases provided are already covered by the simulation process.", "- name: \nBrute Force Calculation\n\n- content: \nFor each test case, we can generate all possible permutations of the deque after adding all elements from the array. We then calculate the number of inversions for each permutation and select the one with the minimal number of inversions. This brute force approach ensures that we find the optimal configuration of the deque.\n\n**Steps:**\n1. For each test case, generate all permutations of the deque after adding all elements from the array.\n2. Calculate the number of inversions for each permutation.\n3. Select the permutation with the minimal number of inversions.\n4. Output the minimal number of inversions for the test case.\n\nThis solution is simple to implement but may not be efficient for large arrays due to the factorial growth of permutations.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'deque': a data structure that supports adding elements to both the beginning and the end.\n    'inversion': in the context of an array or list, an inversion is a pair of indices (i, j) such that i < j and a[i] > a[j].\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests generating all possible permutations of the deque after adding all elements from the array, which is computationally expensive for large arrays due to the factorial growth of permutations.\n\n# [edge case] \n    Edge case 1:\n    Input: [3, 7, 5, 5]\n    Explanation: The minimal number of inversions in any deque configuration is 2, as shown in the example provided.\n    Edge case 2:\n    Input: [3, 2, 1]\n    Explanation: The array is already sorted in descending order, so the deque will have no inversions, and the minimal number of inversions is 0.\n    Edge case 3:\n    Input: [3, 1, 2]\n    Explanation: The minimal number of inversions in any deque configuration is 1, as placing the smallest element (1) at the end minimizes the inversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the problem statement provides clear examples of minimal inversions for given inputs. The brute force approach is not efficient for large inputs and is not necessary to solve the edge cases.", "- name: \nBrute Force Simulation\n\n- content: \n- For each test case, generate all possible sequences that can be formed by inserting elements into the deque in all possible orders.\n- Count the number of inversions for each sequence.\n- Select the sequence with the minimum number of inversions as the result for that test case.\n- This approach is straightforward but may not be efficient for large inputs due to the factorial growth in possible sequences.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'deque': A double-ended queue that allows adding and removing elements from both ends.\n    Explanation: A deque is a data structure that supports adding and removing elements from both ends, providing flexibility in managing sequences.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The brute force simulation approach should be used to generate all possible sequences by inserting elements into the deque in all possible orders. For each sequence, count the number of inversions and select the one with the minimum number of inversions.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: The array [1, 2, 3] is already sorted in ascending order, so no matter how the elements are added to the deque, there will be no inversions.\n    search([3, 2, 1]) = 3\n    Explanation: The array [3, 2, 1] is sorted in descending order, so adding elements to the deque will always create inversions. The minimum number of inversions will be achieved by alternating the addition of elements to the beginning and end of the deque, resulting in 3 inversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The core logic of the brute force simulation will naturally handle these cases by considering all possible sequences and their inversions.", "- name: \nBrute Force Simulation\n\n- content: \n- For each test case, generate all possible sequences that can be formed by inserting elements into the deque in all possible orders.\n- Count the number of inversions for each sequence.\n- Select the sequence with the minimum number of inversions as the result for that test case.\n- This approach is straightforward but may not be efficient for large inputs due to the factorial growth in possible sequences.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'deque': A double-ended queue that allows adding and removing elements from both ends.\n    Explanation: A deque is a data structure that supports adding and removing elements from both ends, providing flexibility in managing sequences.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The brute force simulation approach should be used to generate all possible sequences by inserting elements into the deque in all possible orders. For each sequence, count the number of inversions and select the one with the minimum number of inversions.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: The array [1, 2, 3] is already sorted in ascending order, so no matter how the elements are added to the deque, there will be no inversions.\n    search([3, 2, 1]) = 3\n    Explanation: The array [3, 2, 1] is sorted in descending order, so adding elements to the deque will always create inversions. The minimum number of inversions will be achieved by alternating the addition of elements to the beginning and end of the deque, resulting in 3 inversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The core logic of the brute force simulation will naturally handle these cases by considering all possible sequences and their inversions.", "- name: \nBrute Force Simulation\n\n- content: \n- For each test case, generate all possible sequences that can be formed by inserting elements into the deque in all possible orders.\n- Count the number of inversions for each sequence.\n- Select the sequence with the minimum number of inversions as the result for that test case.\n- This approach is straightforward but may not be efficient for large inputs due to the factorial growth in possible sequences.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'deque': A double-ended queue that allows adding and removing elements from both ends.\n    Explanation: A deque is a data structure that supports adding and removing elements from both ends, providing flexibility in managing sequences.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The brute force simulation approach should be used to generate all possible sequences by inserting elements into the deque in all possible orders. For each sequence, count the number of inversions and select the one with the minimum number of inversions.\n\n# [edge case] \n    search([1, 2, 3]) = 0\n    Explanation: The array [1, 2, 3] is already sorted in ascending order, so no matter how the elements are added to the deque, there will be no inversions.\n    search([3, 2, 1]) = 3\n    Explanation: The array [3, 2, 1] is sorted in descending order, so adding elements to the deque will always create inversions. The minimum number of inversions will be achieved by alternating the addition of elements to the beginning and end of the deque, resulting in 3 inversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The core logic of the brute force simulation will naturally handle these cases by considering all possible sequences and their inversions.", "- name: \nBrute Force Calculation\n\n- content: \nFor each test case, we can generate all possible permutations of the deque after adding all elements from the array. We then calculate the number of inversions for each permutation and select the one with the minimal number of inversions. This brute force approach ensures that we find the optimal configuration of the deque.\n\n**Steps:**\n1. For each test case, generate all permutations of the deque after adding all elements from the array.\n2. Calculate the number of inversions for each permutation.\n3. Select the permutation with the minimal number of inversions.\n4. Output the minimal number of inversions for the test case.\n\nThis solution is simple to implement but may not be efficient for large arrays due to the factorial growth of permutations.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'deque': a data structure that supports adding elements to both the beginning and the end.\n    'inversion': in the context of an array or list, an inversion is a pair of indices (i, j) such that i < j and a[i] > a[j].\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests generating all possible permutations of the deque after adding all elements from the array, which is computationally expensive for large arrays due to the factorial growth of permutations.\n\n# [edge case] \n    Edge case 1:\n    Input: [3, 7, 5, 5]\n    Explanation: The minimal number of inversions in any deque configuration is 2, as shown in the example provided.\n    Edge case 2:\n    Input: [3, 2, 1]\n    Explanation: The array is already sorted in descending order, so the deque will have no inversions, and the minimal number of inversions is 0.\n    Edge case 3:\n    Input: [3, 1, 2]\n    Explanation: The minimal number of inversions in any deque configuration is 1, as placing the smallest element (1) at the end minimizes the inversions.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the problem statement provides clear examples of minimal inversions for given inputs. The brute force approach is not efficient for large inputs and is not necessary to solve the edge cases."]
----------
False
----------
0
multi-gen-prompt:
 Polycarp has come up with a new game to play with you. He calls it "A missing bigram". A bigram of a word is a sequence of two adjacent letters in it. For example, word "abbaaba" contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba". The game goes as follows. First, Polycarp comes up with a word, consisting only of lowercase letters 'a' and 'b'. Then, he writes down all its bigrams on a whiteboard in the same order as they appear in the word. After that, he

Input

The first line contains a single integer t (1 ≤ t ≤ 2000) — the number of testcases.

The first line of each testcase contains a single integer n (3 ≤ n ≤ 100) — the length of the word Polycarp has come up with.

The second line of each testcase contains n-2 bigrams of that word, separated by a single space. Each bigram consists of two letters, each of them is either 'a' or 'b'.

Additional constraint on the input: there exists at least one string such that it is possible to write down all its bigrams, except one, so that the resulting sequence is the same as the sequence in the input. In other words, the answer exists.

Output

For each testcase print a word, consisting of n letters, each of them should be either 'a' or 'b'. It should be possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them. 

Example

Input


4
7
ab bb ba aa ba
7
ab ba aa ab ba
3
aa
5
bb ab bb


Output


abbaaba
abaabaa
baa
bbabb

Note

The first two testcases from the example are produced from the word "abbaaba". As listed in the statement, it contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

In the first testcase, the 5-th bigram is removed. 

In the second testcase, the 2-nd bigram is removed. However, that sequence could also have been produced from the word "abaabaa". It contains bigrams "ab", "ba", "aa", "ab", "ba" and "aa". The missing bigram is the 6-th one.

In the third testcase, all of "baa", "aab" and "aaa" are valid answers.
multi-gen-prompt:
 Polycarp has come up with a new game to play with you. He calls it "A missing bigram". A bigram of a word is a sequence of two adjacent letters in it. For example, word "abbaaba" contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba". The game goes as follows. First, Polycarp comes up with a word, consisting only of lowercase letters 'a' and 'b'. Then, he writes down all its bigrams on a whiteboard in the same order as they appear in the word. After that, he

Input

The first line contains a single integer t (1 ≤ t ≤ 2000) — the number of testcases.

The first line of each testcase contains a single integer n (3 ≤ n ≤ 100) — the length of the word Polycarp has come up with.

The second line of each testcase contains n-2 bigrams of that word, separated by a single space. Each bigram consists of two letters, each of them is either 'a' or 'b'.

Additional constraint on the input: there exists at least one string such that it is possible to write down all its bigrams, except one, so that the resulting sequence is the same as the sequence in the input. In other words, the answer exists.

Output

For each testcase print a word, consisting of n letters, each of them should be either 'a' or 'b'. It should be possible to write down all its bigrams and remove one of them, so that the resulting sequence of bigrams is the same as the one Polycarp ended up with.

The tests are generated in such a way that the answer exists. If there are multiple answers, you can print any of them. 

Example

Input


4
7
ab bb ba aa ba
7
ab ba aa ab ba
3
aa
5
bb ab bb


Output


abbaaba
abaabaa
baa
bbabb

Note

The first two testcases from the example are produced from the word "abbaaba". As listed in the statement, it contains bigrams "ab", "bb", "ba", "aa", "ab" and "ba".

In the first testcase, the 5-th bigram is removed. 

In the second testcase, the 2-nd bigram is removed. However, that sequence could also have been produced from the word "abaabaa". It contains bigrams "ab", "ba", "aa", "ab", "ba" and "aa". The missing bigram is the 6-th one.

In the third testcase, all of "baa", "aab" and "aaa" are valid answers.
generating with deepseek-coder
----------
['def reconstruct_word(bigrams, n):\n    word = bigrams[0]\n    for bigram in bigrams[1:]:\n        if bigram[0] == word[-1]:\n            word += bigram[1]\n        else:\n            word += bigram[0]\n    # Ensure the final word length matches n\n    return word + bigrams[-1][1] if len(word) < n else word\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        bigrams = input().split()\n        word = reconstruct_word(bigrams, n)\n        results.append(word)\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def reconstruct_word(bigrams, n):\n    word = list(bigrams[0][0])  # Start with the first character of the first bigram\n    for bigram in bigrams:\n        if bigram[0] == word[-1]:\n            word.append(bigram[1])  # Append the second character of the bigram if it matches the last character of the current word\n        else:\n            word.append(bigram[0])  # Otherwise, append the first character of the bigram\n    \n    # Ensure the final word length matches n\n    while len(word) < n:\n        last_bigram = bigrams[-1]\n        if last_bigram[0] == word[-1]:\n            word.append(last_bigram[1])  # Append the second character of the last bigram\n        else:\n            word.append(last_bigram[0])  # Otherwise, append the first character of the last bigram\n    \n    return \'\'.join(word)\n\ndef main():\n    t = int(input())  # Read the number of test cases\n    results = []\n    for _ in range(t):\n        n = int(input())  # Read the length of the word\n        bigrams = input().split()  # Read the bigrams\n        results.append(reconstruct_word(bigrams, n))  # Reconstruct the word and add it to the results list\n    for result in results:\n        print(result)  # Print each reconstructed word\n\nif __name__ == "__main__":\n    main()', 'def find_missing_letter(n, bigrams):\n    # Initialize the word with the first bigram\n    word = bigrams[0]\n    \n    # Check each bigram to find the missing letter\n    for bigram in bigrams[1:]:\n        if word[-1] == bigram[0]:\n            word += bigram[1]\n        else:\n            word += bigram[0]\n    \n    # If the last letter is not part of the last bigram, add it\n    if len(word) < n:\n        word += bigrams[-1][1]\n    \n    return word\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        bigrams = input().split()\n        # Find the missing letter and reconstruct the word\n        word = find_missing_letter(n, bigrams)\n        results.append(word)\n    # Print all results\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def f1(n, bigrams):\n    # Initialize the full word with the first bigram\n    full_word = bigrams[0]\n    \n    # Check the possible continuations of the sequence\n    for bigram in bigrams:\n        if full_word[-1] == bigram[0]:\n            full_word += bigram[1]\n        else:\n            full_word += bigram\n    \n    return full_word\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    \n    for _ in range(t):\n        n = int(input())\n        bigrams = input().split()\n        results.append(f1(n, bigrams))\n    \n    for result in results:\n        print(result)', 'def is_valid_word(word, bigrams):\n    generated_bigrams = []\n    for i in range(len(word) - 1):\n        generated_bigrams.append(word[i:i+2])\n    return generated_bigrams == bigrams\n\ndef reconstruct_word(bigrams):\n    possible_letters = [\'a\', \'b\']\n    n = len(bigrams) + 2  # The length of the original word\n    word = bigrams[0]  # Start with the first bigram\n    \n    # Try to find the second letter of the first bigram in the remaining bigrams\n    for i in range(1, len(bigrams)):\n        if bigrams[i][0] == word[-1]:\n            word += bigrams[i][1]\n        else:\n            word += bigrams[i][0]\n    \n    # Add the last letter to complete the word\n    word += bigrams[-1][1]\n    \n    return word\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        bigrams = input().split()\n        print(reconstruct_word(bigrams))', 'def reconstruct_word(bigrams, n):\n    word = list(bigrams[0][0])  # Start with the first character of the first bigram\n    for bigram in bigrams:\n        if bigram[0] == word[-1]:\n            word.append(bigram[1])  # Append the second character of the bigram if it matches the last character of the current word\n        else:\n            word.append(bigram[0])  # Otherwise, append the first character of the bigram\n    \n    # Ensure the final word length matches n\n    while len(word) < n:\n        last_bigram = bigrams[-1]\n        if last_bigram[0] == word[-1]:\n            word.append(last_bigram[1])  # Append the second character of the last bigram\n        else:\n            word.append(last_bigram[0])  # Otherwise, append the first character of the last bigram\n    \n    return \'\'.join(word)\n\ndef main():\n    t = int(input())  # Read the number of test cases\n    results = []\n    for _ in range(t):\n        n = int(input())  # Read the length of the word\n        bigrams = input().split()  # Read the bigrams\n        results.append(reconstruct_word(bigrams, n))  # Reconstruct the word and add it to the results list\n    for result in results:\n        print(result)  # Print each reconstructed word\n\nif __name__ == "__main__":\n    main()', 'def reconstruct_word(bigrams, n):\n    word = list(bigrams[0][0])  # Start with the first character of the first bigram\n    for bigram in bigrams:\n        if bigram[0] == word[-1]:\n            word.append(bigram[1])  # Append the second character of the bigram if it matches the last character of the current word\n        else:\n            word.append(bigram[0])  # Otherwise, append the first character of the bigram\n    \n    # Ensure the final word length matches n\n    while len(word) < n:\n        last_bigram = bigrams[-1]\n        if last_bigram[0] == word[-1]:\n            word.append(last_bigram[1])  # Append the second character of the last bigram\n        else:\n            word.append(last_bigram[0])  # Otherwise, append the first character of the last bigram\n    \n    return \'\'.join(word)\n\ndef main():\n    t = int(input())  # Read the number of test cases\n    results = []\n    for _ in range(t):\n        n = int(input())  # Read the length of the word\n        bigrams = input().split()  # Read the bigrams\n        results.append(reconstruct_word(bigrams, n))  # Reconstruct the word and add it to the results list\n    for result in results:\n        print(result)  # Print each reconstructed word\n\nif __name__ == "__main__":\n    main()', 'def reconstruct_word(bigrams, n):\n    word = list(bigrams[0][0])  # Start with the first character of the first bigram\n    for bigram in bigrams:\n        if bigram[0] == word[-1]:\n            word.append(bigram[1])  # Append the second character of the bigram if it matches the last character of the current word\n        else:\n            word.append(bigram[0])  # Otherwise, append the first character of the bigram\n    \n    # Ensure the final word length matches n\n    while len(word) < n:\n        last_bigram = bigrams[-1]\n        if last_bigram[0] == word[-1]:\n            word.append(last_bigram[1])  # Append the second character of the last bigram\n        else:\n            word.append(last_bigram[0])  # Otherwise, append the first character of the last bigram\n    \n    return \'\'.join(word)\n\ndef main():\n    t = int(input())  # Read the number of test cases\n    results = []\n    for _ in range(t):\n        n = int(input())  # Read the length of the word\n        bigrams = input().split()  # Read the bigrams\n        results.append(reconstruct_word(bigrams, n))  # Reconstruct the word and add it to the results list\n    for result in results:\n        print(result)  # Print each reconstructed word\n\nif __name__ == "__main__":\n    main()', 'def f1(n, bigrams):\n    # Initialize the full word with the first bigram\n    full_word = bigrams[0]\n    \n    # Check the possible continuations of the sequence\n    for bigram in bigrams:\n        if full_word[-1] == bigram[0]:\n            full_word += bigram[1]\n        else:\n            full_word += bigram\n    \n    return full_word\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    \n    for _ in range(t):\n        n = int(input())\n        bigrams = input().split()\n        results.append(f1(n, bigrams))\n    \n    for result in results:\n        print(result)', 'def f1(n, bigrams):\n    # Initialize the full word with the first bigram\n    full_word = bigrams[0]\n    \n    # Check the possible continuations of the sequence\n    for bigram in bigrams:\n        if full_word[-1] == bigram[0]:\n            full_word += bigram[1]\n        else:\n            full_word += bigram\n    \n    return full_word\n\nif __name__ == "__main__":\n    t = int(input())\n    results = []\n    \n    for _ in range(t):\n        n = int(input())\n        bigrams = input().split()\n        results.append(f1(n, bigrams))\n    \n    for result in results:\n        print(result)']
----------
['- name: \nGreedy Solution\n\n- content: \nWe can use a greedy approach to reconstruct the word by leveraging the properties of bigrams. We know that each bigram is formed by two adjacent letters in the word. We can start by assuming the first bigram and then iteratively build the word by adding letters based on the subsequent bigrams.\n\nSteps:\n1. For each test case, read the number of bigrams (n-2) and the bigrams themselves.\n2. Start with the first bigram to determine the first two letters of the word.\n3. For each subsequent bigram, determine the next letter in the word based on the current sequence of letters.\n4. Continue this process until the full word is reconstructed.\n5. Output the reconstructed word.\n\nThis solution is efficient and works well for small to medium-sized inputs.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bigrams\': sequences of two adjacent letters in a word\n    Explanation: In the context of the problem, bigrams are important because they are the basic building blocks of the word. By reconstructing the word from its bigrams, we can determine the order and presence of each letter in the word.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implemented sequentially. Each bigram provides information about the next letter in the sequence, so we need to build the word letter by letter based on the bigrams.\n\n# [edge case] \n    Testcase:\n        3\n        3\n        aa\n        5\n        bb ab bb\n\n    Expected Output:\n        baa\n        bbabb\n\n    Explanation:\n        For the first testcase, the only bigram is "aa". This means the word must be "baa" because the only way to fit "aa" as a bigram in a sequence is to have "b" followed by "a" and then "a".\n        \n        For the second testcase, the bigrams are "bb", "ab", and "bb". We start with "b" (from "bb"), then "a" (from "ab"), and finally "b" (from the last "bb"). Thus, the word is "bbabb".\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the problem guarantees that a valid word exists based on the given bigrams. The steps provided in the plan are sufficient to reconstruct the word.', '- name: \nBrute Force with Backtracking\n\n- content: \nGenerate all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams and check which one matches the given bigrams.\n\nSolution Approach:\n1. For each test case, read the number of bigrams and the bigrams themselves.\n2. Generate all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams.\n3. Check which one matches the given bigrams.\n4. Output the matching word.\n\nThis brute force approach ensures functional correctness by considering all possible combinations of \'a\' and \'b\' to fill in the missing letters.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bigram\': a sequence of two adjacent letters in a word\n    \'possible word\': a word that can be formed by filling in the missing letters between the given bigrams\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship\n\n# [degree adverb] \n    No specific degree adverb\n\n# [code logic]\n    The plan suggests generating all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams and checking which one matches the given bigrams.\n\n# [edge case] \n    Testcase with 3 bigrams: ["aa"]\n    Expected Output: "ba" or "ab"\n    Explanation: There are only two possible words that can be formed: "ba" and "ab". Both will match the given bigram "aa".\n\n    Testcase with 5 bigrams: ["bb", "ab", "bb"]\n    Expected Output: "bbabb" or "babbb"\n    Explanation: There are multiple possible words that can be formed, such as "bbabb" and "babbb", which will match the given bigrams.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case as the problem guarantees that a valid word exists.\n\n# [edge case] \n    Testcase with 3 bigrams: ["aa"]\n    Expected Output: "ba" or "ab"\n    Explanation: There are only two possible words that can be formed: "ba" and "ab". Both will match the given bigram "aa".\n\n    Testcase with 5 bigrams: ["bb", "ab", "bb"]\n    Expected Output: "bbabb" or "babbb"\n    Explanation: There are multiple possible words that can be formed, such as "bbabb" and "babbb", which will match the given bigrams.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case as the problem guarantees that a valid word exists.', '- name: \nGreedy Approach with Simulation\n\n- content: \nFor each test case, we will:\n1. Start with the first bigram as the initial part of the word.\n2. For each subsequent bigram, append the second character of the bigram to the current word.\n3. Identify the missing letter by checking the possible continuations of the sequence.\n4. Insert the missing letter to complete the word.\n5. Output the constructed word.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bigram\': A sequence of two adjacent letters in a word.\n    Explanation: In the context of the problem, a bigram is a pair of consecutive characters that form a distinct unit within the word. For example, in the word "abbaaba", the bigrams are "ab", "bb", "ba", "aa", "ab", and "ba".\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    The steps should be implemented sequentially as described in the plan.\n\n# [edge case] \n    Edge case 1:\n    Input: 7\n    bigrams: ab ba aa ab ba\n    Explanation: The word could be "abbaaba" or "abaabaa". The missing bigram is the 5th one in the sequence "abbaaba".\n    Expected output: abbaaba\n\n    Edge case 2:\n    Input: 7\n    bigrams: ab ba aa ab ba\n    Explanation: The word could be "abbaaba" or "abaabaa". The missing bigram is the 6th one in the sequence "abaabaa".\n    Expected output: abaabaa\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the problem guarantees the existence of a valid word.\n\n# [core concept]\n    \'word\': A sequence of letters.\n    Explanation: In the context of the problem, a word is a sequence of lowercase letters \'a\' and \'b\' that we need to reconstruct based on the given bigrams.\n\n# [phrase showing quantity relationship]\n    \'n-2\': This indicates that we are given n-2 bigrams for a word of length n.\n    Explanation: Since we need to reconstruct a word of length n, and we are given n-2 bigrams, we can infer that the word must have n-2+2 = n letters.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    The plan suggests a greedy approach where we start with the first bigram and build the word by appending the second character of each subsequent bigram.\n\n# [edge case] \n    Edge case 1:\n    Input: 3\n    bigrams: aa\n    Explanation: The word must be "baa", "aab", or "aaa". The missing bigram is the 3rd one in the sequence "baa".\n    Expected output: baa\n\n    Edge case 2:\n    Input: 5\n    bigrams: bb ab bb\n    Explanation: The word could be "bbabb" or "babbb". The missing bigram is the 4th one in the sequence "bbabb".\n    Expected output: bbabb\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the problem guarantees the existence of a valid word.', '- name: \nBrute Force Solution\n\n- content: \nFor each test case, we will try all possible combinations of \'a\' and \'b\' to fill in the missing letter between the bigrams. We will check if the resulting sequence matches the given bigrams. If a match is found, we will output the sequence as the full word.\n\nHere\'s the step-by-step approach:\n1. For each test case, generate all possible combinations of \'a\' and \'b\' for the missing letter.\n2. Insert the missing letter into the sequence of bigrams to form potential words.\n3. Check if the resulting word matches the given bigrams.\n4. If a match is found, output the word as the solution.\n\nThis brute force solution ensures functional correctness by trying all possible combinations and checking for matches with the given bigrams.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bigrams\': sequences of two adjacent letters in a word\n    Explanation: In the context of the problem, a bigram is a pair of consecutive characters in a word. For example, in the word "abbaaba", the bigrams are "ab", "bb", "ba", "aa", "ab", and "ba".\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    The plan suggests generating all possible combinations of \'a\' and \'b\' for the missing letter and checking if the resulting sequence matches the given bigrams. This can be efficiently implemented by iterating through the possible positions for the missing letter and constructing the word accordingly.\n\n# [edge case] \n    Testcase 1:\n    Input: 7\n    bigrams: ab bb ba aa ba\n    Expected Output: abbaaba\n    Explanation: The word "abbaaba" contains the given bigrams in order. The missing bigram is the 5th one, which is "ba".\n\n    Testcase 2:\n    Input: 7\n    bigrams: ab ba aa ab ba\n    Expected Output: abaabaa\n    Explanation: The word "abaabaa" contains the given bigrams in order. The missing bigram is the 6th one, which is "aa".\n\n    Testcase 3:\n    Input: 3\n    bigrams: aa\n    Expected Output: baa\n    Explanation: The word "baa" contains the given bigram "aa". The missing bigram is the first one, which is "aa".\n\n    Testcase 4:\n    Input: 5\n    bigrams: bb ab bb\n    Expected Output: bbabb\n    Explanation: The word "bbabb" contains the given bigrams in order. The missing bigram is the 4th one, which is "ab".\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The brute force solution inherently covers all possible cases by trying all combinations and checking for matches.', '- name: \nBrute Force with All Possible Insertions\n\n- content: \nWe can iterate through all possible positions where the missing bigram could be inserted and check if the resulting sequence of bigrams matches the given sequence. If it does, we return the reconstructed word. This method ensures that we find a valid word by trying all possible insertions.\n\nExample solution for a single test case:\n```python\ndef is_valid_word(word, bigrams):\n    generated_bigrams = []\n    for i in range(len(word) - 1):\n        generated_bigrams.append(word[i:i+2])\n    return generated_bigrams == bigrams\n\ndef reconstruct_word(bigrams):\n    possible_letters = [\'a\', \'b\']\n    for i in range(len(bigrams) + 1):\n        for letter1 in possible_letters:\n            for letter2 in possible_letters:\n                word = bigrams[0][0] if i == 0 else \'\'\n                word += letter1 if i == 0 else \'\'\n                for j in range(len(bigrams)):\n                    word += bigrams[j]\n                    if j == len(bigrams) - 1 and i == len(bigrams):\n                        continue\n                    word += letter2 if j + 1 == i else \'\'\n                if is_valid_word(word, bigrams):\n                    return word\n    return \'\'\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    bigrams = input().split()\n    print(reconstruct_word(bigrams))\n```\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bigram\': A sequence of two adjacent letters in a word.\n    Explanation: In the context of the problem, a bigram is a pair of consecutive characters in a word. For example, in the word "abbaaba", the bigrams are "ab", "bb", "ba", "aa", "ab", and "ba".\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    The plan suggests iterating through all possible positions where the missing bigram could be inserted and checking if the resulting sequence of bigrams matches the given sequence. This can be done by generating all possible words by inserting the missing bigram at every possible position and then checking if the generated bigrams match the input bigrams.\n\n# [edge case] \n    Edge case 1:\n    Input: ["ab", "bb", "ba", "aa", "ba"]\n    Explanation: The word could be "abbaaba" where the missing bigram is "aa". The resulting sequence of bigrams after removing "aa" is ["ab", "bb", "ba", "ab", "ba"], which matches the input.\n\n    Edge case 2:\n    Input: ["ab", "ba", "aa", "ab", "ba"]\n    Explanation: The word could be "abaabaa" where the missing bigram is "ab". The resulting sequence of bigrams after removing "ab" is ["ab", "ba", "aa", "ab", "ba"], which matches the input.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The brute force approach with all possible insertions ensures that we find a valid word by trying all possible insertions.\n\n# Example solution for a single test case:\n```python\ndef is_valid_word(word, bigrams):\n    generated_bigrams = []\n    for i in range(len(word) - 1):\n        generated_bigrams.append(word[i:i+2])\n    return generated_bigrams == bigrams\n\ndef reconstruct_word(bigrams):\n    possible_letters = [\'a\', \'b\']\n    for i in range(len(bigrams) + 1):\n        for letter1 in possible_letters:\n            for letter2 in possible_letters:\n                word = bigrams[0][0] if i == 0 else \'\'\n                word += letter1 if i == 0 else \'\'\n                for j in range(len(bigrams)):\n                    word += bigrams[j]\n                    if j == len(bigrams) - 1 and i == len(bigrams):\n                        continue\n                    word += letter2 if j + 1 == i else \'\'\n                if is_valid_word(word, bigrams):\n                    return word\n    return \'\'\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    bigrams = input().split()\n    print(reconstruct_word(bigrams))\n```', '- name: \nBrute Force with Backtracking\n\n- content: \nGenerate all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams and check which one matches the given bigrams.\n\nSolution Approach:\n1. For each test case, read the number of bigrams and the bigrams themselves.\n2. Generate all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams.\n3. Check which one matches the given bigrams.\n4. Output the matching word.\n\nThis brute force approach ensures functional correctness by considering all possible combinations of \'a\' and \'b\' to fill in the missing letters.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bigram\': a sequence of two adjacent letters in a word\n    \'possible word\': a word that can be formed by filling in the missing letters between the given bigrams\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship\n\n# [degree adverb] \n    No specific degree adverb\n\n# [code logic]\n    The plan suggests generating all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams and checking which one matches the given bigrams.\n\n# [edge case] \n    Testcase with 3 bigrams: ["aa"]\n    Expected Output: "ba" or "ab"\n    Explanation: There are only two possible words that can be formed: "ba" and "ab". Both will match the given bigram "aa".\n\n    Testcase with 5 bigrams: ["bb", "ab", "bb"]\n    Expected Output: "bbabb" or "babbb"\n    Explanation: There are multiple possible words that can be formed, such as "bbabb" and "babbb", which will match the given bigrams.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case as the problem guarantees that a valid word exists.\n\n# [edge case] \n    Testcase with 3 bigrams: ["aa"]\n    Expected Output: "ba" or "ab"\n    Explanation: There are only two possible words that can be formed: "ba" and "ab". Both will match the given bigram "aa".\n\n    Testcase with 5 bigrams: ["bb", "ab", "bb"]\n    Expected Output: "bbabb" or "babbb"\n    Explanation: There are multiple possible words that can be formed, such as "bbabb" and "babbb", which will match the given bigrams.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case as the problem guarantees that a valid word exists.', '- name: \nBrute Force with Backtracking\n\n- content: \nGenerate all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams and check which one matches the given bigrams.\n\nSolution Approach:\n1. For each test case, read the number of bigrams and the bigrams themselves.\n2. Generate all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams.\n3. Check which one matches the given bigrams.\n4. Output the matching word.\n\nThis brute force approach ensures functional correctness by considering all possible combinations of \'a\' and \'b\' to fill in the missing letters.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bigram\': a sequence of two adjacent letters in a word\n    \'possible word\': a word that can be formed by filling in the missing letters between the given bigrams\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship\n\n# [degree adverb] \n    No specific degree adverb\n\n# [code logic]\n    The plan suggests generating all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams and checking which one matches the given bigrams.\n\n# [edge case] \n    Testcase with 3 bigrams: ["aa"]\n    Expected Output: "ba" or "ab"\n    Explanation: There are only two possible words that can be formed: "ba" and "ab". Both will match the given bigram "aa".\n\n    Testcase with 5 bigrams: ["bb", "ab", "bb"]\n    Expected Output: "bbabb" or "babbb"\n    Explanation: There are multiple possible words that can be formed, such as "bbabb" and "babbb", which will match the given bigrams.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case as the problem guarantees that a valid word exists.\n\n# [edge case] \n    Testcase with 3 bigrams: ["aa"]\n    Expected Output: "ba" or "ab"\n    Explanation: There are only two possible words that can be formed: "ba" and "ab". Both will match the given bigram "aa".\n\n    Testcase with 5 bigrams: ["bb", "ab", "bb"]\n    Expected Output: "bbabb" or "babbb"\n    Explanation: There are multiple possible words that can be formed, such as "bbabb" and "babbb", which will match the given bigrams.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case as the problem guarantees that a valid word exists.', '- name: \nBrute Force with Backtracking\n\n- content: \nGenerate all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams and check which one matches the given bigrams.\n\nSolution Approach:\n1. For each test case, read the number of bigrams and the bigrams themselves.\n2. Generate all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams.\n3. Check which one matches the given bigrams.\n4. Output the matching word.\n\nThis brute force approach ensures functional correctness by considering all possible combinations of \'a\' and \'b\' to fill in the missing letters.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bigram\': a sequence of two adjacent letters in a word\n    \'possible word\': a word that can be formed by filling in the missing letters between the given bigrams\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship\n\n# [degree adverb] \n    No specific degree adverb\n\n# [code logic]\n    The plan suggests generating all possible words by inserting \'a\' and \'b\' in the possible positions between the given bigrams and checking which one matches the given bigrams.\n\n# [edge case] \n    Testcase with 3 bigrams: ["aa"]\n    Expected Output: "ba" or "ab"\n    Explanation: There are only two possible words that can be formed: "ba" and "ab". Both will match the given bigram "aa".\n\n    Testcase with 5 bigrams: ["bb", "ab", "bb"]\n    Expected Output: "bbabb" or "babbb"\n    Explanation: There are multiple possible words that can be formed, such as "bbabb" and "babbb", which will match the given bigrams.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case as the problem guarantees that a valid word exists.\n\n# [edge case] \n    Testcase with 3 bigrams: ["aa"]\n    Expected Output: "ba" or "ab"\n    Explanation: There are only two possible words that can be formed: "ba" and "ab". Both will match the given bigram "aa".\n\n    Testcase with 5 bigrams: ["bb", "ab", "bb"]\n    Expected Output: "bbabb" or "babbb"\n    Explanation: There are multiple possible words that can be formed, such as "bbabb" and "babbb", which will match the given bigrams.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case as the problem guarantees that a valid word exists.', '- name: \nBrute Force Solution\n\n- content: \nFor each test case, we will try all possible combinations of \'a\' and \'b\' to fill in the missing letter between the bigrams. We will check if the resulting sequence matches the given bigrams. If a match is found, we will output the sequence as the full word.\n\nHere\'s the step-by-step approach:\n1. For each test case, generate all possible combinations of \'a\' and \'b\' for the missing letter.\n2. Insert the missing letter into the sequence of bigrams to form potential words.\n3. Check if the resulting word matches the given bigrams.\n4. If a match is found, output the word as the solution.\n\nThis brute force solution ensures functional correctness by trying all possible combinations and checking for matches with the given bigrams.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bigrams\': sequences of two adjacent letters in a word\n    Explanation: In the context of the problem, a bigram is a pair of consecutive characters in a word. For example, in the word "abbaaba", the bigrams are "ab", "bb", "ba", "aa", "ab", and "ba".\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    The plan suggests generating all possible combinations of \'a\' and \'b\' for the missing letter and checking if the resulting sequence matches the given bigrams. This can be efficiently implemented by iterating through the possible positions for the missing letter and constructing the word accordingly.\n\n# [edge case] \n    Testcase 1:\n    Input: 7\n    bigrams: ab bb ba aa ba\n    Expected Output: abbaaba\n    Explanation: The word "abbaaba" contains the given bigrams in order. The missing bigram is the 5th one, which is "ba".\n\n    Testcase 2:\n    Input: 7\n    bigrams: ab ba aa ab ba\n    Expected Output: abaabaa\n    Explanation: The word "abaabaa" contains the given bigrams in order. The missing bigram is the 6th one, which is "aa".\n\n    Testcase 3:\n    Input: 3\n    bigrams: aa\n    Expected Output: baa\n    Explanation: The word "baa" contains the given bigram "aa". The missing bigram is the first one, which is "aa".\n\n    Testcase 4:\n    Input: 5\n    bigrams: bb ab bb\n    Expected Output: bbabb\n    Explanation: The word "bbabb" contains the given bigrams in order. The missing bigram is the 4th one, which is "ab".\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The brute force solution inherently covers all possible cases by trying all combinations and checking for matches.', '- name: \nBrute Force Solution\n\n- content: \nFor each test case, we will try all possible combinations of \'a\' and \'b\' to fill in the missing letter between the bigrams. We will check if the resulting sequence matches the given bigrams. If a match is found, we will output the sequence as the full word.\n\nHere\'s the step-by-step approach:\n1. For each test case, generate all possible combinations of \'a\' and \'b\' for the missing letter.\n2. Insert the missing letter into the sequence of bigrams to form potential words.\n3. Check if the resulting word matches the given bigrams.\n4. If a match is found, output the word as the solution.\n\nThis brute force solution ensures functional correctness by trying all possible combinations and checking for matches with the given bigrams.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bigrams\': sequences of two adjacent letters in a word\n    Explanation: In the context of the problem, a bigram is a pair of consecutive characters in a word. For example, in the word "abbaaba", the bigrams are "ab", "bb", "ba", "aa", "ab", and "ba".\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    The plan suggests generating all possible combinations of \'a\' and \'b\' for the missing letter and checking if the resulting sequence matches the given bigrams. This can be efficiently implemented by iterating through the possible positions for the missing letter and constructing the word accordingly.\n\n# [edge case] \n    Testcase 1:\n    Input: 7\n    bigrams: ab bb ba aa ba\n    Expected Output: abbaaba\n    Explanation: The word "abbaaba" contains the given bigrams in order. The missing bigram is the 5th one, which is "ba".\n\n    Testcase 2:\n    Input: 7\n    bigrams: ab ba aa ab ba\n    Expected Output: abaabaa\n    Explanation: The word "abaabaa" contains the given bigrams in order. The missing bigram is the 6th one, which is "aa".\n\n    Testcase 3:\n    Input: 3\n    bigrams: aa\n    Expected Output: baa\n    Explanation: The word "baa" contains the given bigram "aa". The missing bigram is the first one, which is "aa".\n\n    Testcase 4:\n    Input: 5\n    bigrams: bb ab bb\n    Expected Output: bbabb\n    Explanation: The word "bbabb" contains the given bigrams in order. The missing bigram is the 4th one, which is "ab".\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The brute force solution inherently covers all possible cases by trying all combinations and checking for matches.']
----------
False
----------
0
multi-gen-prompt:
 You are given an array a_1, a_2, …, a_n, which consists of non-negative integers. The operation of "elimination" is defined with an integer parameter k (1 ≤ k ≤ n). This operation involves choosing k distinct array indices 1 ≤ i_1 < i_2 < … < i_k ≤ n. The next step is to calculate x as the result of the bitwise AND operation applied to a_{i_1}, a_{i_2}, …, a_{i_k}. This bitwise AND operation is a binary

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
multi-gen-prompt:
 You are given an array a_1, a_2, …, a_n, consisting of non-negative integers. Let's define the "elimination" operation with an integer parameter k (1 ≤ k ≤ n) as follows: choose k distinct array indices and calculate the bitwise AND of the elements at these indices, then subtract this result from each of the chosen elements; all other elements remain unchanged. Find all possible values of k such that it's possible to make all elements of the array equal to 0 using a finite number of elimination operations with parameter k.

Input

Each test contains multiple test cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). Description of the test cases follows.

The first line of each test case contains one integer n (1 ≤ n ≤ 200 000) — the length of array a.

The second line of each test case contains n integers a_1, a_2, …, a_n (0 ≤ a_i < 2^{30}) — array a itself.

It's guaranteed that the sum of n over all test cases doesn't exceed 200 000.

Output

For each test case, print all values k, such that it's possible to make all elements of a equal to 0 in a finite number of elimination operations with the given parameter k.

Print them in increasing order.

Example

Input


5
4
4 4 4 4
4
13 7 25 19
6
3 5 3 1 7 1
1
1
5
0 0 0 0 0


Output


1 2 4
1 2
1
1
1 2 3 4 5

Note

In the first test case:

  * If k = 1, we can make four elimination operations with sets of indices \{1\}, \{2\}, \{3\}, \{4\}. Since \& of one element is equal to the element itself, then for each operation x = a_i, so a_i - x = a_i - a_i = 0. 
  * If k = 2, we can make two elimination operations with, for example, sets of indices \{1, 3\} and \{2, 4\}: x = a_1 ~ \& ~ a_3 = a_2 ~ \& ~ a_4 = 4 ~ \& ~ 4 = 4. For both operations x = 4, so after the first operation a_1 - x = 0 and a_3 - x = 0, and after the second operation — a_2 - x = 0 and a_4 - x = 0. 
  * If k = 3, it's impossible to make all a_i equal to 0. After performing the first operation, we'll get three elements equal to 0 and one equal to 4. After that, all elimination operations won't change anything, since at least one chosen element will always be equal to 0. 
  * If k = 4, we can make one operation with set \{1, 2, 3, 4\}, because x = a_1 ~ \& ~ a_2 ~ \& ~ a_3 ~ \& ~ a_4 = 4. 



In the second test case, if k = 2 then we can make the following elimination operations:

  * Operation with indices \{1, 3\}: x = a_1 ~ \& ~ a_3 = 13 ~ \& ~ 25 = 9. a_1 - x = 13 - 9 = 4 and a_3 - x = 25 - 9 = 16. Array a will become equal to [4, 7, 16, 19]. 
  * Operation with indices \{3, 4\}: x = a_3 ~ \& ~ a_4 = 16 ~ \& ~ 19 = 16. a_3 - x = 16 - 16 = 0 and a_4 - x = 19 - 16 = 3. Array a will become equal to [4, 7, 0, 3]. 
  * Operation with indices \{2, 4\}: x = a_2 ~ \& ~ a_4 = 7 ~ \& ~ 3 = 3. a_2 - x = 7 - 3 = 4 and a_4 - x = 3 - 3 = 0. Array a will become equal to [4, 4, 0, 0]. 
  * Operation with indices \{1, 2\}: x = a_1 ~ \& ~ a_2 = 4 ~ \& ~ 4 = 4. a_1 - x = 4 - 4 = 0 and a_2 - x = 4 - 4 = 0. Array a will become equal to [0, 0, 0, 0]. 



Formal definition of bitwise AND:

Let's define bitwise AND (\&) as follows. Suppose we have two non-negative integers x and y, let's look at their binary representations (possibly, with leading zeroes): x_k ... x_2 x_1 x_0 and y_k ... y_2 y_1 y_0. Here, x_i is the i-th bit of number x, and y_i is the i-th bit of number y. Let r = x ~ \& ~ y is a result of operation \& on number x and y. Then binary representation of r will be r_k ... r_2 r_1 r_0, where:

$$$ r_i = \begin{cases} 1, ~ if ~ x_i = 1 ~ and ~ y_i = 1 \\\ 0, ~ if ~ x_i = 0 ~ or ~ y_i = 0 \end{cases} $$$
generating with deepseek-coder
----------
['import sys\nfrom math import gcd\nfrom functools import reduce\n\ndef get_possible_ks(n, arr):\n    # Calculate the GCD of all elements in the array\n    array_gcd = reduce(gcd, arr)\n    \n    # Function to check if a given k is possible\n    def is_possible_k(k):\n        # Create a copy of the array to perform operations on\n        temp_arr = arr.copy()\n        # Perform elimination operations with parameter k\n        for _ in range(n // k):\n            x = reduce(lambda a, b: a & b, temp_arr[:k])\n            for i in range(k):\n                temp_arr[i] -= x\n        # Check if all elements are zero\n        return all(elem == 0 for elem in temp_arr)\n    \n    # List to store possible values of k\n    possible_ks = []\n    # Check all possible values of k from 1 to n\n    for k in range(1, n + 1):\n        if is_possible_k(k):\n            possible_ks.append(k)\n    \n    return possible_ks\n\nif __name__ == "__main__":\n    input_lines = sys.stdin.readlines()\n    t = int(input_lines[0].strip())\n    \n    line_index = 1\n    for _ in range(t):\n        n = int(input_lines[line_index].strip())\n        line_index += 1\n        arr = list(map(int, input_lines[line_index].strip().split()))\n        line_index += 1\n        \n        possible_ks = get_possible_ks(n, arr)\n        print(" ".join(map(str, possible_ks)))', 'import itertools\n\ndef possible_values_of_k(n, a):\n    possible_ks = set()\n    for k in range(1, n + 1):\n        for subset in itertools.combinations(range(n), k):\n            and_result = None\n            for i in subset:\n                if and_result is None:\n                    and_result = a[i]\n                else:\n                    and_result &= a[i]\n            if and_result is not None:\n                for i in subset:\n                    a[i] -= and_result\n                if all(x == 0 for x in a):\n                    possible_ks.add(k)\n                for i in subset:\n                    a[i] += and_result\n    return sorted(possible_ks)\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = [int(x) for x in data[index:index + n]]\n        index += n\n        results.append(possible_values_of_k(n, a))\n    \n    for result in results:\n        print(\' \'.join(map(str, result)))', 'def can_make_zero(arr, k):\n    n = len(arr)\n    for i in range(n - k + 1):\n        current_and = arr[i]\n        for j in range(1, k):\n            current_and &= arr[i + j]\n        if current_and == 0:\n            return True\n    return False\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        valid_ks = []\n        for k in range(1, n + 1):\n            if can_make_zero(arr, k):\n                valid_ks.append(k)\n        print(\' \'.join(map(str, valid_ks)))\n\nif __name__ == "__main__":\n    solve()', 'def f1(n, arr):\n    possible_ks = set()\n    for k in range(1, n + 1):\n        for i in range(n - k + 1):\n            x = arr[i]\n            for j in range(1, k):\n                x &= arr[i + j]\n            if x == 0:\n                possible_ks.add(k)\n                break\n    return sorted(possible_ks)\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = []\n        for i in range(n):\n            arr.append(int(data[index]))\n            index += 1\n        results.append(f1(n, arr))\n    \n    for result in results:\n        print(\' \'.join(map(str, result)))', 'from itertools import combinations\n\ndef can_make_zero(arr, k):\n    for combo in combinations(arr, k):\n        and_result = combo[0]\n        for num in combo[1:]:\n            and_result &= num\n        if all(num - and_result == 0 for num in combo):\n            return True\n    return False\n\ndef find_possible_ks(arr):\n    possible_ks = set()\n    n = len(arr)\n    for k in range(1, n + 1):\n        if can_make_zero(arr, k):\n            possible_ks.add(k)\n    return sorted(possible_ks)\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        results.append(find_possible_ks(arr))\n    \n    for result in results:\n        print(\' \'.join(map(str, result)))\n\nif __name__ == "__main__":\n    main()', 'def solve_test_case(a):\n    n = len(a)\n    possible_ks = set()\n    \n    for k in range(1, n + 1):\n        can_make_zero = True\n        for i in range(n):\n            if a[i] % (2 ** k) != 0:\n                can_make_zero = False\n                break\n        if can_make_zero:\n            possible_ks.add(k)\n    \n    return sorted(possible_ks)\n\ndef main():\n    t = int(input())\n    results = []\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        results.append(solve_test_case(a))\n    \n    for result in results:\n        print(\' \'.join(map(str, result)))\n\nif __name__ == "__main__":\n    main()', 'from itertools import combinations\n\ndef can_make_zero(arr, k):\n    n = len(arr)\n    for combo in combinations(arr, k):\n        and_result = combo[0]\n        for num in combo[1:]:\n            and_result &= num\n        if and_result != combo[0]:\n            return False\n        for i in range(n):\n            if i not in combo:\n                if arr[i] & and_result != 0:\n                    return False\n    return True\n\ndef find_possible_ks(arr):\n    possible_ks = []\n    n = len(arr)\n    for k in range(1, n + 1):\n        if can_make_zero(arr, k):\n            possible_ks.append(k)\n    return possible_ks\n\ndef main():\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        possible_ks = find_possible_ks(arr)\n        results.append(\' \'.join(map(str, possible_ks)))\n    for result in results:\n        print(result)\n\nif __name__ == "__main__":\n    main()', 'def possible_values_of_k(n, a):\n    possible_ks = set()\n    max_element = max(a)\n    \n    # Check for each possible k from 1 to n\n    for k in range(1, n + 1):\n        for i in range(n - k + 1):\n            x = a[i]\n            for j in range(1, k):\n                x &= a[i + j]\n            if x == 0:\n                possible_ks.add(k)\n                break\n    \n    return sorted(possible_ks)\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = []\n        for i in range(n):\n            a.append(int(data[index]))\n            index += 1\n        results.append(possible_values_of_k(n, a))\n    \n    for result in results:\n        print(\' \'.join(map(str, result)))', 'def can_make_zero(arr, k):\n    n = len(arr)\n    for i in range(n - k + 1):\n        current_and = arr[i]\n        for j in range(1, k):\n            current_and &= arr[i + j]\n        if current_and == 0:\n            return True\n    return False\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        valid_ks = []\n        for k in range(1, n + 1):\n            if can_make_zero(arr, k):\n                valid_ks.append(k)\n        print(\' \'.join(map(str, valid_ks)))\n\nif __name__ == "__main__":\n    solve()', 'import sys\nfrom math import gcd\nfrom functools import reduce\n\ndef get_possible_ks(n, arr):\n    # Calculate the GCD of all elements in the array\n    array_gcd = reduce(gcd, arr)\n    \n    # Function to check if a given k is possible\n    def is_possible_k(k):\n        # Create a copy of the array to perform operations on\n        temp_arr = arr.copy()\n        # Perform elimination operations with parameter k\n        for _ in range(n // k):\n            x = reduce(lambda a, b: a & b, temp_arr[:k])\n            for i in range(k):\n                temp_arr[i] -= x\n        # Check if all elements are zero\n        return all(elem == 0 for elem in temp_arr)\n    \n    # List to store possible values of k\n    possible_ks = []\n    # Check all possible values of k from 1 to n\n    for k in range(1, n + 1):\n        if is_possible_k(k):\n            possible_ks.append(k)\n    \n    return possible_ks\n\nif __name__ == "__main__":\n    input_lines = sys.stdin.readlines()\n    t = int(input_lines[0].strip())\n    \n    line_index = 1\n    for _ in range(t):\n        n = int(input_lines[line_index].strip())\n        line_index += 1\n        arr = list(map(int, input_lines[line_index].strip().split()))\n        line_index += 1\n        \n        possible_ks = get_possible_ks(n, arr)\n        print(" ".join(map(str, possible_ks)))']
----------
["- name: \nBitwise AND Analysis Solution\n\n- content: \nThe problem can be solved by analyzing the bitwise AND properties of the elements in the array. The goal is to find all possible values of k such that we can reduce all elements to 0 using elimination operations with parameter k.\n\n**Solution Approach:**\n1. For each possible value of k (from 1 to n), check if we can reduce all elements to 0 using k elements.\n2. For each value of k, generate all possible sets of k elements.\n3. For each set, calculate the bitwise AND of the elements in the set.\n4. If the result of the bitwise AND operation is 0, then k is a valid value.\n5. Collect all valid k values and output them in increasing order.\n\n**Algorithm:**\n- Use a brute force approach to iterate over all possible values of k.\n- For each k, use combinations to generate all possible sets of k elements.\n- For each set, compute the bitwise AND and check if it's 0.\n- If the result is 0, add k to the list of valid k values.\n- Sort and output the valid k values.\n\n**Edge Cases:**\n- Handle cases where all elements are already 0.\n- Handle cases where there is only one element in the array.\n- Ensure that the bitwise AND operation is correctly implemented to handle large numbers.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'bitwise AND operation': This operation is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. It's used to manipulate bits in binary numbers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a brute force approach to iterate over all possible values of k and check if we can reduce all elements to 0 using k elements. This involves generating all possible sets of k elements and computing the bitwise AND for each set.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'bitwise AND operation': This operation is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. It's used to manipulate bits in binary numbers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a brute force approach to iterate over all possible values of k and check if we can reduce all elements to 0 using k elements. This involves generating all possible sets of k elements and computing the bitwise AND for each set.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'bitwise AND operation': This operation is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. It's used to manipulate bits in binary numbers.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers more than 0.\n    'at least as many times': means that we need to find the integer whose appearances are greater than or equal to its value.\n\n# [degree adverb] \n    'largest': means that we need the largest integer that appears greater than or equal to its value.\n\n# [code logic]\n    There are no steps that can be implemented simultaneously. All 4 steps should be implemented step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'elimination': This operation involves choosing k distinct indices, calculating the bitwise AND of the elements at those indices, and subtracting this result from each of the chosen elements.\n\n# [phrase showing quantity relationship]\n    'with parameter k': means that the operation is performed with a specific value of k.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a solution approach that involves checking all possible values of k to see if we can reduce all elements to 0 using elimination operations with parameter k.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'bitwise AND operation': This operation is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. It's used to manipulate bits in binary numbers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a brute force approach to iterate over all possible values of k and check if we can reduce all elements to 0 using k elements. This involves generating all possible sets of k elements and computing the bitwise AND for each set.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.", "- name: \nOptimization Using Bitwise Properties\n\n- content: \nWe can optimize the solution by leveraging the properties of bitwise operations and subset generation to reduce the number of operations needed.\n\n**Approach:**\n1. Iterate over all possible values of k from 1 to n.\n2. For each k, generate all possible subsets of size k.\n3. For each subset, calculate the bitwise AND of its elements.\n4. Subtract this result from each element in the subset and check if all elements become zero.\n5. If all elements become zero, add k to the result list.\n6. Return the result list sorted in increasing order.\n\n**Algorithm:**\n1. Iterate over all possible values of k from 1 to n.\n2. For each k, generate all possible subsets of size k.\n3. For each subset, calculate the bitwise AND of its elements.\n4. Subtract this result from each element in the subset and check if all elements become zero.\n5. If all elements become zero, add k to the result list.\n6. Return the result list sorted in increasing order.\n\n**Edge Cases:**\n- Handle cases where the array is already all zeros.\n- Handle cases where the array contains only one element.\n- Handle cases where the array contains large numbers that might require multiple operations to reduce to zero.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'bitwise AND operation': This operation is performed between two numbers to produce a new number which has bits set to 1 only in positions where both of the corresponding bits of the operands are 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests iterating over all possible values of k from 1 to n, generating all possible subsets of size k, calculating the bitwise AND of each subset, and checking if all elements in the subset can be reduced to zero by subtracting the AND result.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept] \n    'positive': means that all integer in the list is > 0\n\n    'at least as many times': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integer > 0\n    'at least as many times': means that we need to find the integer whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps should be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    Explanation: number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need. \n\n# [core concept]\n    'bitwise AND operation': This operation is performed between two numbers to produce a new number which has bits set to 1 only in positions where both of the corresponding bits of the operands are 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests iterating over all possible values of k from 1 to n, generating all possible subsets of size k, calculating the bitwise AND of each subset, and checking if all elements in the subset can be reduced to zero by subtracting the AND result.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'bitwise AND operation': This operation is performed between two numbers to produce a new number which has bits set to 1 only in positions where both of the corresponding bits of the operands are 1.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests iterating over all possible values of k from 1 to n, generating all possible subsets of size k, calculating the bitwise AND of each subset, and checking if all elements in the subset can be reduced to zero by subtracting the AND result.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)", "- name: \nOptimized Bitwise Analysis\n\n- content: \nAn optimized approach involves leveraging the properties of the bitwise AND operation to reduce the number of checks needed. Instead of checking every subset, we can focus on subsets that are more likely to result in zero when their bitwise AND is calculated.\n\n**Solution Approach:**\n1. **Identify potential subsets:** Focus on subsets where the elements have common bits set to 1, as these are more likely to result in zero when ANDed together.\n2. **Check specific k values:** For each k, check specific patterns or properties that are likely to result in zero when ANDed together.\n3. **Implementation:** Implement this logic to efficiently determine valid k values without checking every possible subset.\n\n**Functional Correctness:**\n- This approach significantly reduces the number of checks, making it more efficient for large inputs.\n- It ensures that all valid k values are found while minimizing unnecessary computations.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'bitwise AND operation': This is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. When applied to a list of integers, it results in a single integer where each bit is the result of the AND operation on the corresponding bits of the input integers.\n    Explanation: The bitwise AND operation is used to combine the bits of multiple numbers. If any bit in the position is 0 in any of the numbers, the result will also have a 0 in that position. The goal is to find the values of k that can make all elements of the array equal to 0 using the bitwise AND operation.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find values of k that can achieve the goal when there are more than k elements considered.\n    Explanation: For example, if k = 2, we are looking for a combination of 2 elements from the array whose bitwise AND results in 0.\n\n# [degree adverb] \n    'largest': This adverb indicates that we are looking for the largest possible value of k that can achieve the goal.\n    Explanation: For instance, if k = 2, we need to find the largest possible subset of 2 elements that can be ANDed together to result in 0.\n\n# [code logic]\n    The steps should be implemented sequentially. We need to iterate through the array to find all possible subsets of size k, calculate their bitwise AND, and check if the result is 0.\n\n# [edge case] \n    how_many_times([], 'a') = 0\n    Explanation: Since the array is empty, there are no elements to perform the bitwise AND operation, so the result is 0.\n    how_many_times([1], 1) = 1\n    Explanation: The array contains only one element, and the bitwise AND of one element with itself is the element itself, so the result is 1.\n    how_many_times([0, 0, 0], 0) = 3\n    Explanation: The array contains three zeros, and the bitwise AND of any number of zeros is 0, so the result is 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array is empty.\n        if not lst:\n            return 0\n        (other code)\n\n# [core concept]\n    'non-negative integers': These are integers that are greater than or equal to 0.\n    Explanation: In the context of the problem, we are dealing with arrays of positive integers, but the requirement specifies non-negative integers, which includes zero.\n\n# [phrase showing quantity relationship]\n    'positive integers': This phrase indicates that we are only interested in integers that are greater than 0.\n    Explanation: For example, in the requirement, we need to return the largest integer that is more than zero and appears at least as many times as the integer itself.\n\n# [degree adverb] \n    'largest': This adverb indicates that we are looking for the biggest integer that meets the given condition.\n    Explanation: For instance, if we have the array [3, 3, 2, 4, 4, 4], the largest integer that appears at least as many times as itself is 4.\n\n# [code logic]\n    The steps should be implemented sequentially. We need to iterate through the array to find the frequency of each integer, compare it with its value, and keep track of the largest integer that meets the condition.\n\n# [edge case] \n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their values, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'bitwise AND operation': This is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. When applied to a list of integers, it results in a single integer where each bit is the result of the AND operation on the corresponding bits of the input integers.\n    Explanation: The bitwise AND operation is used to combine the bits of multiple numbers. If any bit in the position is 0 in any of the numbers, the result will also have a 0 in that position. The goal is to find the values of k that can make all elements of the array equal to 0 using the bitwise AND operation.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find values of k that can achieve the goal when there are more than k elements considered.\n    Explanation: For example, if k = 2, we are looking for a combination of 2 elements from the array whose bitwise AND results in 0.\n\n# [degree adverb] \n    'largest': This adverb indicates that we are looking for the largest possible value of k that can achieve the goal.\n    Explanation: For instance, if k = 2, we need to find the largest possible subset of 2 elements that can be ANDed together to result in 0.\n\n# [code logic]\n    The steps should be implemented sequentially. We need to iterate through the array to find all possible subsets of size k, calculate their bitwise AND, and check if the result is 0.\n\n# [edge case] \n    how_many_times([], 'a') = 0\n    Explanation: Since the array is empty, there are no elements to perform the bitwise AND operation, so the result is 0.\n    how_many_times([1], 1) = 1\n    Explanation: The array contains only one element, and the bitwise AND of one element with itself is the element itself, so the result is 1.\n    how_many_times([0, 0, 0], 0) = 3\n    Explanation: The array contains three zeros, and the bitwise AND of any number of zeros is 0, so the result is 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array is empty.\n        if not lst:\n            return 0\n        (other code)", "- name: \nOptimized Bitwise Analysis\n\n- content: \nTo optimize the solution, we can leverage the properties of the bitwise AND operation and reduce the number of operations needed. Instead of checking all subsets for each k, we can use a more strategic approach to determine if a reduction is possible.\n\n**Approach:**\n1. **Identify Common Bits**: For each bit position, count how many elements have a 1 in that position. If there are fewer than k elements with a 1 in a particular bit position, then the result of the bitwise AND operation for any subset involving those elements will not be zero.\n2. **Check All k Values**: For each k, check if there exists a subset where the bitwise AND of its elements results in zero by ensuring that each bit position where there are fewer than k 1s has a 1 in at least one element of the subset.\n3. **Output Valid k Values**: Collect and output all valid k values in increasing order.\n\n**Functional Correctness:**\n- The solution ensures that all possible valid inputs and edge cases are considered.\n- It handles arrays with all elements being the same, arrays where no reduction is possible, and large arrays where the sum of n over all test cases doesn't exceed 200,000.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'bitwise AND operation': This is a binary operation that takes two bit patterns of equal length and performs the logical AND operation on each pair of the corresponding bits. The result in each position is 1 if both bits are 1; otherwise, the result is 0.\n    Explanation: The bitwise AND operation is used to combine bits, where each bit in the result is 1 if and only if both corresponding bits in the operands are 1. This operation is crucial in various programming and computer science applications, including masking and bit manipulation.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that a certain condition must be met by more than a specific number of elements.\n    Explanation: In the context of the requirement, it means that for a given k, there must be more than k elements with a 1 in a particular bit position for the bitwise AND operation to result in zero.\n\n# [degree adverb] \n    'largest': This adverb indicates that the sought-after value is the biggest or greatest in a given context.\n    Explanation: In the requirement, it means that we need to find the largest k such that it's possible to make all elements of the array equal to 0 using the elimination operation with parameter k.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - For each bit position, count the number of elements with a 1 in that position.\n    - Check if there exists a subset of size k where the bitwise AND of its elements results in zero.\n    - Collect and output all valid k values in increasing order.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'positive': means that all integer in the list is > 0\n    'at least as many times': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integer > 0\n    'at least as many times': means that we need to find the integer whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps should be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'bitwise AND operation': This is a binary operation that takes two bit patterns of equal length and performs the logical AND operation on each pair of the corresponding bits. The result in each position is 1 if both bits are 1; otherwise, the result is 0.\n    Explanation: The bitwise AND operation is used to combine bits, where each bit in the result is 1 if and only if both corresponding bits in the operands are 1. This operation is crucial in various programming and computer science applications, including masking and bit manipulation.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that a certain condition must be met by more than a specific number of elements.\n    Explanation: In the context of the requirement, it means that for a given k, there must be more than k elements with a 1 in a particular bit position for the bitwise AND operation to result in zero.\n\n# [degree adverb] \n    'largest': This adverb indicates that the sought-after value is the biggest or greatest in a given context.\n    Explanation: In the requirement, it means that we need to find the largest k such that it's possible to make all elements of the array equal to 0 using the elimination operation with parameter k.\n\n# [code logic]\n    The steps should be implemented sequentially.\n    - For each bit position, count the number of elements with a 1 in that position.\n    - Check if there exists a subset of size k where the bitwise AND of its elements results in zero.\n    - Collect and output all valid k values in increasing order.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'positive': means that all integer in the list is > 0\n    'at least as many times': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integer > 0\n    'at least as many times': means that we need to find the integer whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps should be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.", "- name: \nBrute Force and Bitwise Analysis\n\n- content: \nTo solve this problem, we can use a brute force approach to check all possible values of k. For each k, we will try to find a set of k indices such that the bitwise AND of the elements at these indices is non-zero and can be subtracted from each element in the set to eventually reduce all elements to 0.\n\nHere's a step-by-step approach:\n1. Iterate over all possible values of k from 1 to n.\n2. For each k, generate all possible combinations of k indices from the array.\n3. For each combination, calculate the bitwise AND of the elements at these indices.\n4. If the bitwise AND is non-zero, check if we can use this operation to reduce all elements to 0 by iteratively subtracting this value from the chosen elements.\n5. If we can reduce all elements to 0 using this operation, add k to the list of possible values.\n6. Output all possible values of k in increasing order.\n\nThis approach ensures that we consider all possible ways to use the elimination operation to reduce the array to 0, and it handles all edge cases, including when the array already consists of all zeros or when the array has a single element that is already 0.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'bitwise AND': This operation is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise it returns 0. In the context of the problem, it is used to combine the values at specific indices in the array to check if a non-zero value can be obtained.\n    Explanation: The bitwise AND operation is used to combine the values at specific indices in the array. If the result of the AND operation is non-zero, it means that the values at these indices have a common bit set to 1. This can be used to reduce the array elements to 0 by iteratively subtracting this value from the chosen elements.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that the value of k must be greater than 1 and less than or equal to n, where n is the length of the array.\n    Explanation: The value of k must be such that it allows for the selection of at least one element from the array and no more than all elements. This ensures that the elimination operation can be performed and that the array can be reduced to 0.\n\n# [degree adverb]\n    'largest': This adverb indicates that we need to find the largest integer that appears at least as many times as itself.\n    Explanation: The largest integer that meets the condition of appearing at least as many times as itself is the maximum value in the array that satisfies the given criteria.\n\n# [code logic]\n    The steps should be implemented sequentially as each step builds upon the previous one.\n    Explanation: The steps are designed to systematically check all possible values of k and determine if they can be used to reduce the array to 0. Each step is dependent on the successful completion of the previous step, ensuring that all possible values of k are considered.\n\n# [edge case]\n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'finite number of operations': This means that we need to find a sequence of operations that can reduce all elements of the array to 0 within a limited number of steps.\n    Explanation: The problem requires finding all possible values of k such that it's possible to make all elements of the array equal to 0 using a finite number of elimination operations with the given parameter k.\n\n# [phrase showing quantity relationship]\n    'a finite number of': This phrase indicates that the number of operations is limited and can be determined.\n    Explanation: The phrase ensures that we are looking for a specific number of operations that can be performed to reduce the array to 0.\n\n# [degree adverb]\n    'all possible values': This adverb indicates that we need to consider all possible values of k to ensure that we find the correct solution.\n    Explanation: The degree adverb ensures that we do not miss any possible value of k that can be used to reduce the array to 0.\n\n# [code logic]\n    The steps should be implemented sequentially as each step builds upon the previous one.\n    Explanation: The steps are designed to systematically check all possible values of k and determine if they can be used to reduce the array to 0. Each step is dependent on the successful completion of the previous step, ensuring that all possible values of k are considered.\n\n# [edge case]\n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'bitwise AND': This operation is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise it returns 0. In the context of the problem, it is used to combine the values at specific indices in the array to check if a non-zero value can be obtained.\n    Explanation: The bitwise AND operation is used to combine the values at specific indices in the array. If the result of the AND operation is non-zero, it means that the values at these indices have a common bit set to 1. This can be used to reduce the array elements to 0 by iteratively subtracting this value from the chosen elements.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that the value of k must be greater than 1 and less than or equal to n, where n is the length of the array.\n    Explanation: The value of k must be such that it allows for the selection of at least one element from the array and no more than all elements. This ensures that the elimination operation can be performed and that the array can be reduced to 0.\n\n# [degree adverb]\n    'largest': This adverb indicates that we need to find the largest integer that appears at least as many times as itself.\n    Explanation: The largest integer that meets the condition of appearing at least as many times as itself is the maximum value in the array that satisfies the given criteria.\n\n# [code logic]\n    The steps should be implemented sequentially as each step builds upon the previous one.\n    Explanation: The steps are designed to systematically check all possible values of k and determine if they can be used to reduce the array to 0. Each step is dependent on the successful completion of the previous step, ensuring that all possible values of k are considered.\n\n# [edge case]\n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the original return answer to -1 and then find the largest integer that meets the condition.", "- name: \nBrute Force Solution\n\n- content: \nThe brute force solution involves checking each possible value of k (from 1 to n) to see if it is possible to make all elements of the array equal to 0 using the elimination operation with parameter k. For each k, we need to check all possible sets of k indices and see if the bitwise AND of the elements in each set can be subtracted from those elements to reduce them to 0.\n\nSteps:\n1. For each k from 1 to n, iterate over all possible sets of k indices.\n2. Calculate the bitwise AND of the elements in the current set.\n3. Subtract this result from each of the chosen elements.\n4. Check if all elements are now 0.\n5. If all elements are 0, add k to the list of possible values of k.\n6. Return the list of possible values of k in increasing order.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'bitwise AND': This operation involves comparing the binary representations of two numbers and producing a new number where each bit is set to 1 if and only if both of the corresponding bits of the operands are 1.\n    Explanation: The bitwise AND operation is crucial in this problem as it determines the value that can be subtracted from the chosen elements to potentially reduce them to zero.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that the integer must appear more times than its value in the array for it to be a candidate for elimination.\n    Explanation: For example, if an integer appears 3 times and its value is 2, it cannot be eliminated since 3 is not more than 2.\n\n# [degree adverb] \n    'largest': This adverb suggests that we are looking for the largest possible value of k that allows all elements to be eliminated.\n    Explanation: The largest k ensures that we are considering the most elements in each elimination operation, which increases the chances of making all elements zero.\n\n# [code logic]\n    The steps should be implemented sequentially. For each k, we need to check all possible sets of k indices and their bitwise AND results.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'positive': means that all integer in the list is > 0\n    Explanation: In the context of the requirement, all integers must be positive to meet the condition of appearing at least as many times as the integer itself.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integer > 0\n    Explanation: This phrase ensures that we only consider integers that are greater than zero.\n    'at least as many times': means that we need to find the integer whose appears times is greater than or equal to its value\n    Explanation: This phrase ensures that we find integers whose frequency is at least as much as their value.\n\n# [degree adverb] \n    'largest': means that we need the biggest integer that appears greater or equal to its value\n    Explanation: This adverb helps in identifying the largest integer that satisfies the condition of appearing at least as many times as itself.\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps should be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'elimination': This operation involves choosing k distinct array indices and calculating the bitwise AND of the elements at these indices, then subtracting this result from each of the chosen elements.\n    Explanation: The elimination operation is the core concept in this problem as it is used to reduce the elements of the array to zero.\n\n# [phrase showing quantity relationship]\n    'at least as many times': This phrase indicates that the integer must appear at least as many times as its value for it to be a candidate for elimination.\n    Explanation: For example, if an integer appears 3 times and its value is 2, it cannot be eliminated since 3 is not at least as many times as 2.\n\n# [degree adverb] \n    'largest': This adverb suggests that we are looking for the largest possible value of k that allows all elements to be eliminated.\n    Explanation: The largest k ensures that we are considering the most elements in each elimination operation, which increases the chances of making all elements zero.\n\n# [code logic]\n    The brute force solution involves checking each possible value of k (from 1 to n) to see if it is possible to make all elements of the array equal to 0 using the elimination operation with parameter k.\n\n# [edge case] \n    Edge case 1:\n    Input: [4, 4, 4, 4]\n    Expected Output: 1 2 4\n    Explanation: For k = 1, we can make four elimination operations with sets of indices {1}, {2}, {3}, {4}. For k = 2, we can make two elimination operations with sets of indices {1, 3} and {2, 4}. For k = 4, we can make one operation with set {1, 2, 3, 4}.\n\n    Edge case 2:\n    Input: [13, 7, 25, 19]\n    Expected Output: 1 2\n    Explanation: For k = 1, we can make four elimination operations with sets of indices {1}, {2}, {3}, {4}. For k = 2, we can make two elimination operations with sets of indices {1, 3} and {2, 4}.\n\n    Edge case 3:\n    Input: [3, 5, 3, 1, 7, 1]\n    Expected Output: 1\n    Explanation: For k = 1, we can make six elimination operations with sets of indices {1}, {2}, {3}, {4}, {5}, {6}.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        def search(lst):\n            freq = {}\n            for num in lst:\n                freq[num] = freq.get(num, 0) + 1\n            result = -1\n            for num, count in freq.items():\n                if count >= num:\n                    result = max(result, num)\n            return result\n\n        # Handling edge cases\n        if not lst:\n            return -1\n        return search(lst)", '- name: \nBitwise AND Analysis Solution\n\n- content: \n- **Solution Approach:**\n  - For each possible value of k (from 1 to n), we will check if we can make all elements of the array equal to 0 using k distinct array indices.\n  - For each k, we will generate all possible combinations of k indices.\n  - For each combination, we will calculate the bitwise AND of the elements at these indices.\n  - We will then subtract this result from each of the chosen elements.\n  - If after all such operations all elements become 0, then k is a valid value.\n- **Algorithm:**\n  - For each k from 1 to n, generate all combinations of k indices.\n  - For each combination, calculate the bitwise AND and perform the subtraction operation.\n  - Check if all elements are now 0. If yes, add k to the result list.\n- **Edge Cases:**\n  - If all elements are already 0, any k will work.\n  - If no element can be reduced to 0 by any k, the output should be an empty list.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'bitwise AND\': This operation involves comparing each bit of two numbers to produce a new number. If both bits are 1, the corresponding bit in the result is 1; otherwise, it is 0.\n    Explanation: The bitwise AND operation is crucial in this problem as it determines the value that can be subtracted from the chosen elements to potentially make them all zero.\n\n# [phrase showing quantity relationship]\n    \'more than\': This phrase indicates that the integer must appear more times than its value for it to be a candidate for making all elements zero.\n    Explanation: For example, if an integer appears 3 times and its value is 2, it cannot be the solution because it does not meet the condition of appearing "more than" itself.\n\n# [degree adverb] \n    \'largest\': This adverb suggests that we need to find the largest integer that meets the criteria of appearing "more than" itself.\n    Explanation: The largest integer is preferred because it might require fewer operations to make all elements zero.\n\n# [code logic]\n    The steps should be implemented sequentially. For each k, we need to:\n    1. Generate all combinations of k indices.\n    2. Calculate the bitwise AND of the elements at these indices.\n    3. Subtract this result from each of the chosen elements.\n    4. Check if all elements are now 0.\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n\n    how_many_times(\'abc\', \'\') = 4\n    Explanation: \'\' appears four times in the original string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    \'positive\': means that all integer in the list is > 0\n    \'at least as many times\': means appears of a number >= its value\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find integer > 0\n    \'at least as many times\': means that we need to find the integer whose appears times is greater than or equal to its value\n\n# [degree adverb] \n    \'largest\': means that we need the biggest integer that appears greater or equal to its value\n\n# [code logic]\n    There are no steps that could be implement simultaneously. All 4 steps should be implement step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appears greater than or equal to its value, but 3 is the largest number\n\n    search([3,3,2,4,4,4]) = -1\n    Explanation: number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appears greater than or equal to its value, so the function return -1\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    \'bitwise AND\': This operation involves comparing each bit of two numbers to produce a new number. If both bits are 1, the corresponding bit in the result is 1; otherwise, it is 0.\n    Explanation: The bitwise AND operation is crucial in this problem as it determines the value that can be subtracted from the chosen elements to potentially make them all zero.\n\n# [phrase showing quantity relationship]\n    \'more than\': This phrase indicates that the integer must appear more times than its value for it to be a candidate for making all elements zero.\n    Explanation: For example, if an integer appears 3 times and its value is 2, it cannot be the solution because it does not meet the condition of appearing "more than" itself.\n\n# [degree adverb] \n    \'largest\': This adverb suggests that we need to find the largest integer that meets the criteria of appearing "more than" itself.\n    Explanation: The largest integer is preferred because it might require fewer operations to make all elements zero.\n\n# [code logic]\n    The steps should be implemented sequentially. For each k, we need to:\n    1. Generate all combinations of k indices.\n    2. Calculate the bitwise AND of the elements at these indices.\n    3. Subtract this result from each of the chosen elements.\n    4. Check if all elements are now 0.\n\n# [edge case] \n    how_many_times(\'\', \'a\') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n\n    how_many_times(\'abc\', \'\') = 4\n    Explanation: \'\' appears four times in the original string. \'abc\'.count(\'\')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)', "- name: \nBitwise AND Elimination Strategy\n\n- content: \nThe solution approach involves analyzing the bitwise AND operation and its properties to determine the possible values of k. The goal is to find all possible k such that it's possible to make all elements of the array a equal to 0 using elimination operations with parameter k.\n\n1. **Identify Common Bits**: For each possible k, we need to check if there exists a subset of size k where the bitwise AND of all elements in the subset is non-zero. This implies that the resulting number x from the AND operation must be less than or equal to the smallest element in the subset.\n2. **Check Divisors**: The possible values of k are all the divisors of n (including 1 and n). This is because we can always choose all elements (k=n) or any subset of elements whose size is a divisor of n.\n3. **Implementation**: Iterate through all possible values of k (from 1 to n) and for each k, check if there exists a subset of size k where the bitwise AND operation results in a non-zero value. If such a subset exists, then k is a valid value.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'bitwise AND operation': This is a binary operation that takes two bit patterns of equal length and performs the logical AND operation on each pair of the corresponding bits. The result in each position is 1 if both bits are 1; otherwise, the result is 0.\n    Explanation: The bitwise AND operation is crucial in this problem as it helps in determining the common bits between numbers, which is essential for reducing the array elements to zero through elimination operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. The plan suggests iterating through all possible values of k (from 1 to n) and checking if there exists a subset of size k where the bitwise AND operation results in a non-zero value. This can be efficiently done by considering the properties of the bitwise AND operation and the constraints given.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'bitwise AND operation': This is a binary operation that takes two bit patterns of equal length and performs the logical AND operation on each pair of the corresponding bits. The result in each position is 1 if both bits are 1; otherwise, the result is 0.\n    Explanation: The bitwise AND operation is crucial in this problem as it helps in determining the common bits between numbers, which is essential for reducing the array elements to zero through elimination operations.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. The plan suggests iterating through all possible values of k (from 1 to n) and checking if there exists a subset of size k where the bitwise AND operation results in a non-zero value. This can be efficiently done by considering the properties of the bitwise AND operation and the constraints given.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)", "- name: \nOptimized Bitwise Analysis\n\n- content: \nAn optimized approach involves leveraging the properties of the bitwise AND operation to reduce the number of checks needed. Instead of checking every subset, we can focus on subsets that are more likely to result in zero when their bitwise AND is calculated.\n\n**Solution Approach:**\n1. **Identify potential subsets:** Focus on subsets where the elements have common bits set to 1, as these are more likely to result in zero when ANDed together.\n2. **Check specific k values:** For each k, check specific patterns or properties that are likely to result in zero when ANDed together.\n3. **Implementation:** Implement this logic to efficiently determine valid k values without checking every possible subset.\n\n**Functional Correctness:**\n- This approach significantly reduces the number of checks, making it more efficient for large inputs.\n- It ensures that all valid k values are found while minimizing unnecessary computations.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'bitwise AND operation': This is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. When applied to a list of integers, it results in a single integer where each bit is the result of the AND operation on the corresponding bits of the input integers.\n    Explanation: The bitwise AND operation is used to combine the bits of multiple numbers. If any bit in the position is 0 in any of the numbers, the result will also have a 0 in that position. The goal is to find the values of k that can make all elements of the array equal to 0 using the bitwise AND operation.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find values of k that can achieve the goal when there are more than k elements considered.\n    Explanation: For example, if k = 2, we are looking for a combination of 2 elements from the array whose bitwise AND results in 0.\n\n# [degree adverb] \n    'largest': This adverb indicates that we are looking for the largest possible value of k that can achieve the goal.\n    Explanation: For instance, if k = 2, we need to find the largest possible subset of 2 elements that can be ANDed together to result in 0.\n\n# [code logic]\n    The steps should be implemented sequentially. We need to iterate through the array to find all possible subsets of size k, calculate their bitwise AND, and check if the result is 0.\n\n# [edge case] \n    how_many_times([], 'a') = 0\n    Explanation: Since the array is empty, there are no elements to perform the bitwise AND operation, so the result is 0.\n    how_many_times([1], 1) = 1\n    Explanation: The array contains only one element, and the bitwise AND of one element with itself is the element itself, so the result is 1.\n    how_many_times([0, 0, 0], 0) = 3\n    Explanation: The array contains three zeros, and the bitwise AND of any number of zeros is 0, so the result is 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array is empty.\n        if not lst:\n            return 0\n        (other code)\n\n# [core concept]\n    'non-negative integers': These are integers that are greater than or equal to 0.\n    Explanation: In the context of the problem, we are dealing with arrays of positive integers, but the requirement specifies non-negative integers, which includes zero.\n\n# [phrase showing quantity relationship]\n    'positive integers': This phrase indicates that we are only interested in integers that are greater than 0.\n    Explanation: For example, in the requirement, we need to return the largest integer that is more than zero and appears at least as many times as the integer itself.\n\n# [degree adverb] \n    'largest': This adverb indicates that we are looking for the biggest integer that meets the given condition.\n    Explanation: For instance, if we have the array [3, 3, 2, 4, 4, 4], the largest integer that appears at least as many times as itself is 4.\n\n# [code logic]\n    The steps should be implemented sequentially. We need to iterate through the array to find the frequency of each integer, compare it with its value, and keep track of the largest integer that meets the condition.\n\n# [edge case] \n    search([2, 2, 3, 3, 3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their values, but 3 is the largest number.\n    search([3, 3, 2, 4, 4, 4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their values, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We can set the initial return value to -1 and then find the largest integer that meets the condition.\n\n# [core concept]\n    'bitwise AND operation': This is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. When applied to a list of integers, it results in a single integer where each bit is the result of the AND operation on the corresponding bits of the input integers.\n    Explanation: The bitwise AND operation is used to combine the bits of multiple numbers. If any bit in the position is 0 in any of the numbers, the result will also have a 0 in that position. The goal is to find the values of k that can make all elements of the array equal to 0 using the bitwise AND operation.\n\n# [phrase showing quantity relationship]\n    'more than': This phrase indicates that we need to find values of k that can achieve the goal when there are more than k elements considered.\n    Explanation: For example, if k = 2, we are looking for a combination of 2 elements from the array whose bitwise AND results in 0.\n\n# [degree adverb] \n    'largest': This adverb indicates that we are looking for the largest possible value of k that can achieve the goal.\n    Explanation: For instance, if k = 2, we need to find the largest possible subset of 2 elements that can be ANDed together to result in 0.\n\n# [code logic]\n    The steps should be implemented sequentially. We need to iterate through the array to find all possible subsets of size k, calculate their bitwise AND, and check if the result is 0.\n\n# [edge case] \n    how_many_times([], 'a') = 0\n    Explanation: Since the array is empty, there are no elements to perform the bitwise AND operation, so the result is 0.\n    how_many_times([1], 1) = 1\n    Explanation: The array contains only one element, and the bitwise AND of one element with itself is the element itself, so the result is 1.\n    how_many_times([0, 0, 0], 0) = 3\n    Explanation: The array contains three zeros, and the bitwise AND of any number of zeros is 0, so the result is 3.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case where the array is empty.\n        if not lst:\n            return 0\n        (other code)", "- name: \nBitwise AND Analysis Solution\n\n- content: \nThe problem can be solved by analyzing the bitwise AND properties of the elements in the array. The goal is to find all possible values of k such that we can reduce all elements to 0 using elimination operations with parameter k.\n\n**Solution Approach:**\n1. For each possible value of k (from 1 to n), check if we can reduce all elements to 0 using k elements.\n2. For each value of k, generate all possible sets of k elements.\n3. For each set, calculate the bitwise AND of the elements in the set.\n4. If the result of the bitwise AND operation is 0, then k is a valid value.\n5. Collect all valid k values and output them in increasing order.\n\n**Algorithm:**\n- Use a brute force approach to iterate over all possible values of k.\n- For each k, use combinations to generate all possible sets of k elements.\n- For each set, compute the bitwise AND and check if it's 0.\n- If the result is 0, add k to the list of valid k values.\n- Sort and output the valid k values.\n\n**Edge Cases:**\n- Handle cases where all elements are already 0.\n- Handle cases where there is only one element in the array.\n- Ensure that the bitwise AND operation is correctly implemented to handle large numbers.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'bitwise AND operation': This operation is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. It's used to manipulate bits in binary numbers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a brute force approach to iterate over all possible values of k and check if we can reduce all elements to 0 using k elements. This involves generating all possible sets of k elements and computing the bitwise AND for each set.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'bitwise AND operation': This operation is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. It's used to manipulate bits in binary numbers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a brute force approach to iterate over all possible values of k and check if we can reduce all elements to 0 using k elements. This involves generating all possible sets of k elements and computing the bitwise AND for each set.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'bitwise AND operation': This operation is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. It's used to manipulate bits in binary numbers.\n\n# [phrase showing quantity relationship]\n    'more than': means that we need to find integers more than 0.\n    'at least as many times': means that we need to find the integer whose appearances are greater than or equal to its value.\n\n# [degree adverb] \n    'largest': means that we need the largest integer that appears greater than or equal to its value.\n\n# [code logic]\n    There are no steps that can be implemented simultaneously. All 4 steps should be implemented step by step.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need.\n\n# [core concept]\n    'elimination': This operation involves choosing k distinct indices, calculating the bitwise AND of the elements at those indices, and subtracting this result from each of the chosen elements.\n\n# [phrase showing quantity relationship]\n    'with parameter k': means that the operation is performed with a specific value of k.\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a solution approach that involves checking all possible values of k to see if we can reduce all elements to 0 using elimination operations with parameter k.\n\n# [edge case] \n    how_many_times('', 'a') = 0\n    Explanation: Since the original string is empty, the substring cannot appear, so the expected output is 0.\n    how_many_times('abc', '') = 4\n    Explanation: '' appears four times in the original string. 'abc'.count('')=2\n\n# [extra code for edge case]\n    Extra code are needed to handle the edge case.\n        if not string:\n            return 0\n        elif not substring:\n            return len(string)+1\n        (other code)\n\n# [core concept]\n    'bitwise AND operation': This operation is a binary operation that takes two bits and returns 1 if both bits are 1, otherwise, it returns 0. It's used to manipulate bits in binary numbers.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The plan suggests a brute force approach to iterate over all possible values of k and check if we can reduce all elements to 0 using k elements. This involves generating all possible sets of k elements and computing the bitwise AND for each set.\n\n# [edge case] \n    search([2,2,3,3,3]) = 3\n    Explanation: Both 2 and 3 appear more than or equal to their value, but 3 is the largest number.\n    search([3,3,2,4,4,4]) = -1\n    Explanation: Number 2 appears one time, number 3 appears two times, number 4 appears three times, none of them appear more than or equal to their value, so the function returns -1.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. We could set the original return answer to -1 and then find the largest integer that meets the need."]
----------
False
----------
0
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Technically, each cyclic shift consists of two consecutive actions: You may select arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment. Then you replace the segment a[l

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
multi-gen-prompt:
 The new generation external memory contains an array of integers a[1 … n] = [a_1, a_2, …, a_n]. This type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place. Each cyclic shift consists of selecting arbitrary indices l and r (1 ≤ l < r ≤ n) as the boundaries of the segment, then replacing the segment a[l … r] with its cyclic shift to

Input

The first line contains an integer t (1 ≤ t ≤ 1000) — the number of test cases.

The next 2t lines contain the descriptions of the test cases. 

The first line of each test case description contains an integer n (2 ≤ n ≤ 50) — the length of the array. The second line consists of space-separated elements of the array a_i (-10^9 ≤ a_i ≤ 10^9). Elements of array a may repeat and don't have to be unique.

Output

Print t answers to all input test cases. 

The first line of the answer of each test case should contain an integer k (0 ≤ k ≤ n) — the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as "l r d" (without quotes) where l and r (1 ≤ l < r ≤ n) are the boundaries of the segment being shifted, while d (1 ≤ d ≤ r - l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.

Note that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.

If the given array a is already sorted, one of the possible answers is k = 0 and an empty sequence of cyclic shifts.

If there are several possible answers, you may print any of them.

Example

Input


4
2
2 1
3
1 2 1
4
2 4 1 3
5
2 5 1 4 3


Output


1
1 2 1
1
1 3 2
3
2 4 1
2 3 1
1 3 2
4
2 4 2
1 5 3
1 2 1
1 3 1

Note

Explanation of the fourth data set in the example: 

  1. The segment a[2 … 4] is selected and is shifted to the left by 2: [2, \color{blue}{5, 1, 4}, 3] \longrightarrow [2, \color{blue}{4, 5, 1}, 3] 
  2. The segment a[1 … 5] is then selected and is shifted to the left by 3: [\color{blue}{2, 4, 5, 1, 3}] \longrightarrow [\color{blue}{1, 3, 2, 4, 5}] 
  3. After that the segment a[1 … 2] is selected and is shifted to the left by 1: [\color{blue}{1, 3}, 2, 4, 5] \longrightarrow [\color{blue}{3, 1}, 2, 4, 5] 
  4. And in the end the segment a[1 … 3] is selected and is shifted to the left by 1: [\color{blue}{3, 1, 2}, 4, 5] \longrightarrow [\color{blue}{1, 2, 3}, 4, 5] 
generating with deepseek-coder
----------
['def perform_cyclic_shift(a, l, r, d):\n    segment = a[l-1:r]\n    shifted_segment = segment[d:] + segment[:d]\n    a[l-1:r] = shifted_segment\n    return a\n\ndef insertion_sort_with_cyclic_shifts(n, a):\n    shifts = []\n    for i in range(1, n):\n        key = a[i]\n        j = i - 1\n        while j >= 0 and a[j] > key:\n            if len(shifts) < n:\n                shifts.append((j+1, i+1, 1))\n            a = perform_cyclic_shift(a, j+1, i+1, 1)\n            j -= 1\n        a[j+1] = key\n    return shifts\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index+1:index+n+1]))\n        index += n + 1\n        \n        shifts = insertion_sort_with_cyclic_shifts(n, a)\n        results.append(str(len(shifts)))\n        for shift in shifts:\n            results.append(f"{shift[0]} {shift[1]} {shift[2]}")\n    \n    print("\\n".join(results))', 'def f1(n, a):\n    shifts = []\n    for i in range(n):\n        min_index = i\n        for j in range(i + 1, n):\n            if a[j] < a[min_index]:\n                min_index = j\n        if min_index != i:\n            shift_distance = min_index - i\n            shifts.append((i + 1, min_index + 1, shift_distance + 1))\n            a = a[:i] + [a[min_index]] + a[i:min_index] + a[min_index + 1:]\n    return shifts\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        shifts = f1(n, a)\n        print(len(shifts))\n        for shift in shifts:\n            print(*shift)', 'def sort_array_with_shifts(n, array):\n    shifts = []\n    for i in range(n):\n        min_index = i\n        for j in range(i + 1, n):\n            if array[j] < array[min_index]:\n                min_index = j\n        if min_index != i:\n            shift_amount = min_index - i\n            shifts.append((i + 1, min_index + 1, shift_amount))\n            # Perform the shift\n            array = array[:i] + [array[min_index]] + array[i:min_index] + array[min_index+1:]\n    return shifts\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        shifts = sort_array_with_shifts(n, array)\n        print(len(shifts))\n        for shift in shifts:\n            print(*shift)', 'def f1(n, a):\n    actions = []\n    for i in range(n):\n        if a[i] != i + 1:\n            l = i + 1\n            r = n\n            while l < r:\n                d = (r - l) // 2\n                actions.append((l, r, d))\n                a[l-1:r] = [a[l-1+d]] + a[l:l+d] + a[l+d:r]\n                l += 1\n                r -= 1\n    return actions\n\ndef f2(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        actions = f1(n, a)\n        results.append(str(len(actions)))\n        for action in actions:\n            results.append(f"{action[0]} {action[1]} {action[2]}")\n    return results\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        a = list(map(int, data[index+1:index+n+1]))\n        test_cases.append((n, a))\n        index += n + 1\n    \n    results = f2(t, test_cases)\n    for result in results:\n        print(result)', 'def simulate_bubble_sort_with_cyclic_shifts():\n    def perform_cyclic_shift(arr, l, r, d):\n        n = len(arr)\n        segment = arr[l-1:r]\n        shifted_segment = segment[d:] + segment[:d]\n        arr[l-1:r] = shifted_segment\n        return l, r, d\n\n    def is_sorted(arr):\n        return all(arr[i] <= arr[i+1] for i in range(len(arr) - 1))\n\n    def bubble_sort_with_shifts(arr):\n        operations = []\n        n = len(arr)\n        for i in range(n):\n            min_index = i\n            for j in range(i+1, n):\n                if arr[j] < arr[min_index]:\n                    min_index = j\n            if min_index != i:\n                d = (min_index - i) % (n - i)  # Calculate the shift distance\n                l, r = i + 1, min_index + 1\n                operations.append((l, r, d))\n                perform_cyclic_shift(arr, l, r, d)\n            if is_sorted(arr):\n                break\n        return operations\n\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        operations = bubble_sort_with_shifts(arr)\n        results.append(operations)\n    \n    for i, operations in enumerate(results):\n        print(len(operations))\n        for op in operations:\n            print(*op)\n\nif __name__ == "__main__":\n    simulate_bubble_sort_with_cyclic_shifts()', 'def f1(n, a):\n    actions = []\n    for i in range(n):\n        if a[i] != i + 1:\n            l = i\n            r = n\n            while l < r:\n                for j in range(r - l - 1):\n                    actions.append((l + 1, r, j + 1))\n                l += 1\n            break\n    return actions\n\ndef f2(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, a = case\n        actions = f1(n, a)\n        results.append(str(len(actions)))\n        for action in actions:\n            results.append(f"{action[0]} {action[1]} {action[2]}")\n    return results\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        test_cases.append((n, a))\n    \n    results = f2(t, test_cases)\n    for result in results:\n        print(result)', 'def f1(n, a):\n    shifts = []\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if a[j] < a[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            d = min_idx - i\n            shifts.append((i + 1, min_idx + 1, d))\n            # Perform the cyclic shift\n            a = a[:i] + [a[min_idx]] + a[i:min_idx] + a[min_idx + 1:]\n    return shifts\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        shifts = f1(n, a)\n        print(len(shifts))\n        for shift in shifts:\n            print(*shift)', 'def f1(n, a):\n    shifts = []\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if a[j] < a[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            d = min_idx - i\n            shifts.append((i + 1, min_idx + 1, d))\n            # Perform the cyclic shift\n            a = a[:i] + [a[min_idx]] + a[i:min_idx] + a[min_idx + 1:]\n    return shifts\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        shifts = f1(n, a)\n        print(len(shifts))\n        for shift in shifts:\n            print(*shift)', 'def f1(n, a):\n    shifts = []\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if a[j] < a[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            d = min_idx - i\n            shifts.append((i + 1, min_idx + 1, d))\n            # Perform the cyclic shift\n            a = a[:i] + [a[min_idx]] + a[i:min_idx] + a[min_idx + 1:]\n    return shifts\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        shifts = f1(n, a)\n        print(len(shifts))\n        for shift in shifts:\n            print(*shift)', 'def sort_array_with_shifts(n, array):\n    shifts = []\n    for i in range(n):\n        min_index = i\n        for j in range(i + 1, n):\n            if array[j] < array[min_index]:\n                min_index = j\n        if min_index != i:\n            shift_amount = min_index - i\n            shifts.append((i + 1, min_index + 1, shift_amount))\n            # Perform the shift\n            array = array[:i] + [array[min_index]] + array[i:min_index] + array[min_index+1:]\n    return shifts\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        array = list(map(int, input().split()))\n        shifts = sort_array_with_shifts(n, array)\n        print(len(shifts))\n        for shift in shifts:\n            print(*shift)']
----------
['- name: \nInsertion Sort with Cyclic Shifts\n\n- content: \nInsertion sort can also be adapted to use cyclic shifts, where each element is inserted into its correct position one at a time.\n\nSolution Approach:\n1. Start from the second element and compare it with the elements before it.\n2. If the current element is smaller than the previous element, perform a cyclic shift on the segment from the previous element to the current element.\n3. Continue until the array is sorted.\n4. Each insertion and shift counts as a shift operation.\n\nFunctional Correctness:\n- Similar to the previous two sorting methods, this solution ensures that no more than n cyclic shifts are used to sort the array.\n- Handles arrays with repeated elements and negative values.\n- If the array is already sorted, it will require no shifts, which is a valid output.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'cyclic shift\': The process of moving elements of an array to the left or right by a certain number of positions, with the elements that move out of the array\'s bounds reappearing at the other end.\n    Explanation: In this problem, cyclic shifts are used to sort the array by rearranging segments of the array. Each shift operation involves selecting a segment and rotating it by a specified offset.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. The approach involves iterating through the array and performing cyclic shifts on segments to sort the array. Each shift operation should be considered in the context of the entire sorting process.\n\n# [edge case] \n    Edge Case 1: Array with two elements\n    how_many_times([2, 1]) = 1\n    Explanation: The array is already sorted, so no shifts are needed. The output indicates that one shift operation was performed, which is not possible in this case.\n\n    Edge Case 2: Array with all identical elements\n    how_many_times([5, 5, 5, 5]) = 5\n    Explanation: All elements are identical, so any element can be chosen as the "largest integer that appears at least as many times as the integer itself". The output should be the value of the elements themselves, not the number of elements.\n\n    Edge Case 3: Array with negative numbers\n    how_many_times([-3, -1, -2, -2]) = -2\n    Explanation: The array contains negative numbers, and the requirement is to return the largest integer that appears at least as many times as itself. The output should be the largest negative number, which is -2.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n        if len(lst) == 2:\n            return 1  # No shifts needed for a sorted array of two elements\n        if all(x == lst[0] for x in lst):\n            return lst[0]  # Return any element if all elements are identical\n        if any(x < 0 for x in lst):\n            # Handle negative numbers as per the requirement\n            pass\n        (other code)', "- name: \nSorting with Randomized Shuffles\n\n- content: \n- **Approach**: Use a randomized approach to sort the array by randomly selecting segments and offsets for cyclic shifts until the array is sorted.\n- **Solution Steps**:\n  1. For each test case, initialize a counter for the number of shifts.\n  2. Check if the array is already sorted. If it is, output 0 shifts and exit.\n  3. Randomly select segments [l, r] and offsets d within their valid ranges.\n  4. Perform the cyclic shift on the selected segment and check if the array is sorted.\n  5. If the array is sorted, record the number of shifts and the actions taken.\n  6. Output the results for each test case.\n- **Edge Cases**:\n  - Handle arrays that are already sorted by outputting 0 shifts.\n  - Ensure the number of shifts does not exceed n by limiting the number of attempts or ensuring convergence to a sorted state.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'cyclic shift': The process of moving elements of an array to the left or right by a certain number of positions, with the elements that fall off from one end reappearing at the other end.\n    Explanation: In the given problem, cyclic shifts are used to rearrange segments of the array. This can be done by selecting a segment and shifting it to the left or right by a specified offset.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously. The solution involves randomly selecting segments and offsets for cyclic shifts until the array is sorted. This can be achieved by iterating through the array, selecting random segments, and applying cyclic shifts until the array is sorted.\n\n# [edge case] \n    Edge Case 1: Array is already sorted\n    Expected Output: 0 shifts\n    Explanation: If the array is already sorted, no shifts are needed, so the output should be 0 shifts.\n\n    Edge Case 2: Array with all elements the same\n    Expected Output: 1 shift\n    Explanation: If all elements in the array are the same, a single shift can sort the array. For example, if the array is [2, 2, 2], a shift by 1 will result in [2, 2, 2], which is sorted.\n\n    Edge Case 3: Large array with random elements\n    Expected Output: Varies, but typically less than n shifts\n    Explanation: For a large array with random elements, the number of shifts needed to sort the array will vary. However, due to the randomized approach, the number of shifts should not exceed n.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases. The core logic of the problem already includes handling of edge cases such as already sorted arrays and arrays with all elements the same. The randomized approach ensures that the number of shifts does not exceed n.", "- name: \nGreedy Algorithm with Local Shifts\n\n- content: \nA greedy approach is to make local shifts to bring elements into their correct positions one by one. This method assumes that making a series of local shifts can eventually lead to a sorted array.\n\n**Solution Approach:**\n1. Start with the entire array and find the first out-of-order element.\n2. Identify the correct position for this element and perform a cyclic shift to bring it to that position.\n3. Repeat for each out-of-order element until the array is sorted.\n4. Track each shift made.\n\n**Functional Correctness:**\nThis method will sort the array using cyclic shifts, but it may not always find the optimal sequence of shifts. It will handle all possible valid inputs and edge cases as specified in the problem description.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'cyclic shift': changing the position of elements in an array by moving elements in a circular manner.\n    Explanation: In this problem, a cyclic shift means that the segment of the array between indices l and r is rotated to the left by d positions. This is different from a simple left or right shift where elements wrap around the end of the array.\n\n# [phrase showing quantity relationship]\n    'more than': means that the value of the element at a certain position is greater than the value at the next position.\n    Explanation: In the context of sorting, an array is considered sorted if for every i, a[i] ≤ a[i+1].\n\n# [degree adverb] \n    'largest': refers to the element with the highest value in the array.\n    Explanation: In the context of sorting, the largest element should ideally be at the end of the sorted array.\n\n# [code logic]\n    The steps should be implement simultaneously.\n    For each element in the array, find its correct position and perform a cyclic shift to bring it to that position.\n    This can be done by iterating through the array and swapping elements until the array is sorted.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4]\n    Expected output: 0\n    Explanation: The array is already sorted, so no shifts are needed.\n\n    Edge case 2: [4, 3, 2, 1]\n    Expected output: 6\n    Explanation: To sort this array, we need to perform 6 shifts:\n        - Shift segment [4, 3] by 1 to the left.\n        - Shift segment [3, 2] by 1 to the left.\n        - Shift segment [2, 1] by 1 to the left.\n        - Shift segment [4, 3, 2] by 1 to the left.\n        - Shift segment [3, 2, 1] by 1 to the left.\n        - Shift segment [4, 3, 2, 1] by 1 to the left.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case.\n        if not array:\n            return 0\n        shifts = 0\n        for i in range(len(array)):\n            for j in range(i + 1, len(array)):\n                if array[i] > array[j]:\n                    shifts += 1\n        return shifts\n\n    This code counts the number of inversions in the array, which is equivalent to the number of shifts needed to sort the array.", "- name: \nBrute Force Sorting with Cyclic Shifts\n\n- content: \n- For each test case, we will use a brute force approach to sort the array.\n- We will iterate through the array and for each segment of the array, we will try all possible cyclic shifts.\n- We will keep track of the number of shifts required and the segments that were shifted.\n- If the array is sorted after a certain number of shifts, we will output the results.\n- If no sorting is needed, we will output 0 shifts.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'cyclic shift': The process of moving elements in a list to the left or right by a specified number of positions, with elements that move out one end reappearing at the other end.\n    Explanation: In this problem, cyclic shifts are used to rearrange segments of the array. The shift is performed circularly, meaning elements that move out one end are reinserted at the other end.\n\n# [phrase showing quantity relationship]\n    'more than': Indicates that a value must be greater than a certain amount.\n    Explanation: In the requirement, it is used to specify that the offset 'd' must be greater than 0 and less than or equal to the length of the segment being shifted.\n\n# [degree adverb] \n    'largest': Indicates that the value being referred to is the biggest or greatest in a set.\n    Explanation: In the requirement, it suggests that we should aim to find the largest possible segment to shift, as this might lead to a more efficient sorting method.\n\n# [code logic]\n    The steps should be implemented sequentially. For each test case, we need to:\n    1. Iterate through the array to find segments that are not sorted.\n    2. For each unsorted segment, try all possible cyclic shifts.\n    3. Check if the array is sorted after each shift.\n    4. If the array is sorted, record the number of shifts and the details of each shift.\n    5. Output the results.\n\n# [edge case] \n    Edge case 1: Array is already sorted\n    Example: [1, 2, 3, 4]\n    Expected output: 0 shifts\n    Explanation: If the array is already sorted, no shifts are needed, so the output should indicate 0 shifts.\n\n    Edge case 2: Small array with one possible shift\n    Example: [2, 1, 3]\n    Expected output: 1 shift\n    Explanation: The segment [2, 1] can be shifted by 1 to become [1, 2], which sorts the array.\n\n    Edge case 3: Large array with multiple shifts\n    Example: [5, 4, 3, 2, 1]\n    Expected output: Multiple shifts\n    Explanation: The array can be sorted by shifting segments and applying cyclic shifts. The exact number of shifts and the segments involved will depend on the specific arrangement of the array.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case of an already sorted array, as the plan already includes a check to stop the process if the array is sorted. For other edge cases, the plan should be sufficient to handle them by trying all possible cyclic shifts for unsorted segments.", "- name: \nSimulate Bubble Sort with Cyclic Shifts\n\n- content: \nThis solution simulates the bubble sort algorithm using cyclic shifts to sort the array. We will iterate through the array and perform cyclic shifts to bubble the smallest element to the front, then continue this process for the remaining subarray until the entire array is sorted. This approach is simple and ensures that we do not exceed the allowed number of shifts (n).\n\n**Steps:**\n1. For each test case, initialize an array to store the operations.\n2. Use a nested loop to simulate the bubble sort process.\n3. In each iteration, find the smallest element in the unsorted portion of the array and bring it to the front using cyclic shifts.\n4. Continue this process until the entire array is sorted.\n5. Output the number of operations and each operation.\n\n**Edge Cases:**\n- If the array is already sorted, return 0 operations.\n- If the array has only one element, return 0 operations.\n- If the array has two elements out of order, perform at least one shift to sort them.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'cyclic shift': the process of moving elements in a list to the left or right by a certain number of positions, with the elements that move out of the list on one end reappearing at the other end.\n    Explanation: In this problem, cyclic shifts are used to sort an array by repeatedly moving the smallest element found in the unsorted portion of the array to the front of the array using cyclic shifts.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    Steps 2-4 should be implemented in a nested loop where the outer loop iterates through the array to find the smallest element in the unsorted portion, and the inner loop performs cyclic shifts to bring this smallest element to the front.\n\n# [edge case] \n    Edge case 1:\n    Input: [1, 2, 3, 4, 5]\n    Explanation: The array is already sorted, so no operations are needed.\n    Expected output: 0\n\n    Edge case 2:\n    Input: [2, 1]\n    Explanation: The array has only two elements out of order, so one shift is needed to sort them.\n    Expected output: 1\n    1 2 1\n\n    Edge case 3:\n    Input: [4, 3, 2, 1]\n    Explanation: The array is not sorted, and the smallest element 1 is at the end. We need to perform cyclic shifts to bring it to the front.\n    Expected output: 3\n    2 4 1\n    2 3 1\n    1 3 2\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    For edge case 1, we can directly return 0 operations if the array is already sorted.\n    For edge case 2, we can handle the two-element case directly in the main loop.\n    For edge case 3, we need to ensure that we handle the cyclic shift correctly to bring the smallest element to the front.", '- name: \nBubble Sort Simulation\n- content: \nThe bubble sort algorithm can be simulated using cyclic shifts. We can treat each swap in the bubble sort as a cyclic shift of a small segment of the array. This approach involves repeatedly finding and shifting the incorrect pair until the array is sorted.\n\n**Solution Plan:**\n1. For each test case, initialize a counter for the number of shifts.\n2. Simulate the bubble sort process by repeatedly finding the first incorrect pair (a_i > a_{i+1}) and shifting the segment between them to correct it.\n3. Continue this process until the array is sorted.\n4. Output the number of shifts and the details of each shift.\n\nThis solution is more specific to simulating a known sorting algorithm and may not explore other sorting methods as thoroughly as the brute force approach.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    \'cyclic shift\': the process of moving elements in a list to the left or right by a certain number of positions, with elements that move out of the list on one end reappearing at the other end.\n    Explanation: In this problem, cyclic shifts are used to simulate the sorting process by rearranging segments of the array.\n\n# [phrase showing quantity relationship]\n    \'more than\': means that we need to find integers greater than a certain value.\n    Explanation: In the requirement, this phrase is used to describe the condition for sorting the array, where each element must be compared with the next one to determine if a swap is needed.\n\n# [degree adverb] \n    \'largest\': means that we need to find the biggest integer in the array.\n    Explanation: In the requirement, this adverb is used to describe the goal of sorting the array, where the largest element should be placed at the end of the array after sorting.\n\n# [code logic]\n    The steps should be implement simultaneously.\n    The process involves finding the first incorrect pair (a_i > a_{i+1}) and shifting the segment between them to correct it. This could be done by writing a loop to iterate through the array and perform swaps as needed.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4] = 0\n    Explanation: The array is already sorted, so no shifts are needed.\n    Edge case 2: [4, 3, 2, 1] = 6\n    Explanation: The array is in reverse order, so multiple shifts are needed to sort it. The correct output would involve multiple "l r d" operations to sort the array.\n    Edge case 3: [2, 2, 2, 1] = 3\n    Explanation: The array contains duplicates, and the correct output would involve shifts to move the 1 to the correct position while maintaining the order of the other elements.\n\n# [extra code for edge case]\n    We need extra code to handle the edge cases.\n    For example, if the array is already sorted, we should return 0 without performing any shifts. If the array is in reverse order, we need to ensure that all elements are shifted to their correct positions. If the array contains duplicates, we need to handle these carefully to avoid disrupting the order of other elements.', "- name: \nGreedy Sorting with Cyclic Shifts\n\n- content: \nA greedy approach can be used to sort the array by making locally optimal choices at each step. The solution plan involves:\n1. For each test case, start with the entire array and try to find the smallest element out of place.\n2. Perform a cyclic shift to move the smallest element to its correct position.\n3. Repeat until the array is sorted.\n4. Output the results for each test case, including the number of shifts and the details of each shift.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'cyclic shift': the process of moving elements in a sequence to the left or right by a specified number of positions, with the end elements wrapping around to the opposite side.\n    Explanation: In the context of the problem, a cyclic shift means that after reaching the end of the array, the elements wrap around to the beginning. For example, shifting [1, 2, 3, 4] left by 1 results in [2, 3, 4, 1].\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find elements that are greater than a certain value.\n    'at least as many times': means that an element appears a minimum number of times in the array.\n\n# [degree adverb] \n    'largest': refers to finding the biggest element in the array.\n\n# [code logic]\n    The steps should be implemented sequentially as each step relies on the previous one.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 0\n    explanation: The array is already sorted, so no shifts are needed.\n    search([4, 3, 2, 1]) = 4\n    explanation: To sort [4, 3, 2, 1], we need to perform 4 cyclic shifts:\n        1. Shift segment [4, 3, 2] by 1 to [3, 2, 4]\n        2. Shift segment [3, 2, 4] by 1 to [2, 4, 3]\n        3. Shift segment [2, 4, 3] by 1 to [4, 3, 2]\n        4. Shift segment [4, 3, 2] by 1 to [3, 2, 4]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to check if the array is sorted or not and to perform cyclic shifts is already included in the plan.", "- name: \nGreedy Sorting with Cyclic Shifts\n\n- content: \nA greedy approach can be used to sort the array by making locally optimal choices at each step. The solution plan involves:\n1. For each test case, start with the entire array and try to find the smallest element out of place.\n2. Perform a cyclic shift to move the smallest element to its correct position.\n3. Repeat until the array is sorted.\n4. Output the results for each test case, including the number of shifts and the details of each shift.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'cyclic shift': the process of moving elements in a sequence to the left or right by a specified number of positions, with the end elements wrapping around to the opposite side.\n    Explanation: In the context of the problem, a cyclic shift means that after reaching the end of the array, the elements wrap around to the beginning. For example, shifting [1, 2, 3, 4] left by 1 results in [2, 3, 4, 1].\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find elements that are greater than a certain value.\n    'at least as many times': means that an element appears a minimum number of times in the array.\n\n# [degree adverb] \n    'largest': refers to finding the biggest element in the array.\n\n# [code logic]\n    The steps should be implemented sequentially as each step relies on the previous one.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 0\n    explanation: The array is already sorted, so no shifts are needed.\n    search([4, 3, 2, 1]) = 4\n    explanation: To sort [4, 3, 2, 1], we need to perform 4 cyclic shifts:\n        1. Shift segment [4, 3, 2] by 1 to [3, 2, 4]\n        2. Shift segment [3, 2, 4] by 1 to [2, 4, 3]\n        3. Shift segment [2, 4, 3] by 1 to [4, 3, 2]\n        4. Shift segment [4, 3, 2] by 1 to [3, 2, 4]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to check if the array is sorted or not and to perform cyclic shifts is already included in the plan.", "- name: \nGreedy Sorting with Cyclic Shifts\n\n- content: \nA greedy approach can be used to sort the array by making locally optimal choices at each step. The solution plan involves:\n1. For each test case, start with the entire array and try to find the smallest element out of place.\n2. Perform a cyclic shift to move the smallest element to its correct position.\n3. Repeat until the array is sorted.\n4. Output the results for each test case, including the number of shifts and the details of each shift.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'cyclic shift': the process of moving elements in a sequence to the left or right by a specified number of positions, with the end elements wrapping around to the opposite side.\n    Explanation: In the context of the problem, a cyclic shift means that after reaching the end of the array, the elements wrap around to the beginning. For example, shifting [1, 2, 3, 4] left by 1 results in [2, 3, 4, 1].\n\n# [phrase showing quantity relationship]\n    'more than': indicates that we need to find elements that are greater than a certain value.\n    'at least as many times': means that an element appears a minimum number of times in the array.\n\n# [degree adverb] \n    'largest': refers to finding the biggest element in the array.\n\n# [code logic]\n    The steps should be implemented sequentially as each step relies on the previous one.\n\n# [edge case] \n    search([1, 2, 3, 4]) = 0\n    explanation: The array is already sorted, so no shifts are needed.\n    search([4, 3, 2, 1]) = 4\n    explanation: To sort [4, 3, 2, 1], we need to perform 4 cyclic shifts:\n        1. Shift segment [4, 3, 2] by 1 to [3, 2, 4]\n        2. Shift segment [3, 2, 4] by 1 to [2, 4, 3]\n        3. Shift segment [2, 4, 3] by 1 to [4, 3, 2]\n        4. Shift segment [4, 3, 2] by 1 to [3, 2, 4]\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic to check if the array is sorted or not and to perform cyclic shifts is already included in the plan.", "- name: \nGreedy Algorithm with Local Shifts\n\n- content: \nA greedy approach is to make local shifts to bring elements into their correct positions one by one. This method assumes that making a series of local shifts can eventually lead to a sorted array.\n\n**Solution Approach:**\n1. Start with the entire array and find the first out-of-order element.\n2. Identify the correct position for this element and perform a cyclic shift to bring it to that position.\n3. Repeat for each out-of-order element until the array is sorted.\n4. Track each shift made.\n\n**Functional Correctness:**\nThis method will sort the array using cyclic shifts, but it may not always find the optimal sequence of shifts. It will handle all possible valid inputs and edge cases as specified in the problem description.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'cyclic shift': changing the position of elements in an array by moving elements in a circular manner.\n    Explanation: In this problem, a cyclic shift means that the segment of the array between indices l and r is rotated to the left by d positions. This is different from a simple left or right shift where elements wrap around the end of the array.\n\n# [phrase showing quantity relationship]\n    'more than': means that the value of the element at a certain position is greater than the value at the next position.\n    Explanation: In the context of sorting, an array is considered sorted if for every i, a[i] ≤ a[i+1].\n\n# [degree adverb] \n    'largest': refers to the element with the highest value in the array.\n    Explanation: In the context of sorting, the largest element should ideally be at the end of the sorted array.\n\n# [code logic]\n    The steps should be implement simultaneously.\n    For each element in the array, find its correct position and perform a cyclic shift to bring it to that position.\n    This can be done by iterating through the array and swapping elements until the array is sorted.\n\n# [edge case] \n    Edge case 1: [1, 2, 3, 4]\n    Expected output: 0\n    Explanation: The array is already sorted, so no shifts are needed.\n\n    Edge case 2: [4, 3, 2, 1]\n    Expected output: 6\n    Explanation: To sort this array, we need to perform 6 shifts:\n        - Shift segment [4, 3] by 1 to the left.\n        - Shift segment [3, 2] by 1 to the left.\n        - Shift segment [2, 1] by 1 to the left.\n        - Shift segment [4, 3, 2] by 1 to the left.\n        - Shift segment [3, 2, 1] by 1 to the left.\n        - Shift segment [4, 3, 2, 1] by 1 to the left.\n\n# [extra code for edge case]\n    We need extra code to handle the edge case.\n        if not array:\n            return 0\n        shifts = 0\n        for i in range(len(array)):\n            for j in range(i + 1, len(array)):\n                if array[i] > array[j]:\n                    shifts += 1\n        return shifts\n\n    This code counts the number of inversions in the array, which is equivalent to the number of shifts needed to sort the array."]
----------
True
----------
6
multi-gen-prompt:
 The robot is situated on a checkered rectangular board of size n × m (n rows, m columns). The rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right.

The robot can move from the current cell to one of the four adjacent cells. Each cell contains a symbol indicating the direction in which the robot will move: 'L' for left, 'R' for right, 'D' for down, and 'U' for up.

The robot can start its movement from any cell on the board. It moves to the

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
multi-gen-prompt:
 The robot is located on a checkered rectangular board of size n × m (n rows, m columns). The rows in the board are numbered from 1 to n from top to bottom, and the columns — from 1 to m from left to right. The robot is able to move from the current cell to one of the four cells adjacent by side. Each cell has one of the symbols 'L', 'R', 'D' or 'U' written on it, indicating the direction in which the robot will move when it gets in that cell — left, right, down or up, respectively. The robot can

Input

The first line contains an integer t (1 ≤ t ≤ 10000) — the number of test cases in the test.

Each test case's description is preceded by a blank line. Next is a line that contains integers n and m (1 ≤ n ≤ 2000; 1 ≤ m ≤ 2000) — the height and width of the board. This line followed by n lines, the i-th of which describes the i-th line of the board. Each of them is exactly m letters long and consists of symbols 'L', 'R', 'D' and 'U'.

It is guaranteed that the sum of sizes of all boards in the input does not exceed 4⋅10^6.

Output

For each test case, output three integers r, c and d (1 ≤ r ≤ n; 1 ≤ c ≤ m; d ≥ 0), which denote that the robot should start moving from cell (r, c) to make the maximum number of moves d. If there are several answers, output any of them.

Example

Input


7

1 1
R

1 3
RRL

2 2
DL
RU

2 2
UD
RU

3 2
DL
UL
RU

4 4
RRRD
RUUD
URUD
ULLR

4 4
DDLU
RDDU
UUUU
RDLD


Output


1 1 1
1 1 3
1 1 4
2 1 3
3 1 5
4 3 12
1 1 4
generating with deepseek-coder
----------
['def read_ints():\n    return list(map(int, input().split()))\n\ndef read_board(n, m):\n    board = []\n    for _ in range(n):\n        board.append(input().strip())\n    return board\n\ndef move_robot(board, n, m, start_row, start_col):\n    visited = [[False] * m for _ in range(n)]\n    steps = 0\n    row, col = start_row - 1, start_col - 1\n    \n    while True:\n        if visited[row][col]:\n            return steps  # Robot revisits a cell, stops moving\n        visited[row][col] = True\n        direction = board[row][col]\n        if direction == \'L\':\n            col -= 1\n        elif direction == \'R\':\n            col += 1\n        elif direction == \'D\':\n            row += 1\n        elif direction == \'U\':\n            row -= 1\n        \n        if not (0 <= row < n and 0 <= col < m):\n            return steps + 1  # Robot moves out of bounds\n        \n        steps += 1\n\ndef solve(board, n, m):\n    max_steps = 0\n    best_start = (1, 1)\n    \n    for start_row in range(n):\n        for start_col in range(m):\n            steps = move_robot(board, n, m, start_row + 1, start_col + 1)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (start_row + 1, start_col + 1)\n    \n    return best_start[0], best_start[1], max_steps\n\nif __name__ == "__main__":\n    while True:\n        try:\n            t = int(input())\n            break\n        except ValueError:\n            print("Please provide a valid number of test cases.")\n    \n    for _ in range(t):\n        n, m = read_ints()\n        board = read_board(n, m)\n        r, c, d = solve(board, n, m)\n        print(r, c, d)', 'def simulate_robot(board, n, m):\n    # Count the frequency of each direction in each row and column\n    row_freq = [[0] * 4 for _ in range(n)]\n    col_freq = [[0] * 4 for _ in range(m)]\n    \n    direction_map = {\'L\': 0, \'R\': 1, \'D\': 2, \'U\': 3}\n    directions = [\'L\', \'R\', \'D\', \'U\']\n    \n    for i in range(n):\n        for j in range(m):\n            direction = board[i][j]\n            row_freq[i][direction_map[direction]] += 1\n            col_freq[j][direction_map[direction]] += 1\n    \n    # Determine the most frequent direction in each row and column\n    row_most_freq = [max(range(4), key=lambda x: row_freq[i][x]) for i in range(n)]\n    col_most_freq = [max(range(4), key=lambda x: col_freq[j][x]) for j in range(m)]\n    \n    # Simulate the robot\'s movement from each cell to find the maximum number of moves\n    max_moves = -1\n    best_r, best_c = -1, -1\n    \n    for r in range(n):\n        for c in range(m):\n            moves = 0\n            visited = [[False] * m for _ in range(n)]\n            x, y = r, c\n            \n            while True:\n                if visited[x][y]:\n                    break\n                visited[x][y] = True\n                direction = board[x][y]\n                if direction == \'L\':\n                    y -= 1\n                elif direction == \'R\':\n                    y += 1\n                elif direction == \'D\':\n                    x += 1\n                elif direction == \'U\':\n                    x -= 1\n                \n                if x < 0 or x >= n or y < 0 or y >= m:\n                    moves += 1\n                    break\n                \n                moves += 1\n            \n            if moves > max_moves:\n                max_moves = moves\n                best_r, best_c = r + 1, c + 1  # Convert to 1-based index\n    \n    return best_r, best_c, max_moves\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        board = []\n        for i in range(n):\n            board.append(data[index + 2 + i])\n        index += 2 + n\n        \n        r, c, d = simulate_robot(board, n, m)\n        results.append(f"{r} {c} {d}")\n    \n    print("\\n".join(results))', 'from collections import deque\n\ndef bfs(board, n, m):\n    max_moves = 0\n    start_cell = (0, 0)\n    directions = {\'L\': (0, -1), \'R\': (0, 1), \'D\': (1, 0), \'U\': (-1, 0)}\n    \n    for r in range(n):\n        for c in range(m):\n            visited = [[False] * m for _ in range(n)]\n            queue = deque([(r, c, 0)])  # (row, col, moves)\n            visited[r][c] = True\n            \n            while queue:\n                x, y, moves = queue.popleft()\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (r + 1, c + 1)  # Convert to 1-based index\n                \n                for direction, (dx, dy) in directions.items():\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:\n                        if board[nx][ny] == direction:\n                            visited[nx][ny] = True\n                            queue.append((nx, ny, moves + 1))\n    \n    return start_cell[0], start_cell[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        board = []\n        for i in range(n):\n            board.append(data[index])\n            index += 1\n        \n        r, c, d = bfs(board, n, m)\n        print(r, c, d)\n\nif __name__ == "__main__":\n    main()', 'def f1(n, m, board):\n    # Count the occurrences of each direction\n    direction_counts = {\'L\': 0, \'R\': 0, \'D\': 0, \'U\': 0}\n    for row in board:\n        for direction in row:\n            direction_counts[direction] += 1\n    \n    # Determine the most common direction\n    max_direction = max(direction_counts, key=direction_counts.get)\n    \n    # Select the starting cell based on the most common direction\n    if max_direction == \'L\':\n        r, c = 1, 1\n    elif max_direction == \'R\':\n        r, c = 1, m\n    elif max_direction == \'D\':\n        r, c = 1, 1\n    elif max_direction == \'U\':\n        r, c = n, 1\n    \n    # Calculate the maximum number of moves based on the greedy choice of the most common direction\n    if max_direction == \'L\':\n        d = direction_counts[\'L\']\n    elif max_direction == \'R\':\n        d = direction_counts[\'R\']\n    elif max_direction == \'D\':\n        d = direction_counts[\'D\']\n    elif max_direction == \'U\':\n        d = direction_counts[\'U\']\n    \n    return r, c, d\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        board = []\n        for i in range(n):\n            board.append(data[index])\n            index += 1\n        \n        r, c, d = f1(n, m, board)\n        results.append(f"{r} {c} {d}")\n    \n    print("\\n".join(results))', 'def max_moves(board, n, m):\n    dp = [[0] * m for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n    \n    def move(r, c):\n        if r < 0 or r >= n or c < 0 or c >= m or visited[r][c]:\n            return 0\n        visited[r][c] = True\n        next_dir = board[r][c]\n        if next_dir == \'L\':\n            return 1 + move(r, c - 1)\n        elif next_dir == \'R\':\n            return 1 + move(r, c + 1)\n        elif next_dir == \'D\':\n            return 1 + move(r + 1, c)\n        elif next_dir == \'U\':\n            return 1 + move(r - 1, c)\n        return 0\n    \n    max_moves = 0\n    start_cell = (0, 0)\n    \n    for i in range(n):\n        for j in range(m):\n            visited = [[False] * m for _ in range(n)]\n            moves = move(i, j)\n            if moves > max_moves:\n                max_moves = moves\n                start_cell = (i + 1, j + 1)\n    \n    return start_cell[0], start_cell[1], max_moves\n\nif __name__ == "__main__":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        board = []\n        for i in range(index + 2, index + 2 + n):\n            board.append(data[i])\n        index += 2 + n\n        \n        r, c, d = max_moves(board, n, m)\n        print(r, c, d)', 'def read_ints():\n    return list(map(int, input().split()))\n\ndef read_board(n, m):\n    board = []\n    for _ in range(n):\n        board.append(input().strip())\n    return board\n\ndef move_robot(board, n, m, start_row, start_col):\n    visited = [[False] * m for _ in range(n)]\n    steps = 0\n    row, col = start_row - 1, start_col - 1\n    \n    while True:\n        if visited[row][col]:\n            return steps  # Robot revisits a cell, stops moving\n        visited[row][col] = True\n        direction = board[row][col]\n        if direction == \'L\':\n            col -= 1\n        elif direction == \'R\':\n            col += 1\n        elif direction == \'D\':\n            row += 1\n        elif direction == \'U\':\n            row -= 1\n        \n        if not (0 <= row < n and 0 <= col < m):\n            return steps + 1  # Robot moves out of bounds\n        \n        steps += 1\n\ndef solve(board, n, m):\n    max_steps = 0\n    best_start = (1, 1)\n    \n    for start_row in range(n):\n        for start_col in range(m):\n            steps = move_robot(board, n, m, start_row + 1, start_col + 1)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (start_row + 1, start_col + 1)\n    \n    return best_start[0], best_start[1], max_steps\n\nif __name__ == "__main__":\n    while True:\n        try:\n            t = int(input())\n            break\n        except ValueError:\n            print("Please provide a valid number of test cases.")\n    \n    for _ in range(t):\n        n, m = read_ints()\n        board = read_board(n, m)\n        r, c, d = solve(board, n, m)\n        print(r, c, d)', 'from collections import deque\n\ndef bfs(board, n, m):\n    max_moves = 0\n    start_cell = (0, 0)\n    directions = {\'L\': (0, -1), \'R\': (0, 1), \'D\': (1, 0), \'U\': (-1, 0)}\n    \n    for r in range(n):\n        for c in range(m):\n            visited = [[False] * m for _ in range(n)]\n            queue = deque([(r, c, 0)])  # (row, col, moves)\n            visited[r][c] = True\n            \n            while queue:\n                x, y, moves = queue.popleft()\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (r + 1, c + 1)  # Convert to 1-based index\n                \n                for direction, (dx, dy) in directions.items():\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:\n                        if board[nx][ny] == direction:\n                            visited[nx][ny] = True\n                            queue.append((nx, ny, moves + 1))\n    \n    return start_cell[0], start_cell[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        board = []\n        for i in range(n):\n            board.append(data[index])\n            index += 1\n        \n        r, c, d = bfs(board, n, m)\n        print(r, c, d)\n\nif __name__ == "__main__":\n    main()', 'def read_ints():\n    return list(map(int, input().split()))\n\ndef read_board(n, m):\n    board = []\n    for _ in range(n):\n        board.append(input().strip())\n    return board\n\ndef move_robot(board, n, m, start_row, start_col):\n    visited = [[False] * m for _ in range(n)]\n    steps = 0\n    row, col = start_row - 1, start_col - 1\n    \n    while True:\n        if visited[row][col]:\n            return steps  # Robot revisits a cell, stops moving\n        visited[row][col] = True\n        direction = board[row][col]\n        if direction == \'L\':\n            col -= 1\n        elif direction == \'R\':\n            col += 1\n        elif direction == \'D\':\n            row += 1\n        elif direction == \'U\':\n            row -= 1\n        \n        if not (0 <= row < n and 0 <= col < m):\n            return steps + 1  # Robot moves out of bounds\n        \n        steps += 1\n\ndef solve(board, n, m):\n    max_steps = 0\n    best_start = (1, 1)\n    \n    for start_row in range(n):\n        for start_col in range(m):\n            steps = move_robot(board, n, m, start_row + 1, start_col + 1)\n            if steps > max_steps:\n                max_steps = steps\n                best_start = (start_row + 1, start_col + 1)\n    \n    return best_start[0], best_start[1], max_steps\n\nif __name__ == "__main__":\n    while True:\n        try:\n            t = int(input())\n            break\n        except ValueError:\n            print("Please provide a valid number of test cases.")\n    \n    for _ in range(t):\n        n, m = read_ints()\n        board = read_board(n, m)\n        r, c, d = solve(board, n, m)\n        print(r, c, d)', 'from collections import deque\n\ndef bfs(board, n, m):\n    max_moves = 0\n    start_cell = (0, 0)\n    directions = {\'L\': (0, -1), \'R\': (0, 1), \'D\': (1, 0), \'U\': (-1, 0)}\n    \n    for r in range(n):\n        for c in range(m):\n            visited = [[False] * m for _ in range(n)]\n            queue = deque([(r, c, 0)])  # (row, col, moves)\n            visited[r][c] = True\n            \n            while queue:\n                x, y, moves = queue.popleft()\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (r + 1, c + 1)  # Convert to 1-based index\n                \n                for direction, (dx, dy) in directions.items():\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:\n                        if board[nx][ny] == direction:\n                            visited[nx][ny] = True\n                            queue.append((nx, ny, moves + 1))\n    \n    return start_cell[0], start_cell[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        board = []\n        for i in range(n):\n            board.append(data[index])\n            index += 1\n        \n        r, c, d = bfs(board, n, m)\n        print(r, c, d)\n\nif __name__ == "__main__":\n    main()', 'from collections import deque\n\ndef bfs(board, n, m):\n    max_moves = 0\n    start_cell = (0, 0)\n    directions = {\'L\': (0, -1), \'R\': (0, 1), \'D\': (1, 0), \'U\': (-1, 0)}\n    \n    for r in range(n):\n        for c in range(m):\n            visited = [[False] * m for _ in range(n)]\n            queue = deque([(r, c, 0)])  # (row, col, moves)\n            visited[r][c] = True\n            \n            while queue:\n                x, y, moves = queue.popleft()\n                \n                if moves > max_moves:\n                    max_moves = moves\n                    start_cell = (r + 1, c + 1)  # Convert to 1-based index\n                \n                for direction, (dx, dy) in directions.items():\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:\n                        if board[nx][ny] == direction:\n                            visited[nx][ny] = True\n                            queue.append((nx, ny, moves + 1))\n    \n    return start_cell[0], start_cell[1], max_moves\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        board = []\n        for i in range(n):\n            board.append(data[index])\n            index += 1\n        \n        r, c, d = bfs(board, n, m)\n        print(r, c, d)\n\nif __name__ == "__main__":\n    main()']
----------
["- name: \nHeuristic Approach with Predictive Movement\n\n- content: \nUse a heuristic to predict the robot's movement pattern based on the board's layout. For example, if a cell points to a direction that leads to a cycle or out of bounds, it might be beneficial to start from a different cell. Use this heuristic to guide the search for the optimal starting cell. Combine this with simulation to ensure correctness.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.", "- name: \nOptimized Simulation with Direction Tracking\n\n- content: \nTo optimize the simulation, we can track the movement patterns of the robot based on the directions given. This approach involves analyzing the direction frequencies and predicting where the robot is likely to exit the board first.\n\n**Solution Approach:**\n1. For each test case, count the occurrences of each direction ('L', 'R', 'D', 'U') in the board.\n2. Determine the direction that is most frequent in each row and column.\n3. Use this information to predict potential exit points for the robot starting from different cells.\n4. Simulate the robot's movement from these predicted starting points to find the one that results in the maximum number of moves.\n5. Output the results.\n\n**Handling Edge Cases:**\n- Single-cell boards will have a maximum of one move.\n- Boards with uniform directions will have a predictable number of moves based on the direction's cycle.\n- Boards with cyclic patterns will require careful tracking of visited cells to avoid infinite loops.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on given directions, and we need to find the optimal starting point to maximize the number of moves.\n\n# [phrase showing quantity relationship]\n    'most frequent': Indicates the direction that appears the most in each row and column.\n\n# [degree adverb] \n    'maximum': We aim to find the starting point that results in the highest number of moves.\n\n# [code logic]\n    The steps should be implemented simultaneously to analyze the board and determine the best starting point for the robot.\n\n# [edge case] \n    For a single-cell board:\n    Edge case: 1 1\n    R\n    Expected output: 1 1 1\n    Explanation: The robot starts in the only cell, and since there's only one move possible, the output is 1 1 1.\n\n    For a board with uniform directions:\n    Edge case: 1 3\n    RRL\n    Expected output: 1 1 3\n    Explanation: The most frequent direction in this row is 'R', so the robot will move right until it exits the board, resulting in 3 moves.\n\n    For a board with cyclic patterns:\n    Edge case: 4 4\n    UUUU\n    RDDU\n    UUUU\n    RDLD\n    Expected output: 1 1 4\n    Explanation: The most frequent direction in the first column is 'U', and in the first row is 'R'. The robot will move up and right, but due to the cyclic nature, it will end up in a predictable position after 4 moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge cases as the logic provided in the plan is sufficient to determine the optimal starting point and maximum number of moves.", "- name: \nUse Graph Traversal for Maximum Path\n\n- content: \n- For each test case, construct a graph where each cell is a node and there is an edge from node A to node B if moving from A to B is possible according to the board's direction.\n- Use a graph traversal algorithm (like BFS or DFS) to find the longest path starting from any cell.\n- Output the starting cell and the length of the longest path for each test case.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph Traversal': This involves exploring nodes and edges in a graph to find the shortest or longest path, typically using algorithms like Breadth-First Search (BFS) or Depth-First Search (DFS).\n    'Graph Construction': Building a graph from the board where each cell is a node and possible moves are edges.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps involve constructing a graph from the board, then using a graph traversal algorithm to find the longest path starting from any cell. This could be done using BFS or DFS.\n\n# [edge case] \n    For a 1x1 board with direction 'R':\n    - Input: 1 1, R\n    - Explanation: The robot can only move right, so it will move once and stop. The starting cell (1, 1) and the number of moves (d) is 1.\n    - Expected Output: 1 1 1\n\n    For a 1x3 board with directions 'RRL':\n    - Input: 1 3, RRL\n    - Explanation: The robot starts at (1, 1) and moves right three times before hitting the end of the board. The starting cell (1, 1) and the number of moves (d) is 3.\n    - Expected Output: 1 1 3\n\n    For a 2x2 board with directions 'DL' and 'RU':\n    - Input: 2 2, DL, RU\n    - Explanation: The robot starts at (1, 1) and moves down, then left. The starting cell (1, 1) and the number of moves (d) is 4 (2 moves down and 2 moves left).\n    - Expected Output: 1 1 4\n\n# [extra code for edge case]\n    No extra code is needed for the edge cases provided, as the logic in the plan should handle them correctly.", "- name: \nGreedy Approach with Direction Analysis\n\n- content: \nAnalyze the board to determine which direction is most likely to lead to the maximum number of moves. This approach assumes that certain directions will lead to longer paths and uses this knowledge to select a starting position.\n\n**Solution Approach:**\n1. For each test case, read the board dimensions and the board configuration.\n2. Determine which direction is most common across the board.\n3. Select a starting position based on the most common direction.\n4. Output the starting cell and the maximum number of moves based on the greedy choice.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on given directions.\n    Explanation: The robot can move left (L), right (R), down (D), or up (U) based on the symbol in each cell. The goal is to find the starting position that maximizes the number of moves.\n\n# [phrase showing quantity relationship]\n    No phrase showing quantity relationship\n\n# [degree adverb] \n    No degree adverb\n\n# [code logic]\n    The steps should be implement simultaneously.\n    For each test case:\n    1. Read the board dimensions and configuration.\n    2. Count the occurrences of each direction (L, R, D, U) across the board.\n    3. Determine the most common direction.\n    4. Select the starting cell (r, c) based on the most common direction.\n    5. Calculate the maximum number of moves (d) based on the greedy choice of the most common direction.\n\n# [edge case] \n    Test Case:\n    1 1\n    R\n    Edge Case:\n    Expected Output:\n    1 1 1\n    Explanation:\n    Since the board is of size 1x1 and only has one cell with direction 'R', the robot starts at (1, 1) and can make only 1 move.\n\n    Test Case:\n    1 3\n    RRL\n    Edge Case:\n    Expected Output:\n    1 1 3\n    Explanation:\n    The board is 1x3 with directions 'RRL'. The most common direction is 'R', so the robot starts at (1, 1) and can make 3 moves.\n\n# [extra code for edge case]\n    We do not need extra code to handle the edge case. The logic provided in the plan is sufficient to handle the edge case.", "- name: \nDynamic Programming with Memoization\n\n- content: \n- For each test case, use a 2D DP array to store the maximum number of moves for each cell.\n- Iterate over each cell and simulate the robot's movement, updating the DP array based on the number of moves.\n- Track the maximum number of moves and the corresponding starting cell.\n- Output the results.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It stops if it moves beyond the edge of the board or revisits a cell. The goal is to find the starting cell that allows the robot to make the maximum number of moves.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No degree adverb.\n\n# [code logic]\n    The plan suggests using Dynamic Programming with Memoization to solve the problem. For each cell, we need to simulate the robot's movement and update the DP array based on the number of moves. This requires iterating over each cell and checking all possible directions the robot can move.\n\n# [edge case] \n    Edge cases are not directly mentioned in the plan or requirement, but they are crucial for ensuring the robot's movement logic is robust. For example:\n    - A board with only one cell.\n    - A board where all cells direct the robot to move beyond the edge of the board.\n    - A board where all cells direct the robot to move in a loop, preventing it from making any progress.\n\n# [extra code for edge case]\n    We need extra code to handle edge cases where the board is very small or the robot's movement is restricted in a way that it cannot make any moves. For example, if the board has only one cell, the robot should start there and make one move. If all cells direct the robot to move beyond the edge, the robot should start at the edge and make one move before falling off.\n\n    Example extra code for handling edge cases:\n    ```python\n    if n == 1 and m == 1:\n        return 1, 1, 1\n    if all(board[i][j] == 'R' for i in range(n) for j in range(m)) or all(board[i][j] == 'L' for i in range(n) for j in range(m)) or all(board[i][j] == 'D' for i in range(n) for j in range(m)) or all(board[i][j] == 'U' for i in range(n) for j in range(m)):\n        return 1, 1, min(n * m, 1)\n    ```\n\nThis additional code ensures that the robot's movement logic is robust and can handle edge cases appropriately.", "- name: \nHeuristic Approach with Predictive Movement\n\n- content: \nUse a heuristic to predict the robot's movement pattern based on the board's layout. For example, if a cell points to a direction that leads to a cycle or out of bounds, it might be beneficial to start from a different cell. Use this heuristic to guide the search for the optimal starting cell. Combine this with simulation to ensure correctness.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.", "- name: \nUse Graph Traversal for Maximum Path\n\n- content: \n- For each test case, construct a graph where each cell is a node and there is an edge from node A to node B if moving from A to B is possible according to the board's direction.\n- Use a graph traversal algorithm (like BFS or DFS) to find the longest path starting from any cell.\n- Output the starting cell and the length of the longest path for each test case.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph Traversal': This involves exploring nodes and edges in a graph to find the shortest or longest path, typically using algorithms like Breadth-First Search (BFS) or Depth-First Search (DFS).\n    'Graph Construction': Building a graph from the board where each cell is a node and possible moves are edges.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps involve constructing a graph from the board, then using a graph traversal algorithm to find the longest path starting from any cell. This could be done using BFS or DFS.\n\n# [edge case] \n    For a 1x1 board with direction 'R':\n    - Input: 1 1, R\n    - Explanation: The robot can only move right, so it will move once and stop. The starting cell (1, 1) and the number of moves (d) is 1.\n    - Expected Output: 1 1 1\n\n    For a 1x3 board with directions 'RRL':\n    - Input: 1 3, RRL\n    - Explanation: The robot starts at (1, 1) and moves right three times before hitting the end of the board. The starting cell (1, 1) and the number of moves (d) is 3.\n    - Expected Output: 1 1 3\n\n    For a 2x2 board with directions 'DL' and 'RU':\n    - Input: 2 2, DL, RU\n    - Explanation: The robot starts at (1, 1) and moves down, then left. The starting cell (1, 1) and the number of moves (d) is 4 (2 moves down and 2 moves left).\n    - Expected Output: 1 1 4\n\n# [extra code for edge case]\n    No extra code is needed for the edge cases provided, as the logic in the plan should handle them correctly.", "- name: \nHeuristic Approach with Predictive Movement\n\n- content: \nUse a heuristic to predict the robot's movement pattern based on the board's layout. For example, if a cell points to a direction that leads to a cycle or out of bounds, it might be beneficial to start from a different cell. Use this heuristic to guide the search for the optimal starting cell. Combine this with simulation to ensure correctness.\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.\n\n## Example Output for Prompt 3:\n\n# [core concept]\n    'robot movement': The robot moves in a checkered rectangular board based on the direction indicated on each cell. It can move to adjacent cells and stops if it moves out of bounds or revisits a cell.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps in the plan should be implemented sequentially as each step builds upon the previous one. The robot's movement should be simulated from each cell to determine the maximum number of steps before it breaks.\n\n# [edge case] \n    Edge cases should be considered for each test case to ensure the robot's movement is correctly simulated. For example, a board with a single cell 'R' should start from cell (1, 1) to make 1 move.\n\n# [extra code for edge case]\n    Extra code is needed to handle the edge cases where the board is very small or has specific patterns that lead to immediate stopping or breaking.", "- name: \nUse Graph Traversal for Maximum Path\n\n- content: \n- For each test case, construct a graph where each cell is a node and there is an edge from node A to node B if moving from A to B is possible according to the board's direction.\n- Use a graph traversal algorithm (like BFS or DFS) to find the longest path starting from any cell.\n- Output the starting cell and the length of the longest path for each test case.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph Traversal': This involves exploring nodes and edges in a graph to find the shortest or longest path, typically using algorithms like Breadth-First Search (BFS) or Depth-First Search (DFS).\n    'Graph Construction': Building a graph from the board where each cell is a node and possible moves are edges.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps involve constructing a graph from the board, then using a graph traversal algorithm to find the longest path starting from any cell. This could be done using BFS or DFS.\n\n# [edge case] \n    For a 1x1 board with direction 'R':\n    - Input: 1 1, R\n    - Explanation: The robot can only move right, so it will move once and stop. The starting cell (1, 1) and the number of moves (d) is 1.\n    - Expected Output: 1 1 1\n\n    For a 1x3 board with directions 'RRL':\n    - Input: 1 3, RRL\n    - Explanation: The robot starts at (1, 1) and moves right three times before hitting the end of the board. The starting cell (1, 1) and the number of moves (d) is 3.\n    - Expected Output: 1 1 3\n\n    For a 2x2 board with directions 'DL' and 'RU':\n    - Input: 2 2, DL, RU\n    - Explanation: The robot starts at (1, 1) and moves down, then left. The starting cell (1, 1) and the number of moves (d) is 4 (2 moves down and 2 moves left).\n    - Expected Output: 1 1 4\n\n# [extra code for edge case]\n    No extra code is needed for the edge cases provided, as the logic in the plan should handle them correctly.", "- name: \nUse Graph Traversal for Maximum Path\n\n- content: \n- For each test case, construct a graph where each cell is a node and there is an edge from node A to node B if moving from A to B is possible according to the board's direction.\n- Use a graph traversal algorithm (like BFS or DFS) to find the longest path starting from any cell.\n- Output the starting cell and the length of the longest path for each test case.\n\n\nPlease read and understand the following inteperation before coding\n # [core concept]\n    'Graph Traversal': This involves exploring nodes and edges in a graph to find the shortest or longest path, typically using algorithms like Breadth-First Search (BFS) or Depth-First Search (DFS).\n    'Graph Construction': Building a graph from the board where each cell is a node and possible moves are edges.\n\n# [phrase showing quantity relationship]\n    No specific phrase showing quantity relationship.\n\n# [degree adverb] \n    No specific degree adverb.\n\n# [code logic]\n    The steps involve constructing a graph from the board, then using a graph traversal algorithm to find the longest path starting from any cell. This could be done using BFS or DFS.\n\n# [edge case] \n    For a 1x1 board with direction 'R':\n    - Input: 1 1, R\n    - Explanation: The robot can only move right, so it will move once and stop. The starting cell (1, 1) and the number of moves (d) is 1.\n    - Expected Output: 1 1 1\n\n    For a 1x3 board with directions 'RRL':\n    - Input: 1 3, RRL\n    - Explanation: The robot starts at (1, 1) and moves right three times before hitting the end of the board. The starting cell (1, 1) and the number of moves (d) is 3.\n    - Expected Output: 1 1 3\n\n    For a 2x2 board with directions 'DL' and 'RU':\n    - Input: 2 2, DL, RU\n    - Explanation: The robot starts at (1, 1) and moves down, then left. The starting cell (1, 1) and the number of moves (d) is 4 (2 moves down and 2 moves left).\n    - Expected Output: 1 1 4\n\n# [extra code for edge case]\n    No extra code is needed for the edge cases provided, as the logic in the plan should handle them correctly."]
----------
True
----------
2
